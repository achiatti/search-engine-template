{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_table/agg_table.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_table/agg_table.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nrequire('ui/paginated_table');\n\nrequire('ui/compile_recursive_directive');\n\nrequire('ui/agg_table/agg_table.less');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _modules = require('ui/modules');\n\nvar _agg_table = require('ui/agg_table/agg_table.html');\n\nvar _agg_table2 = _interopRequireDefault(_agg_table);\n\nvar _field_formats = require('ui/registry/field_formats');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_modules.uiModules.get('kibana').directive('kbnAggTable', function ($filter, config, Private, compileRecursiveDirective) {\n  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);\n  var numberFormatter = fieldFormats.getDefaultInstance('number').getConverterFor('text');\n\n  return {\n    restrict: 'E',\n    template: _agg_table2.default,\n    scope: {\n      table: '=',\n      perPage: '=?',\n      sort: '=?',\n      exportTitle: '=?',\n      showTotal: '=',\n      totalFunc: '='\n    },\n    controllerAs: 'aggTable',\n    compile: function compile($el) {\n      // Use the compile function from the RecursionHelper,\n      // And return the linking function(s) which it returns\n      return compileRecursiveDirective.compile($el);\n    },\n    controller: function controller($scope) {\n      var self = this;\n\n      self._saveAs = require('@elastic/filesaver').saveAs;\n      self.csv = {\n        separator: config.get('csv:separator'),\n        quoteValues: config.get('csv:quoteValues')\n      };\n\n      self.exportAsCsv = function (formatted) {\n        var csv = new Blob([self.toCsv(formatted)], { type: 'text/plain;charset=utf-8' });\n        self._saveAs(csv, self.csv.filename);\n      };\n\n      self.toCsv = function (formatted) {\n        var rows = $scope.table.rows;\n        var columns = formatted ? $scope.formattedColumns : $scope.table.columns;\n        var nonAlphaNumRE = /[^a-zA-Z0-9]/;\n        var allDoubleQuoteRE = /\"/g;\n\n        function escape(val) {\n          if (!formatted && _lodash2.default.isObject(val)) val = val.valueOf();\n          val = String(val);\n          if (self.csv.quoteValues && nonAlphaNumRE.test(val)) {\n            val = '\"' + val.replace(allDoubleQuoteRE, '\"\"') + '\"';\n          }\n          return val;\n        }\n\n        // escape each cell in each row\n        var csvRows = rows.map(function (row) {\n          return row.map(escape);\n        });\n\n        // add the columns to the rows\n        csvRows.unshift(columns.map(function (col) {\n          return escape(col.title);\n        }));\n\n        return csvRows.map(function (row) {\n          return row.join(self.csv.separator) + '\\r\\n';\n        }).join('');\n      };\n\n      $scope.$watch('table', function () {\n        var table = $scope.table;\n\n        if (!table) {\n          $scope.rows = null;\n          $scope.formattedColumns = null;\n          return;\n        }\n\n        self.csv.filename = ($scope.exportTitle || table.title() || 'table') + '.csv';\n        $scope.rows = table.rows;\n        $scope.formattedColumns = table.columns.map(function (col, i) {\n          var agg = $scope.table.aggConfig(col);\n          var field = agg.getField();\n          var formattedColumn = {\n            title: col.title,\n            filterable: field && field.filterable && agg.schema.group === 'buckets'\n          };\n\n          var last = i === table.columns.length - 1;\n\n          if (last || agg.schema.group === 'metrics') {\n            formattedColumn.class = 'visualize-table-right';\n          }\n\n          var isFieldNumeric = false;\n          var isFieldDate = false;\n          var aggType = agg.type;\n          if (aggType && aggType.type === 'metrics') {\n            if (aggType.name === 'top_hits') {\n              if (agg._opts.params.aggregate !== 'concat') {\n                // all other aggregate types for top_hits output numbers\n                // so treat this field as numeric\n                isFieldNumeric = true;\n              }\n            } else if (field) {\n              // if the metric has a field, check if it is either number or date\n              isFieldNumeric = field.type === 'number';\n              isFieldDate = field.type === 'date';\n            } else {\n              // if there is no field, then it is count or similar so just say number\n              isFieldNumeric = true;\n            }\n          } else if (field) {\n            isFieldNumeric = field.type === 'number';\n            isFieldDate = field.type === 'date';\n          }\n\n          if (isFieldNumeric || isFieldDate || $scope.totalFunc === 'count') {\n            var sum = function sum(tableRows) {\n              return _lodash2.default.reduce(tableRows, function (prev, curr) {\n                // some metrics return undefined for some of the values\n                // derivative is an example of this as it returns undefined in the first row\n                if (curr[i].value === undefined) return prev;\n                return prev + curr[i].value;\n              }, 0);\n            };\n\n            var formatter = agg.fieldFormatter('text');\n\n            switch ($scope.totalFunc) {\n              case 'sum':\n                if (!isFieldDate) {\n                  formattedColumn.total = formatter(sum(table.rows));\n                }\n                break;\n              case 'avg':\n                if (!isFieldDate) {\n                  formattedColumn.total = formatter(sum(table.rows) / table.rows.length);\n                }\n                break;\n              case 'min':\n                formattedColumn.total = formatter(_lodash2.default.chain(table.rows).map(i).map('value').min().value());\n                break;\n              case 'max':\n                formattedColumn.total = formatter(_lodash2.default.chain(table.rows).map(i).map('value').max().value());\n                break;\n              case 'count':\n                formattedColumn.total = numberFormatter(table.rows.length);\n                break;\n              default:\n                break;\n            }\n          }\n\n          return formattedColumn;\n        });\n      });\n    }\n  };\n});",null]}