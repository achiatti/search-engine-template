{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/mappings.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/mappings.js","mtime":1515552026000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar $ = require('jquery');\nvar _ = require('lodash');\nvar es = require('./es');\nvar settings = require('./settings');\n\nvar per_index_types = {};\nvar per_alias_indexes = [];\n\nvar mappingObj = {};\n\nfunction expandAliases(indicesOrAliases) {\n  // takes a list of indices or aliases or a string which may be either and returns a list of indices\n  // returns a list for multiple values or a string for a single.\n\n  if (!indicesOrAliases) {\n    return indicesOrAliases;\n  }\n\n  if (typeof indicesOrAliases === \"string\") {\n    indicesOrAliases = [indicesOrAliases];\n  }\n  indicesOrAliases = $.map(indicesOrAliases, function (iOrA) {\n    if (per_alias_indexes[iOrA]) {\n      return per_alias_indexes[iOrA];\n    }\n    return [iOrA];\n  });\n  var ret = [].concat.apply([], indicesOrAliases);\n  ret.sort();\n  var last;\n  ret = $.map(ret, function (v) {\n    var r = last == v ? null : v;\n    last = v;\n    return r;\n  });\n  return ret.length > 1 ? ret : ret[0];\n}\n\nfunction getFields(indices, types) {\n  // get fields for indices and types. Both can be a list, a string or null (meaning all).\n  var ret = [];\n  indices = expandAliases(indices);\n  if (typeof indices == \"string\") {\n\n    var type_dict = per_index_types[indices];\n    if (!type_dict) {\n      return [];\n    }\n\n    if (typeof types == \"string\") {\n      var f = type_dict[types];\n      ret = f ? f : [];\n    } else {\n      // filter what we need\n      $.each(type_dict, function (type, fields) {\n        if (!types || types.length == 0 || $.inArray(type, types) != -1) {\n          ret.push(fields);\n        }\n      });\n\n      ret = [].concat.apply([], ret);\n    }\n  } else {\n    // multi index mode.\n    $.each(per_index_types, function (index) {\n      if (!indices || indices.length == 0 || $.inArray(index, indices) != -1) {\n        ret.push(getFields(index, types));\n      }\n    });\n    ret = [].concat.apply([], ret);\n  }\n\n  return _.uniq(ret, function (f) {\n    return f.name + \":\" + f.type;\n  });\n}\n\nfunction getTypes(indices) {\n  var ret = [];\n  indices = expandAliases(indices);\n  if (typeof indices == \"string\") {\n    var type_dict = per_index_types[indices];\n    if (!type_dict) {\n      return [];\n    }\n\n    // filter what we need\n    $.each(type_dict, function (type) {\n      ret.push(type);\n    });\n  } else {\n    // multi index mode.\n    $.each(per_index_types, function (index) {\n      if (!indices || $.inArray(index, indices) != -1) {\n        ret.push(getTypes(index));\n      }\n    });\n    ret = [].concat.apply([], ret);\n  }\n\n  return _.uniq(ret);\n}\n\nfunction getIndices(include_aliases) {\n  var ret = [];\n  $.each(per_index_types, function (index) {\n    ret.push(index);\n  });\n  if (typeof include_aliases === \"undefined\" ? true : include_aliases) {\n    $.each(per_alias_indexes, function (alias) {\n      ret.push(alias);\n    });\n  }\n  return ret;\n}\n\nfunction getFieldNamesFromFieldMapping(field_name, field_mapping) {\n  if (field_mapping['enabled'] == false) {\n    return [];\n  }\n  var nested_fields;\n\n  function applyPathSettings(nested_field_names) {\n    var path_type = field_mapping['path'] || \"full\";\n    if (path_type == \"full\") {\n      return $.map(nested_field_names, function (f) {\n        f.name = field_name + \".\" + f.name;\n        return f;\n      });\n    }\n    return nested_field_names;\n  }\n\n  if (field_mapping[\"properties\"]) {\n    // derived object type\n    nested_fields = getFieldNamesFromTypeMapping(field_mapping);\n    return applyPathSettings(nested_fields);\n  }\n\n  var field_type = field_mapping['type'];\n\n  if (field_type === 'multi_field') {\n    nested_fields = $.map(field_mapping['fields'], function (field_mapping, field_name) {\n      return getFieldNamesFromFieldMapping(field_name, field_mapping);\n    });\n\n    return applyPathSettings(nested_fields);\n  }\n\n  var ret = { name: field_name, type: field_type };\n\n  if (field_mapping[\"index_name\"]) {\n    ret.name = field_mapping[\"index_name\"];\n  }\n\n  if (field_mapping[\"fields\"]) {\n    nested_fields = $.map(field_mapping['fields'], function (field_mapping, field_name) {\n      return getFieldNamesFromFieldMapping(field_name, field_mapping);\n    });\n    nested_fields = applyPathSettings(nested_fields);\n    nested_fields.unshift(ret);\n    return nested_fields;\n  }\n\n  return [ret];\n}\n\nfunction getFieldNamesFromTypeMapping(type_mapping) {\n  var field_list = $.map(type_mapping['properties'] || {}, function (field_mapping, field_name) {\n    return getFieldNamesFromFieldMapping(field_name, field_mapping);\n  });\n\n  // deduping\n  return _.uniq(field_list, function (f) {\n    return f.name + \":\" + f.type;\n  });\n}\n\nfunction loadMappings(mappings) {\n  per_index_types = {};\n  $.each(mappings, function (index, index_mapping) {\n    var normalized_index_mappings = {};\n    // 1.0.0 mapping format has changed, extract underlying mapping\n    if (index_mapping.mappings && _.keys(index_mapping).length === 1) {\n      index_mapping = index_mapping.mappings;\n    }\n    $.each(index_mapping, function (type_name, type_mapping) {\n      var field_list = getFieldNamesFromTypeMapping(type_mapping);\n      normalized_index_mappings[type_name] = field_list;\n    });\n    per_index_types[index] = normalized_index_mappings;\n  });\n}\n\nfunction loadAliases(aliases) {\n  per_alias_indexes = {};\n  $.each(aliases || {}, function (index, index_aliases) {\n    // verify we have an index defined. usefull when mapping loading is disabled\n    per_index_types[index] = per_index_types[index] || {};\n\n    $.each(index_aliases.aliases || {}, function (alias) {\n      if (alias === index) {\n        return;\n      } // alias which is identical to index means no index.\n      var cur_aliases = per_alias_indexes[alias];\n      if (!cur_aliases) {\n        cur_aliases = [];\n        per_alias_indexes[alias] = cur_aliases;\n      }\n      cur_aliases.push(index);\n    });\n  });\n\n  per_alias_indexes['_all'] = getIndices(false);\n}\n\nfunction clear() {\n  per_index_types = {};\n  per_alias_indexes = {};\n}\n\nfunction retrieveAutocompleteInfoFromServer() {\n  var autocompleteSettings = settings.getAutocomplete(),\n      mappingPromise,\n      aliasesPromise;\n  if (autocompleteSettings.fields) {\n    mappingPromise = es.send(\"GET\", \"_mapping\", null, null, true);\n  } else {\n    mappingPromise = new $.Deferred();\n    mappingPromise.resolve();\n  }\n  if (autocompleteSettings.indices) {\n    aliasesPromise = es.send(\"GET\", \"_aliases\", null, null, true);\n  } else {\n    aliasesPromise = new $.Deferred();\n    aliasesPromise.resolve();\n  }\n\n  $.when(mappingPromise, aliasesPromise).done(function (mappings, aliases) {\n    if (!mappings) {\n      mappings = {};\n    } else if (mappings[0].length < 10 * 1024 * 1024) {\n      mappings = JSON.parse(mappings[0]);\n    } else {\n      console.warn(\"mapping size is larger than 10MB (\" + mappings[0].length / 1024 / 1024 + \" MB). ignoring..\");\n      mappings = {};\n    }\n    loadMappings(mappings);\n    if (aliases) {\n      loadAliases(JSON.parse(aliases[0]));\n    } else {\n      aliases = [{}];\n      loadAliases({});\n    }\n    // Trigger an update event with the mappings and aliases\n    $(mappingObj).trigger('update', [mappings[0], aliases[0]]);\n  });\n}\n\nfunction autocomplete_retriever() {\n  retrieveAutocompleteInfoFromServer();\n  setTimeout(function () {\n    autocomplete_retriever();\n  }, 60000);\n}\n\nexports.default = _.assign(mappingObj, {\n  getFields: getFields,\n  getIndices: getIndices,\n  getTypes: getTypes,\n  loadMappings: loadMappings,\n  loadAliases: loadAliases,\n  expandAliases: expandAliases,\n  clear: clear,\n  startRetrievingAutoCompleteInfo: autocomplete_retriever\n});\nmodule.exports = exports['default'];",null]}