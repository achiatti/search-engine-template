{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/dashboard/dashboard_app.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/dashboard/dashboard_app.js","mtime":1515552028000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _modules = require('ui/modules');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nrequire('ui/query_bar');\n\nvar _dashboard_strings = require('./dashboard_strings');\n\nvar _dashboard_view_mode = require('./dashboard_view_mode');\n\nvar _top_nav_ids = require('./top_nav/top_nav_ids');\n\nvar _confirm_modal = require('ui/modals/confirm_modal');\n\nvar _query_filter = require('ui/filter_bar/query_filter');\n\nvar _doc_title = require('ui/doc_title');\n\nvar _get_top_nav_config = require('./top_nav/get_top_nav_config');\n\nvar _dashboard_constants = require('./dashboard_constants');\n\nvar _visualize_constants = require('plugins/kibana/visualize/visualize_constants');\n\nvar _dashboard_state_manager = require('./dashboard_state_manager');\n\nvar _lib = require('./lib');\n\nvar _show_clone_modal = require('./top_nav/show_clone_modal');\n\nvar _migrateLegacyQuery = require('ui/utils/migrateLegacyQuery');\n\nvar _dashboard_container_api = require('./dashboard_container_api');\n\nvar _filter = require('ui/doc_table/actions/filter');\n\nvar filterActions = _interopRequireWildcard(_filter);\n\nvar _filter_manager = require('ui/filter_manager');\n\nvar _embeddable_factories_registry = require('ui/embeddable/embeddable_factories_registry');\n\nvar _dashboard_viewport_provider = require('./viewport/dashboard_viewport_provider');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar app = _modules.uiModules.get('app/dashboard', ['elasticsearch', 'ngRoute', 'react', 'kibana/courier', 'kibana/config', 'kibana/notify', 'kibana/typeahead']);\n\napp.directive('dashboardViewportProvider', function (reactDirective) {\n  return reactDirective(_dashboard_viewport_provider.DashboardViewportProvider);\n});\n\napp.directive('dashboardApp', function ($injector) {\n  var Notifier = $injector.get('Notifier');\n  var courier = $injector.get('courier');\n  var AppState = $injector.get('AppState');\n  var timefilter = $injector.get('timefilter');\n  var quickRanges = $injector.get('quickRanges');\n  var kbnUrl = $injector.get('kbnUrl');\n  var confirmModal = $injector.get('confirmModal');\n  var config = $injector.get('config');\n  var Private = $injector.get('Private');\n\n  return {\n    restrict: 'E',\n    controllerAs: 'dashboardApp',\n    controller: function controller($scope, $rootScope, $route, $routeParams, $location, getAppState, $compile, dashboardConfig) {\n      var _this = this;\n\n      var filterManager = Private(_filter_manager.FilterManagerProvider);\n      var filterBar = Private(_query_filter.FilterBarQueryFilterProvider);\n      var docTitle = Private(_doc_title.DocTitleProvider);\n      var notify = new Notifier({ location: 'Dashboard' });\n      var embeddableFactories = Private(_embeddable_factories_registry.EmbeddableFactoriesRegistryProvider);\n      $scope.getEmbeddableFactory = function (panelType) {\n        return embeddableFactories.byName[panelType];\n      };\n\n      var dash = $scope.dash = $route.current.locals.dash;\n      if (dash.id) {\n        docTitle.change(dash.title);\n      }\n\n      var dashboardStateManager = new _dashboard_state_manager.DashboardStateManager(dash, AppState, dashboardConfig.getHideWriteControls());\n\n      $scope.getDashboardState = function () {\n        return dashboardStateManager;\n      };\n      $scope.appState = dashboardStateManager.getAppState();\n      $scope.containerApi = new _dashboard_container_api.DashboardContainerAPI(dashboardStateManager, function (field, value, operator, index) {\n        filterActions.addFilter(field, value, operator, index, dashboardStateManager.getAppState(), filterManager);\n        dashboardStateManager.saveState();\n      });\n      $scope.getContainerApi = function () {\n        return $scope.containerApi;\n      };\n\n      // The 'previouslyStored' check is so we only update the time filter on dashboard open, not during\n      // normal cross app navigation.\n      if (dashboardStateManager.getIsTimeSavedWithDashboard() && !getAppState.previouslyStored()) {\n        dashboardStateManager.syncTimefilterWithDashboard(timefilter, quickRanges);\n      }\n\n      var updateState = function updateState() {\n        // Following the \"best practice\" of always have a '.' in your ng-models â€“\n        // https://github.com/angular/angular.js/wiki/Understanding-Scopes\n        $scope.model = {\n          query: dashboardStateManager.getQuery(),\n          useMargins: dashboardStateManager.getUseMargins(),\n          hidePanelTitles: dashboardStateManager.getHidePanelTitles(),\n          darkTheme: dashboardStateManager.getDarkTheme(),\n          timeRestore: dashboardStateManager.getTimeRestore(),\n          title: dashboardStateManager.getTitle(),\n          description: dashboardStateManager.getDescription()\n        };\n        $scope.panels = dashboardStateManager.getPanels();\n        $scope.indexPatterns = dashboardStateManager.getPanelIndexPatterns();\n      };\n\n      // Part of the exposed plugin API - do not remove without careful consideration.\n      this.appStatus = {\n        dirty: !dash.id\n      };\n\n      dashboardStateManager.registerChangeListener(function (status) {\n        _this.appStatus.dirty = status.dirty || !dash.id;\n        updateState();\n      });\n\n      dashboardStateManager.applyFilters(dashboardStateManager.getQuery() || { query: '', language: config.get('search:queryLanguage') }, filterBar.getFilters());\n\n      timefilter.enabled = true;\n      dash.searchSource.highlightAll(true);\n      dash.searchSource.version(true);\n      courier.setRootSearchSource(dash.searchSource);\n\n      updateState();\n\n      $scope.refresh = function () {\n        $rootScope.$broadcast('fetch');\n        courier.fetch.apply(courier, arguments);\n      };\n      $scope.timefilter = timefilter;\n      $scope.expandedPanel = null;\n      $scope.dashboardViewMode = dashboardStateManager.getViewMode();\n\n      $scope.landingPageUrl = function () {\n        return '#' + _dashboard_constants.DashboardConstants.LANDING_PAGE_PATH;\n      };\n      $scope.hasExpandedPanel = function () {\n        return $scope.expandedPanel !== null;\n      };\n      $scope.getDashTitle = function () {\n        return (0, _dashboard_strings.getDashboardTitle)(dashboardStateManager.getTitle(), dashboardStateManager.getViewMode(), dashboardStateManager.getIsDirty(timefilter));\n      };\n      $scope.newDashboard = function () {\n        kbnUrl.change(_dashboard_constants.DashboardConstants.CREATE_NEW_DASHBOARD_URL, {});\n      };\n      $scope.saveState = function () {\n        return dashboardStateManager.saveState();\n      };\n      $scope.getShouldShowEditHelp = function () {\n        return !dashboardStateManager.getPanels().length && dashboardStateManager.getIsEditMode() && !dashboardConfig.getHideWriteControls();\n      };\n      $scope.getShouldShowViewHelp = function () {\n        return !dashboardStateManager.getPanels().length && dashboardStateManager.getIsViewMode() && !dashboardConfig.getHideWriteControls();\n      };\n\n      $scope.minimizeExpandedPanel = function () {\n        $scope.expandedPanel = null;\n      };\n\n      $scope.expandPanel = function (panelIndex) {\n        $scope.expandedPanel = dashboardStateManager.getPanels().find(function (panel) {\n          return panel.panelIndex === panelIndex;\n        });\n      };\n\n      $scope.updateQueryAndFetch = function (query) {\n        // reset state if language changes\n        if ($scope.model.query.language && $scope.model.query.language !== query.language) {\n          filterBar.removeAll();\n          dashboardStateManager.getAppState().$newFilters = [];\n        }\n        $scope.model.query = (0, _migrateLegacyQuery.migrateLegacyQuery)(query);\n        dashboardStateManager.applyFilters($scope.model.query, filterBar.getFilters());\n        $scope.refresh();\n      };\n\n      // called by the saved-object-finder when a user clicks a vis\n      $scope.addVis = function (hit) {\n        var showToast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        dashboardStateManager.addNewPanel(hit.id, 'visualization');\n        if (showToast) {\n          notify.info('Visualization successfully added to your dashboard');\n        }\n      };\n\n      $scope.addSearch = function (hit) {\n        dashboardStateManager.addNewPanel(hit.id, 'search');\n        notify.info('Search successfully added to your dashboard');\n      };\n      $scope.$watch('model.hidePanelTitles', function () {\n        dashboardStateManager.setHidePanelTitles($scope.model.hidePanelTitles);\n      });\n      $scope.$watch('model.useMargins', function () {\n        dashboardStateManager.setUseMargins($scope.model.useMargins);\n      });\n      $scope.$watch('model.darkTheme', function () {\n        dashboardStateManager.setDarkTheme($scope.model.darkTheme);\n        updateTheme();\n      });\n      $scope.$watch('model.description', function () {\n        return dashboardStateManager.setDescription($scope.model.description);\n      });\n      $scope.$watch('model.title', function () {\n        return dashboardStateManager.setTitle($scope.model.title);\n      });\n      $scope.$watch('model.timeRestore', function () {\n        return dashboardStateManager.setTimeRestore($scope.model.timeRestore);\n      });\n      $scope.indexPatterns = [];\n\n      $scope.registerPanelIndexPattern = function (panelIndex, pattern) {\n        dashboardStateManager.registerPanelIndexPatternMap(panelIndex, pattern);\n        $scope.indexPatterns = dashboardStateManager.getPanelIndexPatterns();\n      };\n\n      $scope.onPanelRemoved = function (panelIndex) {\n        dashboardStateManager.removePanel(panelIndex);\n        $scope.indexPatterns = dashboardStateManager.getPanelIndexPatterns();\n      };\n\n      $scope.$watch('model.query', $scope.updateQueryAndFetch);\n\n      $scope.$listen(timefilter, 'fetch', $scope.refresh);\n\n      function updateViewMode(newMode) {\n        $scope.topNavMenu = (0, _get_top_nav_config.getTopNavConfig)(newMode, navActions, dashboardConfig.getHideWriteControls()); // eslint-disable-line no-use-before-define\n        dashboardStateManager.switchViewMode(newMode);\n        $scope.dashboardViewMode = newMode;\n      }\n\n      var onChangeViewMode = function onChangeViewMode(newMode) {\n        var isPageRefresh = newMode === dashboardStateManager.getViewMode();\n        var isLeavingEditMode = !isPageRefresh && newMode === _dashboard_view_mode.DashboardViewMode.VIEW;\n        var willLoseChanges = isLeavingEditMode && dashboardStateManager.getIsDirty(timefilter);\n\n        if (!willLoseChanges) {\n          updateViewMode(newMode);\n          return;\n        }\n\n        function revertChangesAndExitEditMode() {\n          dashboardStateManager.resetState();\n          kbnUrl.change(dash.id ? (0, _dashboard_constants.createDashboardEditUrl)(dash.id) : _dashboard_constants.DashboardConstants.CREATE_NEW_DASHBOARD_URL);\n          // This is only necessary for new dashboards, which will default to Edit mode.\n          updateViewMode(_dashboard_view_mode.DashboardViewMode.VIEW);\n\n          // We need to do a hard reset of the timepicker. appState will not reload like\n          // it does on 'open' because it's been saved to the url and the getAppState.previouslyStored() check on\n          // reload will cause it not to sync.\n          if (dashboardStateManager.getIsTimeSavedWithDashboard()) {\n            dashboardStateManager.syncTimefilterWithDashboard(timefilter, quickRanges);\n          }\n        }\n\n        confirmModal((0, _dashboard_strings.getUnsavedChangesWarningMessage)(dashboardStateManager.getChangedFilterTypes(timefilter)), {\n          onConfirm: revertChangesAndExitEditMode,\n          onCancel: _lodash2.default.noop,\n          confirmButtonText: 'Yes, lose changes',\n          cancelButtonText: 'No, keep working',\n          defaultFocusedButton: _confirm_modal.ConfirmationButtonTypes.CANCEL\n        });\n      };\n\n      $scope.save = function () {\n        return (0, _lib.saveDashboard)(_angular2.default.toJson, timefilter, dashboardStateManager).then(function (id) {\n          $scope.kbnTopNav.close('save');\n          if (id) {\n            notify.info('Saved Dashboard as \"' + dash.title + '\"');\n            if (dash.id !== $routeParams.id) {\n              kbnUrl.change((0, _dashboard_constants.createDashboardEditUrl)(dash.id));\n            } else {\n              docTitle.change(dash.lastSavedTitle);\n              updateViewMode(_dashboard_view_mode.DashboardViewMode.VIEW);\n            }\n          }\n          return id;\n        }).catch(notify.error);\n      };\n\n      $scope.showFilterBar = function () {\n        return filterBar.getFilters().length > 0 || !dashboardStateManager.getFullScreenMode();\n      };\n\n      $scope.showAddPanel = function () {\n        dashboardStateManager.setFullScreenMode(false);\n        $scope.kbnTopNav.open('add');\n      };\n      $scope.enterEditMode = function () {\n        dashboardStateManager.setFullScreenMode(false);\n        $scope.kbnTopNav.click('edit');\n      };\n      var navActions = {};\n      navActions[_top_nav_ids.TopNavIds.FULL_SCREEN] = function () {\n        return dashboardStateManager.setFullScreenMode(true);\n      };\n      navActions[_top_nav_ids.TopNavIds.EXIT_EDIT_MODE] = function () {\n        return onChangeViewMode(_dashboard_view_mode.DashboardViewMode.VIEW);\n      };\n      navActions[_top_nav_ids.TopNavIds.ENTER_EDIT_MODE] = function () {\n        return onChangeViewMode(_dashboard_view_mode.DashboardViewMode.EDIT);\n      };\n      navActions[_top_nav_ids.TopNavIds.CLONE] = function () {\n        var currentTitle = $scope.model.title;\n        var onClone = function onClone(newTitle) {\n          dashboardStateManager.savedDashboard.copyOnSave = true;\n          dashboardStateManager.setTitle(newTitle);\n          return $scope.save().then(function (id) {\n            // If the save wasn't successful, put the original title back.\n            if (!id) {\n              $scope.model.title = currentTitle;\n              // There is a watch on $scope.model.title that *should* call this automatically but\n              // angular is failing to trigger it, so do so manually here.\n              dashboardStateManager.setTitle(currentTitle);\n            }\n            return id;\n          });\n        };\n\n        (0, _show_clone_modal.showCloneModal)(onClone, currentTitle, $rootScope, $compile);\n      };\n      updateViewMode(dashboardStateManager.getViewMode());\n\n      // update root source when filters update\n      $scope.$listen(filterBar, 'update', function () {\n        dashboardStateManager.applyFilters($scope.model.query, filterBar.getFilters());\n      });\n\n      // update data when filters fire fetch event\n      $scope.$listen(filterBar, 'fetch', $scope.refresh);\n\n      $scope.$on('$destroy', function () {\n        dashboardStateManager.destroy();\n\n        // Remove dark theme to keep it from affecting the appearance of other apps.\n        setLightTheme();\n      });\n\n      function updateTheme() {\n        dashboardStateManager.getDarkTheme() ? setDarkTheme() : setLightTheme();\n      }\n\n      function setDarkTheme() {\n        _chrome2.default.removeApplicationClass(['theme-light']);\n        _chrome2.default.addApplicationClass('theme-dark');\n      }\n\n      function setLightTheme() {\n        _chrome2.default.removeApplicationClass(['theme-dark']);\n        _chrome2.default.addApplicationClass('theme-light');\n      }\n\n      if ($route.current.params && $route.current.params[_dashboard_constants.DashboardConstants.NEW_VISUALIZATION_ID_PARAM]) {\n        // Hide the toast message since they will already see a notification from saving the visualization,\n        // and one is sufficient (especially given how the screen jumps down a bit for each unique notification).\n        var showToast = false;\n        $scope.addVis({ id: $route.current.params[_dashboard_constants.DashboardConstants.NEW_VISUALIZATION_ID_PARAM] }, showToast);\n\n        kbnUrl.removeParam(_dashboard_constants.DashboardConstants.ADD_VISUALIZATION_TO_DASHBOARD_MODE_PARAM);\n        kbnUrl.removeParam(_dashboard_constants.DashboardConstants.NEW_VISUALIZATION_ID_PARAM);\n      }\n\n      var addNewVis = function addNewVis() {\n        kbnUrl.change(_visualize_constants.VisualizeConstants.WIZARD_STEP_1_PAGE_PATH + '?' + _dashboard_constants.DashboardConstants.ADD_VISUALIZATION_TO_DASHBOARD_MODE_PARAM);\n      };\n\n      $scope.opts = {\n        displayName: dash.getDisplayName(),\n        dashboard: dash,\n        save: $scope.save,\n        addVis: $scope.addVis,\n        addNewVis: addNewVis,\n        addSearch: $scope.addSearch,\n        timefilter: $scope.timefilter\n      };\n    }\n  };\n});",null]}