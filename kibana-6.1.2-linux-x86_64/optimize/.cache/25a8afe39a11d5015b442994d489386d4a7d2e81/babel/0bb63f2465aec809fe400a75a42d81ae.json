{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/metrics/public/visualizations/components/flot_chart.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/metrics/public/visualizations/components/flot_chart.js","mtime":1515552030000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _flotCharts = require('ui/flot-charts');\n\nvar _flotCharts2 = _interopRequireDefault(_flotCharts);\n\nvar _events = require('../lib/events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _resize = require('./resize');\n\nvar _resize2 = _interopRequireDefault(_resize);\n\nvar _calculate_bar_width = require('../lib/calculate_bar_width');\n\nvar _calculate_bar_width2 = _interopRequireDefault(_calculate_bar_width);\n\nvar _colors = require('../lib/colors');\n\nvar _colors2 = _interopRequireDefault(_colors);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FlotChart = function (_Component) {\n  _inherits(FlotChart, _Component);\n\n  function FlotChart(props) {\n    _classCallCheck(this, FlotChart);\n\n    var _this = _possibleConstructorReturn(this, (FlotChart.__proto__ || Object.getPrototypeOf(FlotChart)).call(this, props));\n\n    _this.handleResize = _this.handleResize.bind(_this);\n    return _this;\n  }\n\n  _createClass(FlotChart, [{\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(props) {\n      var _this2 = this;\n\n      if (!this.plot) return true;\n      if (props.reversed !== this.props.reversed) {\n        return true;\n      }\n\n      // if the grid changes we need to re-render\n      if (props.showGrid !== this.props.showGrid) return true;\n\n      if (props.yaxes && this.props.yaxes) {\n        // We need to rerender if the axis change\n        var valuesChanged = props.yaxes.some(function (axis, i) {\n          if (_this2.props.yaxes[i]) {\n            return axis.position !== _this2.props.yaxes[i].position || axis.max !== _this2.props.yaxes[i].max || axis.min !== _this2.props.yaxes[i].min || axis.axisFormatter !== _this2.props.yaxes[i].axisFormatter || axis.axisFormatterTemplate !== _this2.props.yaxes[i].axisFormatterTemplate;\n          }\n        });\n        if (props.yaxes.length !== this.props.yaxes.length || valuesChanged) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'shutdownChart',\n    value: function shutdownChart() {\n      if (!this.plot) return;\n      (0, _flotCharts2.default)(this.target).unbind('plothover', this.props.plothover);\n      if (this.props.onMouseOver) (0, _flotCharts2.default)(this.target).on('plothover', this.handleMouseOver);\n      if (this.props.onMouseLeave) (0, _flotCharts2.default)(this.target).on('mouseleave', this.handleMouseLeave);\n      if (this.props.onBrush) (0, _flotCharts2.default)(this.target).off('plotselected', this.brushChart);\n      this.plot.shutdown();\n      if (this.props.crosshair) {\n        (0, _flotCharts2.default)(this.target).off('plothover', this.handlePlotover);\n        _events2.default.off('thorPlotover', this.handleThorPlotover);\n        _events2.default.off('thorPlotleave', this.handleThorPlotleave);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.shutdownChart();\n    }\n  }, {\n    key: 'filterByShow',\n    value: function filterByShow(show) {\n      if (show) {\n        return function (metric) {\n          return show.some(function (id) {\n            return _lodash2.default.startsWith(id, metric.id);\n          });\n        };\n      }\n      return function () {\n        return true;\n      };\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(newProps) {\n      if (this.plot) {\n        var series = newProps.series;\n\n        var options = this.plot.getOptions();\n        _lodash2.default.set(options, 'series.bars.barWidth', (0, _calculate_bar_width2.default)(series));\n        this.plot.setData(this.calculateData(series, newProps.show));\n        this.plot.setupGrid();\n        this.plot.draw();\n        if (!_lodash2.default.isEqual(this.props.series, series)) this.handleDraw(this.plot);\n      } else {\n        this.renderChart();\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.renderChart();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.shutdownChart();\n      this.renderChart();\n    }\n  }, {\n    key: 'calculateData',\n    value: function calculateData(data, show) {\n      return (0, _lodash2.default)(data).filter(this.filterByShow(show)).map(function (set) {\n        if (_lodash2.default.isPlainObject(set)) {\n          return set;\n        }\n        return {\n          color: '#990000',\n          data: set\n        };\n      }).reverse().value();\n    }\n  }, {\n    key: 'handleDraw',\n    value: function handleDraw(plot) {\n      if (this.props.onDraw) this.props.onDraw(plot);\n    }\n  }, {\n    key: 'getOptions',\n    value: function getOptions(props) {\n      var yaxes = props.yaxes || [{}];\n\n      var lineColor = props.reversed ? _colors2.default.lineColorReversed : _colors2.default.lineColor;\n      var textColor = props.reversed ? _colors2.default.textColorReversed : _colors2.default.textColor;\n\n      var borderWidth = { bottom: 1, top: 0, left: 0, right: 0 };\n\n      if (yaxes.some(function (y) {\n        return y.position === 'left';\n      })) borderWidth.left = 1;\n      if (yaxes.some(function (y) {\n        return y.position === 'right';\n      })) borderWidth.right = 1;\n\n      if (props.showGrid) {\n        borderWidth.top = 1;\n        borderWidth.left = 1;\n        borderWidth.right = 1;\n      }\n\n      var opts = {\n        legend: { show: false },\n        yaxes: yaxes.map(function (axis) {\n          axis.tickLength = props.showGrid ? null : 0;\n          return axis;\n        }),\n        yaxis: {\n          color: lineColor,\n          font: { color: textColor },\n          tickFormatter: props.tickFormatter\n        },\n        xaxis: {\n          tickLength: props.showGrid ? null : 0,\n          color: lineColor,\n          timezone: 'browser',\n          mode: 'time',\n          font: { color: textColor }\n        },\n        series: {\n          shadowSize: 0\n        },\n        grid: {\n          margin: 0,\n          borderWidth: borderWidth,\n          borderColor: lineColor,\n          hoverable: true,\n          mouseActiveRadius: 200\n        }\n      };\n\n      if (props.crosshair) {\n        _lodash2.default.set(opts, 'crosshair', {\n          mode: 'x',\n          color: props.reversed ? '#FFF' : '#000',\n          lineWidth: 1\n        });\n      }\n\n      if (props.onBrush) {\n        _lodash2.default.set(opts, 'selection', { mode: 'x', color: textColor });\n      }\n      _lodash2.default.set(opts, 'series.bars.barWidth', (0, _calculate_bar_width2.default)(props.series));\n      return _lodash2.default.assign(opts, props.options);\n    }\n  }, {\n    key: 'handleResize',\n    value: function handleResize(width, height) {\n      this.size = { width: width, height: height };\n\n      if (this.size.height > 0 && this.size.width > 0) {\n        if (!this.plot) return;\n        this.plot.resize();\n        this.plot.setupGrid();\n        this.plot.draw();\n        this.handleDraw(this.plot);\n      }\n    }\n  }, {\n    key: 'renderChart',\n    value: function renderChart() {\n      var _this3 = this;\n\n      if (this.size.height > 0 && this.size.width > 0) {\n\n        this.rendered = true;\n        var series = this.props.series;\n\n        var data = this.calculateData(series, this.props.show);\n\n        this.plot = _flotCharts2.default.plot(this.target, data, this.getOptions(this.props));\n\n        this.handleDraw(this.plot);\n\n        _lodash2.default.defer(function () {\n          return _this3.handleResize();\n        });\n\n        this.handleMouseOver = function () {\n          var _props;\n\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          if (_this3.props.onMouseOver) (_props = _this3.props).onMouseOver.apply(_props, args.concat([_this3.plot]));\n        };\n\n        this.handleMouseLeave = function () {\n          var _props2;\n\n          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          if (_this3.props.onMouseLeave) (_props2 = _this3.props).onMouseLeave.apply(_props2, args.concat([_this3.plot]));\n        };\n\n        (0, _flotCharts2.default)(this.target).on('plothover', this.handleMouseOver);\n        (0, _flotCharts2.default)(this.target).on('mouseleave', this.handleMouseLeave);\n\n        if (this.props.crosshair) {\n          this.handleThorPlotover = function (e, pos, item, originalPlot) {\n            if (_this3.plot !== originalPlot) {\n              _this3.plot.setCrosshair({ x: _lodash2.default.get(pos, 'x') });\n              _this3.props.plothover(e, pos, item);\n            }\n          };\n\n          this.handlePlotover = function (e, pos, item) {\n            return _events2.default.trigger('thorPlotover', [pos, item, _this3.plot]);\n          };\n          this.handlePlotleave = function () {\n            return _events2.default.trigger('thorPlotleave');\n          };\n          this.handleThorPlotleave = function (e) {\n            _this3.plot.clearCrosshair();\n            if (_this3.props.plothover) _this3.props.plothover(e);\n          };\n\n          (0, _flotCharts2.default)(this.target).on('plothover', this.handlePlotover);\n          (0, _flotCharts2.default)(this.target).on('mouseleave', this.handlePlotleave);\n          _events2.default.on('thorPlotover', this.handleThorPlotover);\n          _events2.default.on('thorPlotleave', this.handleThorPlotleave);\n        }\n\n        if (_lodash2.default.isFunction(this.props.plothover)) {\n          (0, _flotCharts2.default)(this.target).bind('plothover', this.props.plothover);\n        }\n\n        (0, _flotCharts2.default)(this.target).on('mouseleave', function () {\n          _events2.default.trigger('thorPlotleave');\n        });\n\n        if (_lodash2.default.isFunction(this.props.onBrush)) {\n          this.brushChart = function (e, ranges) {\n            _this3.props.onBrush(ranges);\n            _this3.plot.clearSelection();\n          };\n\n          (0, _flotCharts2.default)(this.target).on('plotselected', this.brushChart);\n        }\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      return _react2.default.createElement(\n        'div',\n        { className: 'rhythm_chart__timeseries-container' },\n        _react2.default.createElement('div', { ref: function ref(el) {\n            return _this4.target = el;\n          }, className: 'rhythm_chart__timeseries-container' }),\n        _react2.default.createElement(_resize2.default, { onResize: this.handleResize })\n      );\n    }\n  }]);\n\n  return FlotChart;\n}(_react.Component);\n\nFlotChart.defaultProps = {\n  showGrid: true\n};\n\nFlotChart.propTypes = {\n  crosshair: _propTypes2.default.bool,\n  onBrush: _propTypes2.default.func,\n  onPlotCreate: _propTypes2.default.func,\n  onMouseOver: _propTypes2.default.func,\n  onMouseLeave: _propTypes2.default.func,\n  options: _propTypes2.default.object,\n  plothover: _propTypes2.default.func,\n  reversed: _propTypes2.default.bool,\n  series: _propTypes2.default.array,\n  show: _propTypes2.default.array,\n  tickFormatter: _propTypes2.default.func,\n  showGrid: _propTypes2.default.bool,\n  yaxes: _propTypes2.default.array\n};\n\nexports.default = FlotChart;\nmodule.exports = exports['default'];",null]}