{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/dashboard/panel/panel_state.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/dashboard/panel/panel_state.js","mtime":1515552028000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPanelState = createPanelState;\nexports.getPersistedStateId = getPersistedStateId;\n\nvar _dashboard_constants = require('../dashboard_constants');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Represents a panel on a grid. Keeps track of position in the grid and what visualization it\n * contains.\n *\n * @typedef {Object} PanelState\n * @property {number} id - Id of the visualization contained in the panel.\n * @property {string} version - Version of Kibana this panel was created in.\n * @property {string} type - Type of the visualization in the panel.\n * @property {number} panelIndex - Unique id to represent this panel in the grid. Note that this is\n * NOT the index in the panels array. While it may initially represent that, it is not\n * updated with changes in a dashboard, and is simply used as a unique identifier.  The name\n * remains as panelIndex for backward compatibility reasons - changing it can break reporting.\n * @property {Object} gridData\n * @property {number} gridData.w - Width of the panel.\n * @property {number} gridData.h - Height of the panel.\n * @property {number} gridData.x - Column position of the panel.\n * @property {number} gridData.y - Row position of the panel.\n */\n\n// Look for the smallest y and x value where the default panel will fit.\nfunction findTopLeftMostOpenSpace(width, height, currentPanels) {\n  var maxY = -1;\n\n  for (var i = 0; i < currentPanels.length; i++) {\n    var panel = currentPanels[i];\n    maxY = Math.max(panel.gridData.y + panel.gridData.h, maxY);\n  }\n\n  // Handle case of empty grid.\n  if (maxY < 0) {\n    return { x: 0, y: 0 };\n  }\n\n  var grid = new Array(maxY);\n  for (var y = 0; y < maxY; y++) {\n    grid[y] = new Array(_dashboard_constants.DASHBOARD_GRID_COLUMN_COUNT).fill(0);\n  }\n\n  for (var _i = 0; _i < currentPanels.length; _i++) {\n    var _panel = currentPanels[_i];\n    for (var x = _panel.gridData.x; x < _panel.gridData.x + _panel.gridData.w; x++) {\n      for (var _y = _panel.gridData.y; _y < _panel.gridData.y + _panel.gridData.h; _y++) {\n        grid[_y][x] = 1;\n      }\n    }\n  }\n\n  for (var _y2 = 0; _y2 < maxY; _y2++) {\n    for (var _x = 0; _x < _dashboard_constants.DASHBOARD_GRID_COLUMN_COUNT; _x++) {\n      if (grid[_y2][_x] === 1) {\n        // Space is filled\n        continue;\n      } else {\n        for (var h = _y2; h < Math.min(_y2 + height, maxY); h++) {\n          for (var w = _x; w < Math.min(_x + width, _dashboard_constants.DASHBOARD_GRID_COLUMN_COUNT); w++) {\n            var spaceIsEmpty = grid[h][w] === 0;\n            var fitsPanelWidth = w === _x + width - 1;\n            // If the panel is taller than any other panel in the current grid, it can still fit in the space, hence\n            // we check the minimum of maxY and the panel height.\n            var fitsPanelHeight = h === Math.min(_y2 + height - 1, maxY - 1);\n\n            if (spaceIsEmpty && fitsPanelWidth && fitsPanelHeight) {\n              // Found space\n              return { x: _x, y: _y2 };\n            } else if (grid[h][w] === 1) {\n              // x, y spot doesn't work, break.\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return { x: 0, y: Infinity };\n}\n\n/**\n * Creates and initializes a basic panel state.\n * @param {number} id\n * @param {string} type\n * @param {number} panelIndex\n * @param {Array} currentPanels\n * @return {PanelState}\n */\nfunction createPanelState(id, type, panelIndex, currentPanels) {\n  var _findTopLeftMostOpenS = findTopLeftMostOpenSpace(_dashboard_constants.DEFAULT_PANEL_WIDTH, _dashboard_constants.DEFAULT_PANEL_HEIGHT, currentPanels),\n      x = _findTopLeftMostOpenS.x,\n      y = _findTopLeftMostOpenS.y;\n\n  return {\n    gridData: {\n      w: _dashboard_constants.DEFAULT_PANEL_WIDTH,\n      h: _dashboard_constants.DEFAULT_PANEL_HEIGHT,\n      x: x,\n      y: y,\n      i: panelIndex.toString()\n    },\n    version: _chrome2.default.getKibanaVersion(),\n    panelIndex: panelIndex.toString(),\n    type: type,\n    id: id\n  };\n}\n\n/**\n * Returns a unique id for storing the panel state in the persistent ui.\n * @param {PanelState} panel\n * @returns {string}\n */\nfunction getPersistedStateId(panel) {\n  return 'P-' + panel.panelIndex;\n}",null]}