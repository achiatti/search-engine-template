{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vis/agg_configs.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vis/agg_configs.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * @name AggConfig\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @extends IndexedArray\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @description A \"data structure\"-like class with methods for indexing and\n                                                                                                                                                                                                                                                                               * accessing instances of AggConfig.\n                                                                                                                                                                                                                                                                               */\n\nexports.VisAggConfigsProvider = VisAggConfigsProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _indexed_array = require('ui/indexed_array');\n\nvar _agg_config = require('ui/vis/agg_config');\n\nvar _index = require('ui/agg_types/index');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction VisAggConfigsProvider(Private) {\n  var AggConfig = Private(_agg_config.VisAggConfigProvider);\n\n  AggConfig.aggTypes = Private(_index.AggTypesIndexProvider);\n\n  _lodash2.default.class(AggConfigs).inherits(_indexed_array.IndexedArray);\n  function AggConfigs(vis, configStates) {\n    var self = this;\n    self.vis = vis;\n\n    configStates = AggConfig.ensureIds(configStates || []);\n\n    AggConfigs.Super.call(self, {\n      index: ['id'],\n      group: ['schema.group', 'type.name', 'schema.name'],\n      initialSet: configStates.map(function (aggConfigState) {\n        if (aggConfigState instanceof AggConfig) return aggConfigState;\n        return new AggConfig(vis, aggConfigState);\n      })\n    });\n\n    // Set the defaults for any schema which has them. If the defaults\n    // for some reason has more then the max only set the max number\n    // of defaults (not sure why a someone define more...\n    // but whatever). Also if a schema.name is already set then don't\n    // set anything.\n    if (vis && vis.type && vis.type.schemas && vis.type.schemas.all) {\n      (0, _lodash2.default)(vis.type.schemas.all).filter(function (schema) {\n        return Array.isArray(schema.defaults) && schema.defaults.length > 0;\n      }).each(function (schema) {\n        if (!self.bySchemaName[schema.name]) {\n          var defaults = schema.defaults.slice(0, schema.max);\n          _lodash2.default.each(defaults, function (defaultState) {\n            var state = _lodash2.default.defaults({ id: AggConfig.nextId(self) }, defaultState);\n            self.push(new AggConfig(vis, state));\n          });\n        }\n      }).commit();\n    }\n  }\n\n  /**\n   * Data-by-data comparison of this Aggregation\n   * Ignores the non-array indexes\n   * @param aggConfigs an AggConfigs instance\n   */\n  AggConfigs.prototype.jsonDataEquals = function (aggConfigs) {\n    if (aggConfigs.length !== this.length) {\n      return false;\n    }\n    for (var i = 0; i < this.length; i += 1) {\n      if (!_lodash2.default.isEqual(aggConfigs[i].toJSON(), this[i].toJSON())) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  function removeParentAggs(obj) {\n    for (var prop in obj) {\n      if (prop === 'parentAggs') delete obj[prop];else if (_typeof(obj[prop]) === 'object') removeParentAggs(obj[prop]);\n    }\n  }\n\n  function parseParentAggs(dslLvlCursor, dsl) {\n    if (dsl.parentAggs) {\n      _lodash2.default.each(dsl.parentAggs, function (agg, key) {\n        dslLvlCursor[key] = agg;\n        parseParentAggs(dslLvlCursor, agg);\n      });\n    }\n  }\n\n  AggConfigs.prototype.toDsl = function () {\n    var dslTopLvl = {};\n    var dslLvlCursor = void 0;\n    var nestedMetrics = void 0;\n\n    if (this.vis.isHierarchical()) {\n      // collect all metrics, and filter out the ones that we won't be copying\n      nestedMetrics = (0, _lodash2.default)(this.vis.aggs.bySchemaGroup.metrics).filter(function (agg) {\n        return agg.type.name !== 'count';\n      }).map(function (agg) {\n        return {\n          config: agg,\n          dsl: agg.toDsl()\n        };\n      }).value();\n    }\n    this.getRequestAggs().filter(function (config) {\n      return !config.type.hasNoDsl;\n    }).forEach(function nestEachConfig(config, i, list) {\n      if (!dslLvlCursor) {\n        // start at the top level\n        dslLvlCursor = dslTopLvl;\n      } else {\n        var prevConfig = list[i - 1];\n        var prevDsl = dslLvlCursor[prevConfig.id];\n\n        // advance the cursor and nest under the previous agg, or\n        // put it on the same level if the previous agg doesn't accept\n        // sub aggs\n        dslLvlCursor = prevDsl.aggs || dslLvlCursor;\n      }\n\n      var dsl = dslLvlCursor[config.id] = config.toDsl();\n      var subAggs = void 0;\n\n      parseParentAggs(dslLvlCursor, dsl);\n\n      if (config.schema.group === 'buckets' && i < list.length - 1) {\n        // buckets that are not the last item in the list accept sub-aggs\n        subAggs = dsl.aggs || (dsl.aggs = {});\n      }\n\n      if (subAggs && nestedMetrics) {\n        nestedMetrics.forEach(function (agg) {\n          subAggs[agg.config.id] = agg.dsl;\n        });\n      }\n    });\n\n    removeParentAggs(dslTopLvl);\n    return dslTopLvl;\n  };\n\n  AggConfigs.prototype.getRequestAggs = function () {\n    //collect all the aggregations\n    var aggregations = this.reduce(function (requestValuesAggs, agg) {\n      var aggs = agg.getRequestAggs();\n      return aggs ? requestValuesAggs.concat(aggs) : requestValuesAggs;\n    }, []);\n    //move metrics to the end\n    return _lodash2.default.sortBy(aggregations, function (agg) {\n      return agg.schema.group === 'metrics' ? 1 : 0;\n    });\n  };\n\n  /**\n   * Gets the AggConfigs (and possibly ResponseAggConfigs) that\n   * represent the values that will be produced when all aggs\n   * are run.\n   *\n   * With multi-value metric aggs it is possible for a single agg\n   * request to result in multiple agg values, which is why the length\n   * of a vis' responseValuesAggs may be different than the vis' aggs\n   *\n   * @return {array[AggConfig]}\n   */\n  AggConfigs.prototype.getResponseAggs = function () {\n    return this.getRequestAggs().reduce(function (responseValuesAggs, agg) {\n      var aggs = agg.getResponseAggs();\n      return aggs ? responseValuesAggs.concat(aggs) : responseValuesAggs;\n    }, []);\n  };\n\n  /**\n   * Find a response agg by it's id. This may be an agg in the aggConfigs, or one\n   * created specifically for a response value\n   *\n   * @param  {string} id - the id of the agg to find\n   * @return {AggConfig}\n   */\n  AggConfigs.prototype.getResponseAggById = function (id) {\n    id = String(id);\n    var reqAgg = _lodash2.default.find(this.getRequestAggs(), function (agg) {\n      return id.substr(0, String(agg.id).length) === agg.id;\n    });\n    if (!reqAgg) return;\n    return _lodash2.default.find(reqAgg.getResponseAggs(), { id: id });\n  };\n\n  return AggConfigs;\n}",null]}