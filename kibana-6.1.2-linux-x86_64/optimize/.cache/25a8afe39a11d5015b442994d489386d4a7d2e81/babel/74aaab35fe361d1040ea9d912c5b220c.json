{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/promises/promises.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/promises/promises.js","mtime":1515552037000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _module = _modules.uiModules.get('kibana');\n\n// Provides a tiny subset of the excelent API from\n// bluebird, reimplemented using the $q service\n_module.service('Promise', function ($q, $timeout) {\n  function Promise(fn) {\n    if (typeof this === 'undefined') throw new Error('Promise constructor must be called with \"new\"');\n\n    var defer = $q.defer();\n    try {\n      fn(defer.resolve, defer.reject);\n    } catch (e) {\n      defer.reject(e);\n    }\n    return defer.promise;\n  }\n\n  Promise.all = Promise.props = $q.all;\n  Promise.resolve = function (val) {\n    var defer = $q.defer();\n    defer.resolve(val);\n    return defer.promise;\n  };\n  Promise.reject = function (reason) {\n    var defer = $q.defer();\n    defer.reject(reason);\n    return defer.promise;\n  };\n  Promise.cast = $q.when;\n  Promise.defer = $q.defer;\n  Promise.delay = function (ms) {\n    return $timeout(_lodash2.default.noop, ms);\n  };\n  Promise.method = function (fn) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      return Promise.try(fn, args, this);\n    };\n  };\n  Promise.nodeify = function (promise, cb) {\n    promise.then(function (val) {\n      cb(void 0, val);\n    }, cb);\n  };\n  Promise.map = function (arr, fn) {\n    return Promise.all(arr.map(function (i, el, list) {\n      return Promise.try(fn, [i, el, list]);\n    }));\n  };\n  Promise.each = function (arr, fn) {\n    var queue = arr.slice(0);\n    var i = 0;\n    return function next() {\n      if (!queue.length) return arr;\n      return Promise.try(fn, [arr.shift(), i++]).then(next);\n    }();\n  };\n  Promise.is = function (obj) {\n    // $q doesn't create instances of any constructor, promises are just objects with a then function\n    // https://github.com/angular/angular.js/blob/58f5da86645990ef984353418cd1ed83213b111e/src/ng/q.js#L335\n    return obj && typeof obj.then === 'function';\n  };\n  Promise.halt = _lodash2.default.once(function () {\n    var promise = new Promise(function () {});\n    promise.then = _lodash2.default.constant(promise);\n    promise.catch = _lodash2.default.constant(promise);\n    return promise;\n  });\n  Promise.try = function (fn, args, ctx) {\n    if (typeof fn !== 'function') {\n      return Promise.reject(new TypeError('fn must be a function'));\n    }\n\n    var value = void 0;\n\n    if (Array.isArray(args)) {\n      try {\n        value = fn.apply(ctx, args);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    } else {\n      try {\n        value = fn.call(ctx, args);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    return Promise.resolve(value);\n  };\n  Promise.fromNode = function (takesCbFn) {\n    return new Promise(function (resolve, reject) {\n      takesCbFn(function (err) {\n        for (var _len = arguments.length, results = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          results[_key - 1] = arguments[_key];\n        }\n\n        if (err) reject(err);else if (results.length > 1) resolve(results);else resolve(results[0]);\n      });\n    });\n  };\n  Promise.race = function (iterable) {\n    return new Promise(function (resolve, reject) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var i = _step.value;\n\n          Promise.resolve(i).then(resolve, reject);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n  };\n\n  return Promise;\n});\n\n_module.factory('PromiseEmitter', function (Promise) {\n  /**\n   * Create a function that uses an \"event\" like pattern for promises.\n   *\n   * When a single argument is passed, this will behave just like calling `new Promise(fn)`,\n   * but when a second arguemnt is passed, the fn will be used to recreate a promise eveytime\n   * the previous is resolved. The following example demonstrates what this allows:\n   *\n   * When using `new Promise()` to create a promise, you can allow consumers to be\n   * notified of a single change:\n   * ```\n   * obj.onUpdate= function() {\n   *   // NOTE: we are NOT using `new Promise.emitter()` here\n   *   return new Promise(function (resolve, reject) {\n   *     // wait for the update...\n   *     resolve();\n   *   });\n   * }\n   * ```\n   *\n   * And the consumer can ask for continual updates be re-invoking the `.onChange()` method\n   * every time a change occurs:\n   * ```\n   * obj.onChange().then(function useChanges(change) {\n   *   // use changes...\n   *   // then register to receive notifcation of the next change\n   *   obj.onChange().then(useChanges);\n   * });\n   * ```\n   *\n   * But by defining obj.onChange using `new Promise.emitter`:\n   * ```\n   * obj.onChange = function (handler) {\n   *   return new Promise.emitter(function (resolve, reject) {\n   *     // wait for changes...\n   *     resolve();\n   *   });\n   * };\n   * ```\n   *\n   * The consumer can now simplify their code by passing the handler directly to `.onUpdate()`\n   * and the boilerplate of recalling `.onUpdate()` will be handled for them.\n   * ```\n   * obj.onChanges(function useChanges(changes) {\n   *   // use changes...\n   * });\n   * ```\n   *\n   * @param  {Function} fn - Used to init the promise, and call either\n   *                       reject or resolve (passed as args)\n   * @param  {Function} handler - A function that will be called every\n   *                            time this promise is resolved\n   *\n   * @return {Promise}\n   */\n  function PromiseEmitter(fn, handler) {\n    var prom = new Promise(fn);\n\n    if (!handler) return prom;\n\n    return prom.then(handler).then(function recurse() {\n      return new PromiseEmitter(fn, handler);\n    });\n  }\n\n  return PromiseEmitter;\n});",null]}