{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/fetch_now.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/fetch_now.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchNowProvider = FetchNowProvider;\n\nvar _notifier = require('./notifier');\n\nvar _call_client = require('./call_client');\n\nvar _call_response_handlers = require('./call_response_handlers');\n\nvar _continue_incomplete = require('./continue_incomplete');\n\nvar _req_status = require('./req_status');\n\n/**\n * Fetch now provider should be used if you want the results searched and returned immediately.\n * This can be slightly inefficient if a large number of requests are queued up, we can batch these\n * by using fetchSoon. This introduces a slight delay which allows other requests to queue up before\n * sending out requests in a batch.\n *\n * @param Private\n * @param Promise\n * @return {fetchNow}\n * @constructor\n */\nfunction FetchNowProvider(Private, Promise) {\n  // core tasks\n  var callClient = Private(_call_client.CallClientProvider);\n  var callResponseHandlers = Private(_call_response_handlers.CallResponseHandlersProvider);\n  var continueIncomplete = Private(_continue_incomplete.ContinueIncompleteProvider);\n\n  var ABORTED = _req_status.RequestStatus.ABORTED;\n  var DUPLICATE = _req_status.RequestStatus.DUPLICATE;\n  var INCOMPLETE = _req_status.RequestStatus.INCOMPLETE;\n\n  function fetchNow(requests) {\n    return fetchSearchResults(requests.map(function (req) {\n      if (!req.started) return req;\n      return req.retry();\n    })).catch(_notifier.courierNotifier.fatal);\n  }\n\n  function fetchSearchResults(requests) {\n    function replaceAbortedRequests() {\n      requests = requests.map(function (r) {\n        return r.aborted ? ABORTED : r;\n      });\n    }\n\n    replaceAbortedRequests();\n    return startRequests(requests).then(function () {\n      replaceAbortedRequests();\n      return callClient(requests);\n    }).then(function (responses) {\n      replaceAbortedRequests();\n      return callResponseHandlers(requests, responses);\n    }).then(function (responses) {\n      replaceAbortedRequests();\n      return continueIncomplete(requests, responses, fetchSearchResults);\n    }).then(function (responses) {\n      replaceAbortedRequests();\n      return responses.map(function (resp) {\n        switch (resp) {\n          case ABORTED:\n            return null;\n          case DUPLICATE:\n          case INCOMPLETE:\n            throw new Error('Failed to clear incomplete or duplicate request from responses.');\n          default:\n            return resp;\n        }\n      });\n    });\n  }\n\n  function startRequests(requests) {\n    return Promise.map(requests, function (req) {\n      if (req === ABORTED) {\n        return req;\n      }\n\n      return new Promise(function (resolve) {\n        var action = req.started ? req.continue : req.start;\n        resolve(action.call(req));\n      }).catch(function (err) {\n        return req.handleFailure(err);\n      });\n    });\n  }\n\n  return fetchNow;\n}",null]}