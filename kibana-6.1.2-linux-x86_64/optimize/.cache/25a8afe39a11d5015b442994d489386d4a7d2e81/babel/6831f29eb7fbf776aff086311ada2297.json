{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_types/buckets/geo_hash.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_types/buckets/geo_hash.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggTypesBucketsGeoHashProvider = AggTypesBucketsGeoHashProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _bucket_agg_type = require('ui/agg_types/buckets/_bucket_agg_type');\n\nvar _agg_config = require('ui/vis/agg_config');\n\nvar _precision = require('ui/agg_types/controls/precision.html');\n\nvar _precision2 = _interopRequireDefault(_precision);\n\nvar _decode_geo_hash = require('ui/utils/decode_geo_hash');\n\nvar _geo_utils = require('ui/utils/geo_utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction AggTypesBucketsGeoHashProvider(Private, config) {\n  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);\n  var AggConfig = Private(_agg_config.VisAggConfigProvider);\n\n  var defaultPrecision = 2;\n  var maxPrecision = parseInt(config.get('visualization:tileMap:maxPrecision'), 10) || 12;\n  /**\n   * Map Leaflet zoom levels to geohash precision levels.\n   * The size of a geohash column-width on the map should be at least `minGeohashPixels` pixels wide.\n   */\n  var zoomPrecision = {};\n  var minGeohashPixels = 16;\n  for (var zoom = 0; zoom <= 21; zoom += 1) {\n    var worldPixels = 256 * Math.pow(2, zoom);\n    zoomPrecision[zoom] = 1;\n    for (var precision = 2; precision <= maxPrecision; precision += 1) {\n      var columns = (0, _decode_geo_hash.geohashColumns)(precision);\n      if (worldPixels / columns >= minGeohashPixels) {\n        zoomPrecision[zoom] = precision;\n      } else {\n        break;\n      }\n    }\n  }\n\n  function getPrecision(precision) {\n\n    precision = parseInt(precision, 10);\n\n    if (isNaN(precision)) {\n      precision = defaultPrecision;\n    }\n\n    if (precision > maxPrecision) {\n      return maxPrecision;\n    }\n\n    return precision;\n  }\n\n  function getMapZoom(vis) {\n    if (vis.hasUiState() && parseInt(vis.uiStateVal('mapZoom')) >= 0) {\n      return parseInt(vis.uiStateVal('mapZoom'));\n    }\n\n    return vis.params.mapZoom;\n  }\n\n  function isOutsideCollar(bounds, collar) {\n    return bounds && collar && !(0, _geo_utils.geoContains)(collar, bounds);\n  }\n\n  return new BucketAggType({\n    name: 'geohash_grid',\n    title: 'Geohash',\n    params: [{\n      name: 'field',\n      filterFieldTypes: 'geo_point'\n    }, {\n      name: 'autoPrecision',\n      default: true,\n      write: _lodash2.default.noop\n    }, {\n      name: 'isFilteredByCollar',\n      default: true,\n      write: _lodash2.default.noop\n    }, {\n      name: 'useGeocentroid',\n      default: true,\n      write: _lodash2.default.noop\n    }, {\n      name: 'mapZoom',\n      write: _lodash2.default.noop\n    }, {\n      name: 'mapCenter',\n      write: _lodash2.default.noop\n    }, {\n      name: 'precision',\n      editor: _precision2.default,\n      default: defaultPrecision,\n      deserialize: getPrecision,\n      controller: function controller() {},\n      write: function write(aggConfig, output) {\n        var vis = aggConfig.vis;\n        var currZoom = getMapZoom(vis);\n        var autoPrecisionVal = zoomPrecision[currZoom];\n        output.params.precision = aggConfig.params.autoPrecision ? autoPrecisionVal : getPrecision(aggConfig.params.precision);\n      }\n    }],\n    getRequestAggs: function getRequestAggs(agg) {\n      var aggs = [];\n\n      if (agg.params.isFilteredByCollar && agg.getField()) {\n        var vis = agg.vis;\n        var mapBounds = vis.sessionState.mapBounds;\n        var mapZoom = getMapZoom(vis);\n        if (mapBounds) {\n          var lastMapCollar = vis.sessionState.mapCollar;\n          var mapCollar = void 0;\n          if (!lastMapCollar || lastMapCollar.zoom !== mapZoom || isOutsideCollar(mapBounds, lastMapCollar)) {\n            mapCollar = (0, _geo_utils.scaleBounds)(mapBounds);\n            mapCollar.zoom = mapZoom;\n            vis.sessionState.mapCollar = mapCollar;\n          } else {\n            mapCollar = lastMapCollar;\n          }\n          var boundingBox = {};\n          boundingBox[agg.getField().name] = {\n            top_left: mapCollar.top_left,\n            bottom_right: mapCollar.bottom_right\n          };\n          aggs.push(new AggConfig(agg.vis, {\n            type: 'filter',\n            id: 'filter_agg',\n            enabled: true,\n            params: {\n              geo_bounding_box: boundingBox\n            },\n            schema: {\n              group: 'buckets'\n            }\n          }));\n        }\n      }\n\n      aggs.push(agg);\n\n      if (agg.params.useGeocentroid) {\n        aggs.push(new AggConfig(agg.vis, {\n          type: 'geo_centroid',\n          enabled: true,\n          params: {\n            field: agg.getField()\n          },\n          schema: 'metric'\n        }));\n      }\n\n      return aggs;\n    }\n  });\n}",null]}