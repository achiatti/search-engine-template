{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/angular-bootstrap/position/position.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/angular-bootstrap/position/position.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n.factory('$position', ['$document', '$window', function ($document, $window) {\n\n  function getStyle(el, cssprop) {\n    if (el.currentStyle) {\n      //IE\n      return el.currentStyle[cssprop];\n    } else if ($window.getComputedStyle) {\n      return $window.getComputedStyle(el)[cssprop];\n    }\n    // finally try and get inline style\n    return el.style[cssprop];\n  }\n\n  /**\n   * Checks if a given element is statically positioned\n   * @param element - raw DOM element\n   */\n  function isStaticPositioned(element) {\n    return (getStyle(element, 'position') || 'static') === 'static';\n  }\n\n  /**\n   * returns the closest, non-statically positioned parentOffset of a given element\n   * @param element\n   */\n  var parentOffsetEl = function parentOffsetEl(element) {\n    var docDomEl = $document[0];\n    var offsetParent = element.offsetParent || docDomEl;\n    while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {\n      offsetParent = offsetParent.offsetParent;\n    }\n    return offsetParent || docDomEl;\n  };\n\n  return {\n    /**\n     * Provides read-only equivalent of jQuery's position function:\n     * http://api.jquery.com/position/\n     */\n    position: function position(element) {\n      var elBCR = this.offset(element);\n      var offsetParentBCR = { top: 0, left: 0 };\n      var offsetParentEl = parentOffsetEl(element[0]);\n      if (offsetParentEl != $document[0]) {\n        offsetParentBCR = this.offset(angular.element(offsetParentEl));\n        offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n        offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n      }\n\n      var boundingClientRect = element[0].getBoundingClientRect();\n      return {\n        width: boundingClientRect.width || element.prop('offsetWidth'),\n        height: boundingClientRect.height || element.prop('offsetHeight'),\n        top: elBCR.top - offsetParentBCR.top,\n        left: elBCR.left - offsetParentBCR.left\n      };\n    },\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * http://api.jquery.com/offset/\n     */\n    offset: function offset(element) {\n      var boundingClientRect = element[0].getBoundingClientRect();\n      return {\n        width: boundingClientRect.width || element.prop('offsetWidth'),\n        height: boundingClientRect.height || element.prop('offsetHeight'),\n        top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n        left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n      };\n    },\n\n    /**\n     * Provides coordinates for the targetEl in relation to hostEl\n     */\n    positionElements: function positionElements(hostEl, targetEl, positionStr, appendToBody) {\n\n      var positionStrParts = positionStr.split('-');\n      var pos0 = positionStrParts[0],\n          pos1 = positionStrParts[1] || 'center';\n\n      var hostElPos, targetElWidth, targetElHeight, targetElPos;\n\n      hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n      targetElWidth = targetEl.prop('offsetWidth');\n      targetElHeight = targetEl.prop('offsetHeight');\n\n      var shiftWidth = {\n        center: function center() {\n          return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n        },\n        left: function left() {\n          return hostElPos.left;\n        },\n        right: function right() {\n          return hostElPos.left + hostElPos.width;\n        }\n      };\n\n      var shiftHeight = {\n        center: function center() {\n          return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n        },\n        top: function top() {\n          return hostElPos.top;\n        },\n        bottom: function bottom() {\n          return hostElPos.top + hostElPos.height;\n        }\n      };\n\n      switch (pos0) {\n        case 'right':\n          targetElPos = {\n            top: shiftHeight[pos1](),\n            left: shiftWidth[pos0]()\n          };\n          break;\n        case 'left':\n          targetElPos = {\n            top: shiftHeight[pos1](),\n            left: hostElPos.left - targetElWidth\n          };\n          break;\n        case 'bottom':\n          targetElPos = {\n            top: shiftHeight[pos0](),\n            left: shiftWidth[pos1]()\n          };\n          break;\n        default:\n          targetElPos = {\n            top: hostElPos.top - targetElHeight,\n            left: shiftWidth[pos1]()\n          };\n          break;\n      }\n\n      return targetElPos;\n    }\n  };\n}]);",null]}