{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/fixed_scroll.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/fixed_scroll.js","mtime":1515552033000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SCROLLER_HEIGHT = 20;\n\n/**\n * This directive adds a fixed horizontal scrollbar to the bottom of the window that proxies its scroll events\n * to the target element's real scrollbar. This is useful when the target element's horizontal scrollbar\n * might be waaaay down the page, like the doc table on Discover.\n */\n_modules.uiModules.get('kibana').directive('fixedScroll', function (debounce) {\n  return {\n    restrict: 'A',\n    link: function link($scope, $el) {\n      var $window = (0, _jquery2.default)(window);\n      var $scroller = (0, _jquery2.default)('<div class=\"fixed-scroll-scroller\">').height(SCROLLER_HEIGHT);\n\n      /**\n      * Remove the listeners bound in listen()\n      * @type {function}\n      */\n      var unlisten = _lodash2.default.noop;\n\n      /**\n      * Listen for scroll events on the $scroller and the $el, sets unlisten()\n      *\n      * unlisten must be called before calling or listen() will throw an Error\n      *\n      * Since the browser emits \"scroll\" events after setting scrollLeft\n      * the listeners also prevent tug-of-war\n      *\n      * @throws {Error} If unlisten was not called first\n      * @return {undefined}\n      */\n      function listen() {\n        if (unlisten !== _lodash2.default.noop) {\n          throw new Error('fixedScroll listeners were not cleaned up properly before re-listening!');\n        }\n\n        var blockTo = void 0;\n        function bind($from, $to) {\n          function handler() {\n            if (blockTo === $to) return blockTo = null;\n            $to.scrollLeft((blockTo = $from).scrollLeft());\n          }\n\n          $from.on('scroll', handler);\n          return function () {\n            $from.off('scroll', handler);\n          };\n        }\n\n        unlisten = _lodash2.default.flow(bind($el, $scroller), bind($scroller, $el), function () {\n          unlisten = _lodash2.default.noop;\n        });\n      }\n\n      /**\n      * Revert DOM changes and event listeners\n      * @return {undefined}\n      */\n      function cleanUp() {\n        unlisten();\n        $scroller.detach();\n        $el.css('padding-bottom', 0);\n      }\n\n      /**\n      * Modify the DOM and attach event listeners based on need.\n      * Is called many times to re-setup, must be idempotent\n      * @return {undefined}\n      */\n      function setup() {\n        cleanUp();\n\n        var containerWidth = $el.width();\n        var contentWidth = $el.prop('scrollWidth');\n        var containerHorizOverflow = contentWidth - containerWidth;\n\n        var elTop = $el.offset().top - $window.scrollTop();\n        var elBottom = elTop + $el.height();\n        var windowVertOverflow = elBottom - $window.height();\n\n        var requireScroller = containerHorizOverflow > 0 && windowVertOverflow > 0;\n        if (!requireScroller) return;\n\n        // push the content away from the scroller\n        $el.css('padding-bottom', SCROLLER_HEIGHT);\n\n        // fill the scroller with a dummy element that mimics the content\n        $scroller.width(containerWidth).html((0, _jquery2.default)('<div>').css({ width: contentWidth, height: SCROLLER_HEIGHT })).insertAfter($el);\n\n        // listen for scroll events\n        listen();\n      }\n\n      var width = void 0;\n      var scrollWidth = void 0;\n      function checkWidth() {\n        var newScrollWidth = $el.prop('scrollWidth');\n        var newWidth = $el.width();\n\n        if (scrollWidth !== newScrollWidth || width !== newWidth) {\n          $scope.$apply(setup);\n\n          scrollWidth = newScrollWidth;\n          width = newWidth;\n        }\n      }\n\n      var debouncedCheckWidth = debounce(checkWidth, 100, {\n        invokeApply: false\n      });\n      $scope.$watch(debouncedCheckWidth);\n\n      // cleanup when the scope is destroyed\n      $scope.$on('$destroy', function () {\n        cleanUp();\n        debouncedCheckWidth.cancel();\n        $scroller = $window = null;\n      });\n    }\n  };\n});",null]}