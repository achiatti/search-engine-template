{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/timelion/public/directives/timelion_expression_input_helpers.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/timelion/public/directives/timelion_expression_input_helpers.js","mtime":1515552031000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.suggest = exports.Suggestions = exports.SUGGESTION_TYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar extractSuggestionsFromParsedResult = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(result, cursorPosition, functionList, argValueSuggestions) {\n    var activeFunc, functionHelp, openParen, activeArg, functionName, functionArgs, argName, partialInput, valueSuggestions, _functionHelp$args$fi, staticSuggestions, providedArguments, args, argumentSuggestions, location;\n\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            activeFunc = result.functions.find(function (func) {\n              return cursorPosition >= func.location.min && cursorPosition < func.location.max;\n            });\n\n            if (activeFunc) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt('return');\n\n          case 3:\n            functionHelp = functionList.find(function (func) {\n              return func.name === activeFunc.function;\n            });\n\n            // return function suggestion when cursor is outside of parentheses\n            // location range includes '.', function name, and '('.\n\n            openParen = activeFunc.location.min + activeFunc.function.length + 2;\n\n            if (!(cursorPosition < openParen)) {\n              _context.next = 7;\n              break;\n            }\n\n            return _context.abrupt('return', { list: [functionHelp], location: activeFunc.location, type: SUGGESTION_TYPE.FUNCTIONS });\n\n          case 7:\n\n            // return argument value suggestions when cursor is inside agrument value\n            activeArg = activeFunc.arguments.find(function (argument) {\n              return inLocation(cursorPosition, argument.location);\n            });\n\n            if (!(activeArg && activeArg.type === 'namedArg' && inLocation(cursorPosition, activeArg.value.location))) {\n              _context.next = 21;\n              break;\n            }\n\n            functionName = activeFunc.function, functionArgs = activeFunc.arguments;\n            argName = activeArg.name, partialInput = activeArg.value.text;\n            valueSuggestions = void 0;\n\n            if (!argValueSuggestions.hasDynamicSuggestionsForArgument(functionName, argName)) {\n              _context.next = 18;\n              break;\n            }\n\n            _context.next = 15;\n            return argValueSuggestions.getDynamicSuggestionsForArgument(functionName, argName, functionArgs, partialInput);\n\n          case 15:\n            valueSuggestions = _context.sent;\n            _context.next = 20;\n            break;\n\n          case 18:\n            _functionHelp$args$fi = functionHelp.args.find(function (arg) {\n              return arg.name === activeArg.name;\n            }), staticSuggestions = _functionHelp$args$fi.suggestions;\n\n            valueSuggestions = argValueSuggestions.getStaticSuggestionsForInput(partialInput, staticSuggestions);\n\n          case 20:\n            return _context.abrupt('return', { list: valueSuggestions, location: activeArg.value.location, type: SUGGESTION_TYPE.ARGUMENT_VALUE });\n\n          case 21:\n\n            // return argument suggestions\n            providedArguments = activeFunc.arguments.map(function (arg) {\n              return arg.name;\n            });\n            // Do not provide 'inputSeries' as argument suggestion for chainable functions\n\n            args = functionHelp.chainable ? functionHelp.args.slice(1) : functionHelp.args.slice(0);\n            argumentSuggestions = args.filter(function (arg) {\n              // ignore arguments that are all ready provided in function declaration\n              if (providedArguments.includes(arg.name)) {\n                return false;\n              }\n\n              if (_lodash2.default.get(activeArg, 'type') === 'namedArg') {\n                return _lodash2.default.startsWith(arg.name, activeArg.name);\n              } else if (activeArg) {\n                return _lodash2.default.startsWith(arg.name, activeArg.text);\n              }\n              return true;\n            });\n            location = activeArg ? activeArg.location : { min: cursorPosition, max: cursorPosition };\n            return _context.abrupt('return', { list: argumentSuggestions, location: location, type: SUGGESTION_TYPE.ARGUMENTS });\n\n          case 26:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function extractSuggestionsFromParsedResult(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar suggest = exports.suggest = function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(expression, functionList, Parser, cursorPosition, argValueSuggestions) {\n    var result, message, list, _message, argName, functionName, functionArgs, valueSuggestions, functionHelp, argHelp;\n\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return Parser.parse(expression);\n\n          case 3:\n            result = _context2.sent;\n            _context2.next = 6;\n            return extractSuggestionsFromParsedResult(result, cursorPosition, functionList, argValueSuggestions);\n\n          case 6:\n            return _context2.abrupt('return', _context2.sent);\n\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2['catch'](0);\n            message = void 0;\n            _context2.prev = 12;\n\n            // The grammar will throw an error containing a message if the expression is formatted\n            // correctly and is prepared to accept suggestions. If the expression is not formmated\n            // correctly the grammar will just throw a regular PEG SyntaxError, and this JSON.parse\n            // attempt will throw an error.\n            message = JSON.parse(_context2.t0.message);\n            _context2.next = 19;\n            break;\n\n          case 16:\n            _context2.prev = 16;\n            _context2.t1 = _context2['catch'](12);\n            return _context2.abrupt('return');\n\n          case 19:\n            _context2.t2 = message.type;\n            _context2.next = _context2.t2 === 'incompleteFunction' ? 22 : _context2.t2 === 'incompleteArgument' ? 25 : 36;\n            break;\n\n          case 22:\n            list = void 0;\n\n            if (message.function) {\n              // The user has start typing a function name, so we'll filter the list down to only\n              // possible matches.\n              list = functionList.filter(function (func) {\n                return _lodash2.default.startsWith(func.name, message.function);\n              });\n            } else {\n              // The user hasn't typed anything yet, so we'll just return the entire list.\n              list = functionList;\n            }\n            return _context2.abrupt('return', { list: list, location: message.location, type: SUGGESTION_TYPE.FUNCTIONS });\n\n          case 25:\n            _message = message, argName = _message.name, functionName = _message.currentFunction, functionArgs = _message.currentArgs;\n            valueSuggestions = [];\n\n            if (!argValueSuggestions.hasDynamicSuggestionsForArgument(functionName, argName)) {\n              _context2.next = 33;\n              break;\n            }\n\n            _context2.next = 30;\n            return argValueSuggestions.getDynamicSuggestionsForArgument(functionName, argName, functionArgs);\n\n          case 30:\n            valueSuggestions = _context2.sent;\n            _context2.next = 35;\n            break;\n\n          case 33:\n            functionHelp = functionList.find(function (func) {\n              return func.name === functionName;\n            });\n\n            if (functionHelp) {\n              argHelp = functionHelp.args.find(function (arg) {\n                return arg.name === argName;\n              });\n\n              if (argHelp && argHelp.suggestions) {\n                valueSuggestions = argHelp.suggestions;\n              }\n            }\n\n          case 35:\n            return _context2.abrupt('return', {\n              list: valueSuggestions,\n              location: { min: cursorPosition, max: cursorPosition },\n              type: SUGGESTION_TYPE.ARGUMENT_VALUE\n            });\n\n          case 36:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this, [[0, 9], [12, 16]]);\n  }));\n\n  return function suggest(_x5, _x6, _x7, _x8, _x9) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.insertAtLocation = insertAtLocation;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SUGGESTION_TYPE = exports.SUGGESTION_TYPE = {\n  ARGUMENTS: 'arguments',\n  ARGUMENT_VALUE: 'argument_value',\n  FUNCTIONS: 'functions'\n};\n\nvar Suggestions = exports.Suggestions = function () {\n  function Suggestions() {\n    _classCallCheck(this, Suggestions);\n\n    this.reset();\n  }\n\n  _createClass(Suggestions, [{\n    key: 'reset',\n    value: function reset() {\n      this.index = -1;\n      this.list = [];\n      this.type = null;\n      this.isVisible = false;\n    }\n  }, {\n    key: 'setList',\n    value: function setList(list, type) {\n      this.list = list.sort(function (a, b) {\n        if (a.name < b.name) {\n          return -1;\n        }\n        if (a.name > b.name) {\n          return 1;\n        }\n        // names must be equal\n        return 0;\n      });\n      this.type = type;\n\n      // Only try to position index inside of list range, when it was already focused\n      // beforehand (i.e. not -1)\n      if (this.index > -1) {\n        // We may get a shorter list than the one we have now, so we need to make sure our index doesn't\n        // fall outside of the new list's range.\n        this.index = Math.max(0, Math.min(this.index, this.list.length - 1));\n      }\n    }\n  }, {\n    key: 'getCount',\n    value: function getCount() {\n      return this.list.length;\n    }\n  }, {\n    key: 'isEmpty',\n    value: function isEmpty() {\n      return this.list.length === 0;\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      this.isVisible = true;\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.isVisible = false;\n    }\n  }, {\n    key: 'stepForward',\n    value: function stepForward() {\n      if (this.index > 0) {\n        this.index -= 1;\n      }\n    }\n  }, {\n    key: 'stepBackward',\n    value: function stepBackward() {\n      if (this.index < this.list.length - 1) {\n        this.index += 1;\n      }\n    }\n  }]);\n\n  return Suggestions;\n}();\n\nfunction inLocation(cursorPosition, location) {\n  return cursorPosition >= location.min && cursorPosition <= location.max;\n}\n\nfunction insertAtLocation(valueToInsert, destination, replacementRangeStart, replacementRangeEnd) {\n  // Insert the value at a location caret within the destination.\n  var prefix = destination.slice(0, replacementRangeStart);\n  var suffix = destination.slice(replacementRangeEnd, destination.length);\n  var result = '' + prefix + valueToInsert + suffix;\n  return result;\n}",null]}