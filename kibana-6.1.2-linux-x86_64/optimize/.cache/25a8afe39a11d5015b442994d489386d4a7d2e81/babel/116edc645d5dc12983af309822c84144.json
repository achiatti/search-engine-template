{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_types/metrics/top_hit.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_types/metrics/top_hit.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.AggTypesMetricsTopHitProvider = AggTypesMetricsTopHitProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _metric_agg_type = require('ui/agg_types/metrics/metric_agg_type');\n\nvar _top_sort = require('ui/agg_types/controls/top_sort.html');\n\nvar _top_sort2 = _interopRequireDefault(_top_sort);\n\nvar _top_aggregate_and_size = require('ui/agg_types/controls/top_aggregate_and_size.html');\n\nvar _top_aggregate_and_size2 = _interopRequireDefault(_top_aggregate_and_size);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AggTypesMetricsTopHitProvider(Private) {\n  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);\n\n  var isNumber = function isNumber(type) {\n    return type === 'number';\n  };\n\n  return new MetricAggType({\n    name: 'top_hits',\n    title: 'Top Hit',\n    makeLabel: function makeLabel(aggConfig) {\n      var prefix = aggConfig.params.sortOrder.val === 'desc' ? 'Last' : 'First';\n      if (aggConfig.params.size !== 1) {\n        prefix += ' ' + aggConfig.params.size;\n      }\n      return prefix + ' ' + aggConfig.params.field.displayName;\n    },\n    params: [{\n      name: 'field',\n      onlyAggregatable: false,\n      filterFieldTypes: function filterFieldTypes(vis, value) {\n        if (vis.type.name === 'table' || vis.type.name === 'metric') {\n          return true;\n        }\n        return value === 'number';\n      },\n      write: function write(agg, output) {\n        var field = agg.params.field;\n        output.params = {};\n\n        if (field.scripted) {\n          output.params.script_fields = _defineProperty({}, field.name, {\n            script: {\n              inline: field.script,\n              lang: field.lang\n            }\n          });\n        } else {\n          if (field.readFromDocValues) {\n            output.params.docvalue_fields = [field.name];\n          }\n          output.params._source = field.name === '_source' ? true : field.name;\n        }\n      }\n    }, {\n      name: 'aggregate',\n      type: 'optioned',\n      editor: _top_aggregate_and_size2.default,\n      options: [{\n        display: 'Min',\n        isCompatibleType: isNumber,\n        isCompatibleVis: _lodash2.default.constant(true),\n        disabled: true,\n        val: 'min'\n      }, {\n        display: 'Max',\n        isCompatibleType: isNumber,\n        isCompatibleVis: _lodash2.default.constant(true),\n        disabled: true,\n        val: 'max'\n      }, {\n        display: 'Sum',\n        isCompatibleType: isNumber,\n        isCompatibleVis: _lodash2.default.constant(true),\n        disabled: true,\n        val: 'sum'\n      }, {\n        display: 'Average',\n        isCompatibleType: isNumber,\n        isCompatibleVis: _lodash2.default.constant(true),\n        disabled: true,\n        val: 'average'\n      }, {\n        display: 'Concatenate',\n        isCompatibleType: _lodash2.default.constant(true),\n        isCompatibleVis: function isCompatibleVis(name) {\n          return name === 'metric' || name === 'table';\n        },\n        disabled: true,\n        val: 'concat'\n      }],\n      controller: function controller($scope) {\n        $scope.options = [];\n        $scope.$watchGroup(['agg.vis.type.name', 'agg.params.field.type'], function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              visName = _ref2[0],\n              fieldType = _ref2[1];\n\n          if (fieldType && visName) {\n            $scope.options = _lodash2.default.filter($scope.aggParam.options, function (option) {\n              return option.isCompatibleVis(visName) && option.isCompatibleType(fieldType);\n            });\n            if ($scope.options.length === 1) {\n              $scope.agg.params.aggregate = $scope.options[0];\n            }\n          }\n        });\n      },\n      write: _lodash2.default.noop\n    }, {\n      name: 'size',\n      editor: null, // size setting is done together with the aggregation setting\n      default: 1\n    }, {\n      name: 'sortField',\n      type: 'field',\n      editor: null,\n      filterFieldTypes: ['number', 'date', 'ip', 'string'],\n      default: function _default(agg) {\n        return agg.vis.indexPattern.timeFieldName;\n      },\n      write: _lodash2.default.noop // prevent default write, it is handled below\n    }, {\n      name: 'sortOrder',\n      type: 'optioned',\n      default: 'desc',\n      editor: _top_sort2.default,\n      options: [{ display: 'Descending', val: 'desc' }, { display: 'Ascending', val: 'asc' }],\n      write: function write(agg, output) {\n        var sortField = agg.params.sortField;\n        var sortOrder = agg.params.sortOrder;\n\n        if (sortField.scripted) {\n          output.params.sort = [{\n            _script: {\n              script: {\n                inline: sortField.script,\n                lang: sortField.lang\n              },\n              type: sortField.type,\n              order: sortOrder.val\n            }\n          }];\n        } else {\n          output.params.sort = [_defineProperty({}, sortField.name, {\n            order: sortOrder.val\n          })];\n        }\n      }\n    }],\n    getValue: function getValue(agg, bucket) {\n      var hits = _lodash2.default.get(bucket, agg.id + '.hits.hits');\n      if (!hits || !hits.length) {\n        return null;\n      }\n      var path = agg.params.field.name;\n\n      var values = (0, _lodash2.default)(hits).map(function (hit) {\n        return path === '_source' ? hit._source : agg.vis.indexPattern.flattenHit(hit, true)[path];\n      }).flatten().value();\n\n      if (values.length === 1) {\n        values = values[0];\n      }\n\n      if (Array.isArray(values)) {\n        if (!_lodash2.default.compact(values).length) {\n          return null;\n        }\n        switch (agg.params.aggregate.val) {\n          case 'max':\n            return _lodash2.default.max(values);\n          case 'min':\n            return _lodash2.default.min(values);\n          case 'sum':\n            return _lodash2.default.sum(values);\n          case 'average':\n            return _lodash2.default.sum(values) / values.length;\n        }\n      }\n      return values;\n    }\n  });\n}",null]}