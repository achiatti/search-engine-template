{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/curl.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/curl.js","mtime":1515552026000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.detectCURL = detectCURL;\nexports.parseCURL = parseCURL;\nfunction detectCURLinLine(line) {\n  // returns true if text matches a curl request\n  return line.match(/^\\s*?curl\\s+(-X[A-Z]+)?\\s*['\"]?.*?['\"]?(\\s*$|\\s+?-d\\s*?['\"])/);\n}\n\nfunction detectCURL(text) {\n  // returns true if text matches a curl request\n  if (!text) return false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = text.split(\"\\n\")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var line = _step.value;\n\n      if (detectCURLinLine(line)) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction parseCURL(text) {\n  var state = 'NONE';\n  var out = [];\n  var body = [];\n  var line = '';\n  var lines = text.trim().split(\"\\n\");\n  var matches;\n\n  var EmptyLine = /^\\s*$/;\n  var Comment = /^\\s*(?:#|\\/{2,})(.*)\\n?$/;\n  var ExecutionComment = /^\\s*#!/;\n  var ClosingSingleQuote = /^([^']*)'/;\n  var ClosingDoubleQuote = /^((?:[^\\\\\"]|\\\\.)*)\"/;\n  var EscapedQuotes = /^((?:[^\\\\\"']|\\\\.)+)/;\n\n  var LooksLikeCurl = /^\\s*curl\\s+/;\n  var CurlVerb = /-X ?(GET|HEAD|POST|PUT|DELETE)/;\n\n  var HasProtocol = /[\\s\"']https?:\\/\\//;\n  var CurlRequestWithProto = /[\\s\"']https?:\\/\\/[^\\/ ]+\\/+([^\\s\"']+)/;\n  var CurlRequestWithoutProto = /[\\s\"'][^\\/ ]+\\/+([^\\s\"']+)/;\n  var CurlData = /^.+\\s(--data|-d)\\s*/;\n  var SenseLine = /^\\s*(GET|HEAD|POST|PUT|DELETE)\\s+\\/?(.+)/;\n\n  if (lines.length > 0 && ExecutionComment.test(lines[0])) {\n    lines.shift();\n  }\n\n  function nextLine() {\n    if (line.length > 0) {\n      return true;\n    }\n    if (lines.length == 0) {\n      return false;\n    }\n    line = lines.shift().replace(/[\\r\\n]+/g, \"\\n\") + \"\\n\";\n    return true;\n  }\n\n  function unescapeLastBodyEl() {\n    var str = body.pop().replace(/\\\\([\\\\\"'])/g, \"$1\");\n    body.push(str);\n  }\n\n  // Is the next char a single or double quote?\n  // If so remove it\n  function detectQuote() {\n    if (line.substr(0, 1) == \"'\") {\n      line = line.substr(1);\n      state = 'SINGLE_QUOTE';\n    } else if (line.substr(0, 1) == '\"') {\n      line = line.substr(1);\n      state = 'DOUBLE_QUOTE';\n    } else {\n      state = 'UNQUOTED';\n    }\n  }\n\n  // Body is finished - append to output with final LF\n  function addBodyToOut() {\n    if (body.length > 0) {\n      out.push(body.join(\"\"));\n      body = [];\n    }\n    state = 'LF';\n    out.push(\"\\n\");\n  }\n\n  // If the pattern matches, then the state is about to change,\n  // so add the capture to the body and detect the next state\n  // Otherwise add the whole line\n  function consumeMatching(pattern) {\n    var matches = line.match(pattern);\n    if (matches) {\n      body.push(matches[1]);\n      line = line.substr(matches[0].length);\n      detectQuote();\n    } else {\n      body.push(line);\n      line = '';\n    }\n  }\n\n  function parseCurlLine() {\n    var verb = 'GET';\n    var request = '';\n    var matches;\n    if (matches = line.match(CurlVerb)) {\n      verb = matches[1];\n    }\n\n    // JS regexen don't support possesive quantifiers, so\n    // we need two distinct patterns\n    var pattern = HasProtocol.test(line) ? CurlRequestWithProto : CurlRequestWithoutProto;\n\n    if (matches = line.match(pattern)) {\n      request = matches[1];\n    }\n\n    out.push(verb + ' /' + request + \"\\n\");\n\n    if (matches = line.match(CurlData)) {\n      line = line.substr(matches[0].length);\n      detectQuote();\n      if (EmptyLine.test(line)) {\n        line = '';\n      }\n    } else {\n      state = 'NONE';\n      line = '';\n      out.push('');\n    }\n  }\n\n  while (nextLine()) {\n\n    if (state == 'SINGLE_QUOTE') {\n      consumeMatching(ClosingSingleQuote);\n    } else if (state == 'DOUBLE_QUOTE') {\n      consumeMatching(ClosingDoubleQuote);\n      unescapeLastBodyEl();\n    } else if (state == 'UNQUOTED') {\n      consumeMatching(EscapedQuotes);\n      if (body.length) {\n        unescapeLastBodyEl();\n      }\n      if (state == 'UNQUOTED') {\n        addBodyToOut();\n        line = '';\n      }\n    }\n\n    // the BODY state (used to match the body of a Sense request)\n    // can be terminated early if it encounters\n    // a comment or an empty line\n    else if (state == 'BODY') {\n        if (Comment.test(line) || EmptyLine.test(line)) {\n          addBodyToOut();\n        } else {\n          body.push(line);\n          line = '';\n        }\n      } else if (EmptyLine.test(line)) {\n        if (state != 'LF') {\n          out.push(\"\\n\");\n          state = 'LF';\n        }\n        line = '';\n      } else if (matches = line.match(Comment)) {\n        out.push(\"#\" + matches[1] + \"\\n\");\n        state = 'NONE';\n        line = '';\n      } else if (LooksLikeCurl.test(line)) {\n        parseCurlLine();\n      } else if (matches = line.match(SenseLine)) {\n        out.push(matches[1] + ' /' + matches[2] + \"\\n\");\n        line = '';\n        state = 'BODY';\n      }\n\n      // Nothing else matches, so output with a prefix of !!! for debugging purposes\n      else {\n          out.push('### ' + line);\n          line = '';\n        }\n  }\n\n  addBodyToOut();\n  return out.join('').trim();\n}",null]}