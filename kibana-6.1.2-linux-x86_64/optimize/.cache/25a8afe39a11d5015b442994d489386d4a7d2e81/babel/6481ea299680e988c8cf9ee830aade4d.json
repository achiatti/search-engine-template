{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/visualizations/point_series/heatmap_chart.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/visualizations/point_series/heatmap_chart.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.VislibVisualizationsHeatmapChartProvider = VislibVisualizationsHeatmapChartProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _point_series = require('./_point_series');\n\nvar _heatmap_color = require('ui/vislib/components/color/heatmap_color');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction VislibVisualizationsHeatmapChartProvider(Private) {\n\n  var PointSeries = Private(_point_series.VislibVisualizationsPointSeriesProvider);\n\n  var defaults = {\n    color: undefined, // todo\n    fillColor: undefined // todo\n  };\n  /**\n   * Line Chart Visualization\n   *\n   * @class HeatmapChart\n   * @constructor\n   * @extends Chart\n   * @param handler {Object} Reference to the Handler Class Constructor\n   * @param el {HTMLElement} HTML element to which the chart will be appended\n   * @param chartData {Object} Elasticsearch query results for this specific chart\n   */\n\n  var HeatmapChart = function (_PointSeries) {\n    _inherits(HeatmapChart, _PointSeries);\n\n    function HeatmapChart(handler, chartEl, chartData, seriesConfigArgs) {\n      _classCallCheck(this, HeatmapChart);\n\n      var _this = _possibleConstructorReturn(this, (HeatmapChart.__proto__ || Object.getPrototypeOf(HeatmapChart)).call(this, handler, chartEl, chartData, seriesConfigArgs));\n\n      _this.seriesConfig = _lodash2.default.defaults(seriesConfigArgs || {}, defaults);\n\n      _this.handler.visConfig.set('legend', {\n        labels: _this.getHeatmapLabels(_this.handler.visConfig),\n        colors: _this.getHeatmapColors(_this.handler.visConfig)\n      });\n\n      var colors = _this.handler.visConfig.get('legend.colors', null);\n      if (colors) {\n        _this.handler.vis.uiState.setSilent('vis.defaultColors', null);\n        _this.handler.vis.uiState.setSilent('vis.defaultColors', colors);\n      }\n      return _this;\n    }\n\n    _createClass(HeatmapChart, [{\n      key: 'getHeatmapLabels',\n      value: function getHeatmapLabels(cfg) {\n        var percentageMode = cfg.get('percentageMode');\n        var colorsNumber = cfg.get('colorsNumber');\n        var colorsRange = cfg.get('colorsRange');\n        var zAxisConfig = this.getValueAxis().axisConfig;\n        var zAxisFormatter = zAxisConfig.get('labels.axisFormatter');\n        var zScale = this.getValueAxis().getScale();\n\n        var _zScale$domain = zScale.domain(),\n            _zScale$domain2 = _slicedToArray(_zScale$domain, 2),\n            min = _zScale$domain2[0],\n            max = _zScale$domain2[1];\n\n        var labels = [];\n        if (cfg.get('setColorRange')) {\n          colorsRange.forEach(function (range) {\n            var from = isFinite(range.from) ? zAxisFormatter(range.from) : range.from;\n            var to = isFinite(range.to) ? zAxisFormatter(range.to) : range.to;\n            labels.push(from + ' - ' + to);\n          });\n        } else {\n          if (max === min) {\n            return [min.toString()];\n          }\n          for (var i = 0; i < colorsNumber; i++) {\n            var label = void 0;\n            var val = i / colorsNumber;\n            var nextVal = (i + 1) / colorsNumber;\n            if (percentageMode) {\n              val = Math.ceil(val * 100);\n              nextVal = Math.ceil(nextVal * 100);\n              label = val + '% - ' + nextVal + '%';\n            } else {\n              val = val * (max - min) + min;\n              nextVal = nextVal * (max - min) + min;\n              if (max > 1) {\n                val = Math.ceil(val);\n                nextVal = Math.ceil(nextVal);\n              }\n              if (isFinite(val)) val = zAxisFormatter(val);\n              if (isFinite(nextVal)) nextVal = zAxisFormatter(nextVal);\n              label = val + ' - ' + nextVal;\n            }\n\n            labels.push(label);\n          }\n        }\n\n        return labels;\n      }\n    }, {\n      key: 'getHeatmapColors',\n      value: function getHeatmapColors(cfg) {\n        var colorsNumber = cfg.get('colorsNumber');\n        var invertColors = cfg.get('invertColors');\n        var colorSchema = cfg.get('colorSchema');\n        var labels = this.getHeatmapLabels(cfg);\n        var colors = {};\n        for (var i in labels) {\n          if (labels[i]) {\n            var val = invertColors ? 1 - i / colorsNumber : i / colorsNumber;\n            colors[labels[i]] = (0, _heatmap_color.getHeatmapColors)(val, colorSchema);\n          }\n        }\n        return colors;\n      }\n    }, {\n      key: 'addSquares',\n      value: function addSquares(svg, data) {\n        var xScale = this.getCategoryAxis().getScale();\n        var yScale = this.handler.categoryAxes[1].getScale();\n        var zScale = this.getValueAxis().getScale();\n        var tooltip = this.baseChart.tooltip;\n        var isTooltip = this.handler.visConfig.get('tooltip.show');\n        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();\n        var colorsNumber = this.handler.visConfig.get('colorsNumber');\n        var setColorRange = this.handler.visConfig.get('setColorRange');\n        var colorsRange = this.handler.visConfig.get('colorsRange');\n        var color = this.handler.data.getColorFunc();\n        var labels = this.handler.visConfig.get('legend.labels');\n        var zAxisConfig = this.getValueAxis().axisConfig;\n        var zAxisFormatter = zAxisConfig.get('labels.axisFormatter');\n        var showLabels = zAxisConfig.get('labels.show');\n\n        var layer = svg.append('g').attr('class', 'series');\n\n        var squares = layer.selectAll('g.square').data(data.values);\n\n        squares.exit().remove();\n\n        var barWidth = void 0;\n        if (this.getCategoryAxis().axisConfig.isTimeDomain()) {\n          var _handler$data$get = this.handler.data.get('ordered'),\n              _min = _handler$data$get.min,\n              interval = _handler$data$get.interval;\n\n          var start = _min;\n          var end = (0, _moment2.default)(_min).add(interval).valueOf();\n\n          barWidth = xScale(end) - xScale(start);\n          if (!isHorizontal) barWidth *= -1;\n        }\n\n        function x(d) {\n          return xScale(d.x);\n        }\n\n        function y(d) {\n          return yScale(d.series);\n        }\n\n        var _zScale$domain3 = zScale.domain(),\n            _zScale$domain4 = _slicedToArray(_zScale$domain3, 2),\n            min = _zScale$domain4[0],\n            max = _zScale$domain4[1];\n\n        function getColorBucket(d) {\n          var val = 0;\n          if (setColorRange && colorsRange.length) {\n            var bucket = _lodash2.default.find(colorsRange, function (range) {\n              return range.from <= d.y && range.to > d.y;\n            });\n            return bucket ? colorsRange.indexOf(bucket) : -1;\n          } else {\n            if (isNaN(min) || isNaN(max)) {\n              val = colorsNumber - 1;\n            } else if (min === max) {\n              val = 0;\n            } else {\n              val = (d.y - min) / (max - min); /* get val from 0 - 1 */\n              val = Math.min(colorsNumber - 1, Math.floor(val * colorsNumber));\n            }\n          }\n          return !isNaN(val) ? val : -1;\n        }\n\n        function label(d) {\n          var colorBucket = getColorBucket(d);\n          if (colorBucket === -1) d.hide = true;\n          return labels[colorBucket];\n        }\n\n        function z(d) {\n          if (label(d) === '') return 'transparent';\n          return color(label(d));\n        }\n\n        var squareWidth = barWidth || xScale.rangeBand();\n        var squareHeight = yScale.rangeBand();\n\n        squares.enter().append('g').attr('class', 'square');\n\n        squares.append('rect').attr('x', x).attr('width', squareWidth).attr('y', y).attr('height', squareHeight).attr('data-label', label).attr('fill', z).attr('style', 'cursor: pointer; stroke: black; stroke-width: 0.1px').style('display', function (d) {\n          return d.hide ? 'none' : 'initial';\n        });\n\n        // todo: verify that longest label is not longer than the barwidth\n        // or barwidth is not smaller than textheight (and vice versa)\n        //\n        if (showLabels) {\n          var rotate = zAxisConfig.get('labels.rotate');\n          var rotateRad = rotate * Math.PI / 180;\n          var cellPadding = 5;\n          var maxLength = Math.min(Math.abs(squareWidth / Math.cos(rotateRad)), Math.abs(squareHeight / Math.sin(rotateRad))) - cellPadding;\n          var maxHeight = Math.min(Math.abs(squareWidth / Math.sin(rotateRad)), Math.abs(squareHeight / Math.cos(rotateRad))) - cellPadding;\n\n          var hiddenLabels = false;\n          squares.append('text').text(function (d) {\n            return zAxisFormatter(d.y);\n          }).style('display', function (d) {\n            var textLength = this.getBBox().width;\n            var textHeight = this.getBBox().height;\n            var textTooLong = textLength > maxLength;\n            var textTooWide = textHeight > maxHeight;\n            if (!d.hide && (textTooLong || textTooWide)) {\n              hiddenLabels = true;\n            }\n            return d.hide || textTooLong || textTooWide ? 'none' : 'initial';\n          }).style('dominant-baseline', 'central').style('text-anchor', 'middle').style('fill', zAxisConfig.get('labels.color')).attr('x', function (d) {\n            var center = x(d) + squareWidth / 2;\n            return center;\n          }).attr('y', function (d) {\n            var center = y(d) + squareHeight / 2;\n            return center;\n          }).attr('transform', function (d) {\n            var horizontalCenter = x(d) + squareWidth / 2;\n            var verticalCenter = y(d) + squareHeight / 2;\n            return 'rotate(' + rotate + ',' + horizontalCenter + ',' + verticalCenter + ')';\n          });\n          if (hiddenLabels) {\n            this.baseChart.handler.alerts.show('Some labels were hidden due to size constraints');\n          }\n        }\n\n        if (isTooltip) {\n          squares.call(tooltip.render());\n        }\n\n        return squares.selectAll('rect');\n      }\n\n      /**\n       * Renders d3 visualization\n       *\n       * @method draw\n       * @returns {Function} Creates the line chart\n       */\n\n    }, {\n      key: 'draw',\n      value: function draw() {\n        var self = this;\n\n        return function (selection) {\n          selection.each(function () {\n            var svg = self.chartEl.append('g');\n            svg.data([self.chartData]);\n\n            var squares = self.addSquares(svg, self.chartData);\n            self.addCircleEvents(squares);\n\n            self.events.emit('rendered', {\n              chart: self.chartData\n            });\n\n            return svg;\n          });\n        };\n      }\n    }]);\n\n    return HeatmapChart;\n  }(PointSeries);\n\n  return HeatmapChart;\n}",null]}