{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/axis/axis_scale.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/axis/axis_scale.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.VislibAxisScaleProvider = VislibAxisScaleProvider;\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _errors = require('ui/errors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction VislibAxisScaleProvider() {\n  var AxisScale = function () {\n    function AxisScale(axisConfig, visConfig) {\n      _classCallCheck(this, AxisScale);\n\n      this.axisConfig = axisConfig;\n      this.visConfig = visConfig;\n\n      if (this.axisConfig.get('type') === 'category') {\n        this.values = this.axisConfig.values;\n        this.ordered = this.axisConfig.ordered;\n      }\n    }\n\n    _createClass(AxisScale, [{\n      key: 'getScaleType',\n      value: function getScaleType() {\n        return this.axisConfig.getScaleType();\n      }\n    }, {\n      key: 'validateUserExtents',\n      value: function validateUserExtents(domain) {\n        var config = this.axisConfig;\n        return domain.map(function (val) {\n          val = parseFloat(val);\n          if (isNaN(val)) throw new Error(val + ' is not a valid number');\n          if (config.isPercentage() && config.isUserDefined()) return val / 100;\n          return val;\n        });\n      }\n    }, {\n      key: 'getTimeDomain',\n      value: function getTimeDomain(data) {\n        return [this.minExtent(data), this.maxExtent(data)];\n      }\n    }, {\n      key: 'minExtent',\n      value: function minExtent(data) {\n        return this.calculateExtent(data || this.values, 'min');\n      }\n    }, {\n      key: 'maxExtent',\n      value: function maxExtent(data) {\n        return this.calculateExtent(data || this.values, 'max');\n      }\n    }, {\n      key: 'calculateExtent',\n      value: function calculateExtent(data, extent) {\n        var ordered = this.ordered;\n        var opts = [ordered[extent]];\n\n        var point = _d2.default[extent](data);\n        if (this.axisConfig.get('scale.expandLastBucket') && extent === 'max') {\n          point = this.addInterval(point);\n        }\n        opts.push(point);\n\n        return _d2.default[extent](opts.reduce(function (opts, v) {\n          if (!_lodash2.default.isNumber(v)) v = +v;\n          if (!isNaN(v)) opts.push(v);\n          return opts;\n        }, []));\n      }\n    }, {\n      key: 'addInterval',\n      value: function addInterval(x) {\n        return this.modByInterval(x, +1);\n      }\n    }, {\n      key: 'subtractInterval',\n      value: function subtractInterval(x) {\n        return this.modByInterval(x, -1);\n      }\n    }, {\n      key: 'modByInterval',\n      value: function modByInterval(x, n) {\n        var ordered = this.ordered;\n        if (!ordered) return x;\n        var interval = ordered.interval;\n        if (!interval) return x;\n\n        if (!ordered.date) {\n          return x += ordered.interval * n;\n        }\n\n        var y = (0, _moment2.default)(x);\n        var method = n > 0 ? 'add' : 'subtract';\n\n        _lodash2.default.times(Math.abs(n), function () {\n          y[method](interval);\n        });\n\n        return y.valueOf();\n      }\n    }, {\n      key: 'getAllPoints',\n      value: function getAllPoints() {\n        var _this = this;\n\n        var config = this.axisConfig;\n        var data = this.visConfig.data.chartData();\n        var chartPoints = _lodash2.default.reduce(data, function (chartPoints, chart, chartIndex) {\n          var points = chart.series.reduce(function (points, seri, seriIndex) {\n            var seriConfig = _this.visConfig.get('charts[' + chartIndex + '].series[' + seriIndex + ']');\n            var matchingValueAxis = !!seriConfig.valueAxis && seriConfig.valueAxis === config.get('id');\n            var isFirstAxis = config.get('id') === _this.visConfig.get('valueAxes[0].id');\n\n            if (matchingValueAxis || !seriConfig.valueAxis && isFirstAxis) {\n              var axisPoints = seri.values.map(function (val) {\n                if (val.y0) {\n                  return val.y0 + val.y;\n                }\n                return val.y;\n              });\n              return points.concat(axisPoints);\n            }\n            return points;\n          }, []);\n          return chartPoints.concat(points);\n        }, []);\n\n        return chartPoints;\n      }\n    }, {\n      key: 'getYMin',\n      value: function getYMin() {\n        return _d2.default.min(this.getAllPoints());\n      }\n    }, {\n      key: 'getYMax',\n      value: function getYMax() {\n        return _d2.default.max(this.getAllPoints());\n      }\n    }, {\n      key: 'getExtents',\n      value: function getExtents() {\n        if (this.axisConfig.get('type') === 'category') {\n          if (this.axisConfig.isTimeDomain()) return this.getTimeDomain(this.values);\n          if (this.axisConfig.isOrdinal()) return this.values;\n        }\n\n        var min = this.axisConfig.get('scale.min', this.getYMin());\n        var max = this.axisConfig.get('scale.max', this.getYMax());\n        var domain = [min, max];\n        if (this.axisConfig.isUserDefined()) return this.validateUserExtents(domain);\n        if (this.axisConfig.isLogScale()) return this.logDomain(min, max);\n        if (this.axisConfig.isYExtents()) return domain;\n        return [Math.min(0, min), Math.max(0, max)];\n      }\n    }, {\n      key: 'getRange',\n      value: function getRange(length) {\n        if (this.axisConfig.isHorizontal()) {\n          return !this.axisConfig.get('scale.inverted') ? [0, length] : [length, 0];\n        } else {\n          return this.axisConfig.get('scale.inverted') ? [0, length] : [length, 0];\n        }\n      }\n    }, {\n      key: 'throwCustomError',\n      value: function throwCustomError(message) {\n        throw new Error(message);\n      }\n    }, {\n      key: 'throwLogScaleValuesError',\n      value: function throwLogScaleValuesError() {\n        throw new _errors.InvalidLogScaleValues();\n      }\n    }, {\n      key: 'logDomain',\n      value: function logDomain(min, max) {\n        if (min < 0 || max < 0) return this.throwLogScaleValuesError();\n        return [1, max];\n      }\n    }, {\n      key: 'getD3Scale',\n      value: function getD3Scale(scaleTypeArg) {\n        var scaleType = scaleTypeArg || 'linear';\n        if (scaleType === 'square root') scaleType = 'sqrt';\n\n        if (this.axisConfig.isTimeDomain()) return _d2.default.time.scale.utc(); // allow time scale\n        if (this.axisConfig.isOrdinal()) return _d2.default.scale.ordinal();\n        if (typeof _d2.default.scale[scaleType] !== 'function') {\n          return this.throwCustomError('Axis.getScaleType: ' + scaleType + ' is not a function');\n        }\n\n        return _d2.default.scale[scaleType]();\n      }\n    }, {\n      key: 'canApplyNice',\n      value: function canApplyNice() {\n        var config = this.axisConfig;\n        return !config.isUserDefined() && !config.isYExtents() && !config.isOrdinal() && !config.isTimeDomain();\n      }\n    }, {\n      key: 'getScale',\n      value: function getScale(length) {\n        var config = this.axisConfig;\n        var scale = this.getD3Scale(config.getScaleType());\n        var domain = this.getExtents();\n        var range = this.getRange(length);\n        var padding = config.get('style.rangePadding');\n        var outerPadding = config.get('style.rangeOuterPadding');\n        this.scale = scale.domain(domain);\n        if (config.isOrdinal()) {\n          this.scale.rangeBands(range, padding, outerPadding);\n        } else {\n          this.scale.range(range);\n        }\n\n        if (this.canApplyNice()) this.scale.nice();\n        // Prevents bars from going off the chart when the y extents are within the domain range\n        if (this.scale.clamp) this.scale.clamp(true);\n\n        this.validateScale(this.scale);\n\n        return this.scale;\n      }\n    }, {\n      key: 'validateScale',\n      value: function validateScale(scale) {\n        if (!scale || _lodash2.default.isNaN(scale)) throw new Error('scale is ' + scale);\n      }\n    }]);\n\n    return AxisScale;\n  }();\n\n  return AxisScale;\n}",null]}