{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/index_patterns/_index_pattern.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/index_patterns/_index_pattern.js","mtime":1515552036000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.getRoutes = getRoutes;\nexports.IndexPatternProvider = IndexPatternProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _errors = require('ui/errors');\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _field_formats = require('ui/registry/field_formats');\n\nvar _mapping_setup = require('ui/utils/mapping_setup');\n\nvar _mapping_setup2 = _interopRequireDefault(_mapping_setup);\n\nvar _notify = require('ui/notify');\n\nvar _get_computed_fields = require('./_get_computed_fields');\n\nvar _format_hit = require('./_format_hit');\n\nvar _get = require('./_get');\n\nvar _intervals = require('./_intervals');\n\nvar _field_list = require('./_field_list');\n\nvar _flatten_hit = require('./_flatten_hit');\n\nvar _pattern_cache = require('./_pattern_cache');\n\nvar _fields_fetcher_provider = require('./fields_fetcher_provider');\n\nvar _unsupported_time_patterns = require('./unsupported_time_patterns');\n\nvar _saved_objects = require('ui/saved_objects');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getRoutes() {\n  return {\n    edit: '/management/kibana/indices/{{id}}',\n    addField: '/management/kibana/indices/{{id}}/create-field',\n    indexedFields: '/management/kibana/indices/{{id}}?_a=(tab:indexedFields)',\n    scriptedFields: '/management/kibana/indices/{{id}}?_a=(tab:scriptedFields)',\n    sourceFilters: '/management/kibana/indices/{{id}}?_a=(tab:sourceFilters)'\n  };\n}\n\nfunction IndexPatternProvider(Private, config, Promise, confirmModalPromise, kbnUrl) {\n  var fieldformats = Private(_field_formats.RegistryFieldFormatsProvider);\n  var getConfig = function getConfig() {\n    return config.get.apply(config, arguments);\n  };\n  var getIds = Private(_get.IndexPatternsGetProvider)('id');\n  var fieldsFetcher = Private(_fields_fetcher_provider.FieldsFetcherProvider);\n  var intervals = Private(_intervals.IndexPatternsIntervalsProvider);\n  var mappingSetup = Private(_mapping_setup2.default);\n  var FieldList = Private(_field_list.IndexPatternsFieldListProvider);\n  var flattenHit = Private(_flatten_hit.IndexPatternsFlattenHitProvider);\n  var patternCache = Private(_pattern_cache.IndexPatternsPatternCacheProvider);\n  var isUserAwareOfUnsupportedTimePattern = Private(_unsupported_time_patterns.IsUserAwareOfUnsupportedTimePatternProvider);\n  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n\n  var type = 'index-pattern';\n  var notify = new _notify.Notifier();\n  var configWatchers = new WeakMap();\n\n  var mapping = mappingSetup.expandShorthand({\n    title: 'text',\n    timeFieldName: 'keyword',\n    intervalName: 'keyword',\n    fields: 'json',\n    sourceFilters: 'json',\n    fieldFormatMap: {\n      type: 'text',\n      _serialize: function _serialize() {\n        var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var serialized = _lodash2.default.transform(map, serializeFieldFormatMap);\n        return _lodash2.default.isEmpty(serialized) ? undefined : _angular2.default.toJson(serialized);\n      },\n      _deserialize: function _deserialize() {\n        var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';\n\n        return _lodash2.default.mapValues(_angular2.default.fromJson(map), deserializeFieldFormatMap);\n      }\n    }\n  });\n\n  function serializeFieldFormatMap(flat, format, field) {\n    if (format) {\n      flat[field] = format;\n    }\n  }\n\n  function deserializeFieldFormatMap(mapping) {\n    var FieldFormat = fieldformats.byId[mapping.id];\n    return FieldFormat && new FieldFormat(mapping.params, getConfig);\n  }\n\n  function updateFromElasticSearch(indexPattern, response) {\n    if (!response.found) {\n      var markdownSaveId = indexPattern.id.replace('*', '%2A');\n\n      throw new _errors.SavedObjectNotFound(type, indexPattern.id, kbnUrl.eval('#/management/kibana/index?id={{id}}&name=', { id: markdownSaveId }));\n    }\n\n    _lodash2.default.forOwn(mapping, function (fieldMapping, name) {\n      if (!fieldMapping._deserialize) {\n        return;\n      }\n      response._source[name] = fieldMapping._deserialize(response._source[name]);\n    });\n\n    // give index pattern all of the values in _source\n    _lodash2.default.assign(indexPattern, response._source);\n\n    if (!indexPattern.title) {\n      indexPattern.title = indexPattern.id;\n    }\n\n    if (indexPattern.isUnsupportedTimePattern()) {\n      if (!isUserAwareOfUnsupportedTimePattern(indexPattern)) {\n        var warning = 'Support for time-intervals has been removed. ' + ('View the [\"' + indexPattern.title + '\" index pattern in management](') + kbnUrl.getRouteHref(indexPattern, 'edit') + ') for more information.';\n        notify.warning(warning, { lifetime: Infinity });\n      }\n    }\n\n    return indexFields(indexPattern);\n  }\n\n  function isFieldRefreshRequired(indexPattern) {\n    if (!indexPattern.fields) {\n      return true;\n    }\n\n    return indexPattern.fields.every(function (field) {\n      // See https://github.com/elastic/kibana/pull/8421\n      var hasFieldCaps = 'aggregatable' in field && 'searchable' in field;\n\n      // See https://github.com/elastic/kibana/pull/11969\n      var hasDocValuesFlag = 'readFromDocValues' in field;\n\n      return !hasFieldCaps || !hasDocValuesFlag;\n    });\n  }\n\n  function indexFields(indexPattern) {\n    var promise = Promise.resolve();\n\n    if (!indexPattern.id) {\n      return promise;\n    }\n\n    if (isFieldRefreshRequired(indexPattern)) {\n      promise = indexPattern.refreshFields();\n    }\n\n    return promise.then(function () {\n      initFields(indexPattern);\n    });\n  }\n\n  function setId(indexPattern, id) {\n    indexPattern.id = id;\n    return id;\n  }\n\n  function watch(indexPattern) {\n    if (configWatchers.has(indexPattern)) {\n      return;\n    }\n    var unwatch = config.watchAll(function () {\n      if (indexPattern.fields) {\n        initFields(indexPattern); // re-init fields when config changes, but only if we already had fields\n      }\n    });\n    configWatchers.set(indexPattern, { unwatch: unwatch });\n  }\n\n  function unwatch(indexPattern) {\n    if (!configWatchers.has(indexPattern)) {\n      return;\n    }\n    configWatchers.get(indexPattern).unwatch();\n    configWatchers.delete(indexPattern);\n  }\n\n  function initFields(indexPattern, input) {\n    var oldValue = indexPattern.fields;\n    var newValue = input || oldValue || [];\n    indexPattern.fields = new FieldList(indexPattern, newValue);\n  }\n\n  function fetchFields(indexPattern) {\n    return Promise.resolve().then(function () {\n      return fieldsFetcher.fetch(indexPattern);\n    }).then(function (fields) {\n      var scripted = indexPattern.getScriptedFields();\n      var all = fields.concat(scripted);\n      initFields(indexPattern, all);\n    });\n  }\n\n  var IndexPattern = function () {\n    function IndexPattern(id) {\n      _classCallCheck(this, IndexPattern);\n\n      setId(this, id);\n      this.metaFields = config.get('metaFields');\n      this.getComputedFields = _get_computed_fields.getComputedFields.bind(this);\n\n      this.flattenHit = flattenHit(this);\n      this.formatHit = (0, _format_hit.formatHit)(this, fieldformats.getDefaultInstance('string'));\n      this.formatField = this.formatHit.formatField;\n    }\n\n    _createClass(IndexPattern, [{\n      key: 'init',\n      value: function init() {\n        var _this = this;\n\n        watch(this);\n\n        if (!this.id) {\n          return Promise.resolve(this); // no id === no elasticsearch document\n        }\n\n        return savedObjectsClient.get(type, this.id).then(function (resp) {\n          // temporary compatability for savedObjectsClient\n\n          return {\n            _id: resp.id,\n            _type: resp.type,\n            _source: _lodash2.default.cloneDeep(resp.attributes),\n            found: resp._version ? true : false\n          };\n        }).then(function (response) {\n          return updateFromElasticSearch(_this, response);\n        }).then(function () {\n          return _this;\n        });\n      }\n\n      // Get the source filtering configuration for that index.\n\n    }, {\n      key: 'getSourceFiltering',\n      value: function getSourceFiltering() {\n        return {\n          excludes: this.sourceFilters && this.sourceFilters.map(function (filter) {\n            return filter.value;\n          }) || []\n        };\n      }\n    }, {\n      key: 'addScriptedField',\n      value: function addScriptedField(name, script) {\n        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'string';\n        var lang = arguments[3];\n\n        var scriptedFields = this.getScriptedFields();\n        var names = _lodash2.default.pluck(scriptedFields, 'name');\n\n        if (_lodash2.default.contains(names, name)) {\n          throw new _errors.DuplicateField(name);\n        }\n\n        this.fields.push({\n          name: name,\n          script: script,\n          type: type,\n          scripted: true,\n          lang: lang\n        });\n\n        this.save();\n      }\n    }, {\n      key: 'removeScriptedField',\n      value: function removeScriptedField(name) {\n        var fieldIndex = _lodash2.default.findIndex(this.fields, {\n          name: name,\n          scripted: true\n        });\n        this.fields.splice(fieldIndex, 1);\n        this.save();\n      }\n    }, {\n      key: 'popularizeField',\n      value: function popularizeField(fieldName) {\n        var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n        var field = _lodash2.default.get(this, ['fields', 'byName', fieldName]);\n        if (!field) {\n          return;\n        }\n        var count = Math.max((field.count || 0) + unit, 0);\n        if (field.count === count) {\n          return;\n        }\n        field.count = count;\n        this.save();\n      }\n    }, {\n      key: 'getNonScriptedFields',\n      value: function getNonScriptedFields() {\n        return _lodash2.default.where(this.fields, { scripted: false });\n      }\n    }, {\n      key: 'getScriptedFields',\n      value: function getScriptedFields() {\n        return _lodash2.default.where(this.fields, { scripted: true });\n      }\n    }, {\n      key: 'getInterval',\n      value: function getInterval() {\n        return this.intervalName && _lodash2.default.find(intervals, { name: this.intervalName });\n      }\n    }, {\n      key: 'toIndexList',\n      value: function toIndexList(start, stop, sortDirection) {\n        return this.toDetailedIndexList(start, stop, sortDirection).then(function (detailedIndices) {\n          if (!Array.isArray(detailedIndices)) {\n            return detailedIndices.index;\n          }\n          return _lodash2.default.pluck(detailedIndices, 'index');\n        });\n      }\n    }, {\n      key: 'toDetailedIndexList',\n      value: function toDetailedIndexList(start, stop, sortDirection) {\n        var _this2 = this;\n\n        return Promise.resolve().then(function () {\n          if (_this2.isTimeBasedInterval()) {\n            return intervals.toIndexList(_this2.title, _this2.getInterval(), start, stop, sortDirection);\n          }\n\n          return [{\n            index: _this2.title,\n            min: -Infinity,\n            max: Infinity\n          }];\n        });\n      }\n    }, {\n      key: 'isTimeBased',\n      value: function isTimeBased() {\n        return !!this.timeFieldName && (!this.fields || !!this.getTimeField());\n      }\n    }, {\n      key: 'isTimeBasedInterval',\n      value: function isTimeBasedInterval() {\n        return this.isTimeBased() && !!this.getInterval();\n      }\n    }, {\n      key: 'isUnsupportedTimePattern',\n      value: function isUnsupportedTimePattern() {\n        return !!this.intervalName;\n      }\n    }, {\n      key: 'isTimeBasedWildcard',\n      value: function isTimeBasedWildcard() {\n        return this.isTimeBased() && this.isWildcard();\n      }\n    }, {\n      key: 'getTimeField',\n      value: function getTimeField() {\n        if (!this.timeFieldName || !this.fields || !this.fields.byName) return;\n        return this.fields.byName[this.timeFieldName];\n      }\n    }, {\n      key: 'isWildcard',\n      value: function isWildcard() {\n        return _lodash2.default.includes(this.title, '*');\n      }\n    }, {\n      key: 'prepBody',\n      value: function prepBody() {\n        var _this3 = this;\n\n        var body = {};\n\n        // serialize json fields\n        _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {\n          if (_this3[fieldName] != null) {\n            body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this3[fieldName]) : _this3[fieldName];\n          }\n        });\n\n        // clear the indexPattern list cache\n        getIds.clearCache();\n        return body;\n      }\n\n      /**\n       * Returns a promise that resolves to true if either the title is unique, or if the user confirmed they\n       * wished to save the duplicate title.  Promise is rejected if the user rejects the confirmation.\n       */\n\n    }, {\n      key: 'warnIfDuplicateTitle',\n      value: function warnIfDuplicateTitle() {\n        var _this4 = this;\n\n        return (0, _saved_objects.findObjectByTitle)(savedObjectsClient, type, this.title).then(function (duplicate) {\n          if (!duplicate) return false;\n          if (duplicate.id === _this4.id) return false;\n\n          var confirmMessage = 'An index pattern with the title \\'' + _this4.title + '\\' already exists.';\n\n          return confirmModalPromise(confirmMessage, { confirmButtonText: 'Go to existing pattern' }).then(function () {\n            kbnUrl.redirect('/management/kibana/indices/{{id}}', { id: duplicate.id });\n            return true;\n          }).catch(function () {\n            return true;\n          });\n        });\n      }\n    }, {\n      key: 'create',\n      value: function create() {\n        var _this5 = this;\n\n        return this.warnIfDuplicateTitle().then(function (isDuplicate) {\n          if (isDuplicate) return;\n\n          var body = _this5.prepBody();\n\n          return savedObjectsClient.create(type, body, { id: _this5.id }).then(function (response) {\n            return setId(_this5, response.id);\n          }).catch(function (err) {\n            if (err.statusCode !== 409) {\n              return Promise.resolve(false);\n            }\n            var confirmMessage = 'Are you sure you want to overwrite this?';\n\n            return confirmModalPromise(confirmMessage, { confirmButtonText: 'Overwrite' }).then(function () {\n              return Promise.try(function () {\n                var cached = patternCache.get(_this5.id);\n                if (cached) {\n                  return cached.then(function (pattern) {\n                    return pattern.destroy();\n                  });\n                }\n              }).then(function () {\n                return savedObjectsClient.create(type, body, { id: _this5.id, overwrite: true });\n              }).then(function (response) {\n                return setId(_this5, response.id);\n              });\n            }, _lodash2.default.constant(false) // if the user doesn't overwrite, resolve with false\n            );\n          });\n        });\n      }\n    }, {\n      key: 'save',\n      value: function save() {\n        var _this6 = this;\n\n        return savedObjectsClient.update(type, this.id, this.prepBody()).then(function (_ref) {\n          var id = _ref.id;\n          return setId(_this6, id);\n        });\n      }\n    }, {\n      key: 'refreshFields',\n      value: function refreshFields() {\n        var _this7 = this;\n\n        return fetchFields(this).then(function () {\n          return _this7.save();\n        }).catch(function (err) {\n          notify.error(err);\n          // https://github.com/elastic/kibana/issues/9224\n          // This call will attempt to remap fields from the matching\n          // ES index which may not actually exist. In that scenario,\n          // we still want to notify the user that there is a problem\n          // but we do not want to potentially make any pages unusable\n          // so do not rethrow the error here\n          if (err instanceof _errors.IndexPatternMissingIndices) {\n            return [];\n          }\n\n          throw err;\n        });\n      }\n    }, {\n      key: 'toJSON',\n      value: function toJSON() {\n        return this.id;\n      }\n    }, {\n      key: 'toString',\n      value: function toString() {\n        return '' + this.toJSON();\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        unwatch(this);\n        patternCache.clear(this.id);\n        return savedObjectsClient.delete(type, this.id);\n      }\n    }, {\n      key: 'routes',\n      get: function get() {\n        return getRoutes();\n      }\n    }]);\n\n    return IndexPattern;\n  }();\n\n  return IndexPattern;\n}",null]}