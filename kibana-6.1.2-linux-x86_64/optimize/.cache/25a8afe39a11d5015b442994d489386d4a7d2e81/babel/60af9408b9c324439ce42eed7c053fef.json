{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/saved_object/saved_object.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/saved_object/saved_object.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SavedObjectProvider = SavedObjectProvider;\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _errors = require('ui/errors');\n\nvar _mapping_setup = require('ui/utils/mapping_setup');\n\nvar _mapping_setup2 = _interopRequireDefault(_mapping_setup);\n\nvar _search_source = require('../data_source/search_source');\n\nvar _saved_objects = require('ui/saved_objects');\n\nvar _migrateLegacyQuery = require('../../utils/migrateLegacyQuery.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * An error message to be used when the user rejects a confirm overwrite.\n * @type {string}\n */\nvar OVERWRITE_REJECTED = 'Overwrite confirmation was rejected';\n\n/**\n * An error message to be used when the user rejects a confirm save with duplicate title.\n * @type {string}\n */\n/**\n * @name SavedObject\n *\n * NOTE: SavedObject seems to track a reference to an object in ES,\n * and surface methods for CRUD functionality (save and delete). This seems\n * similar to how Backbone Models work.\n *\n * This class seems to interface with ES primarily through the es Angular\n * service and the saved object api.\n */\n\nvar SAVE_DUPLICATE_REJECTED = 'Save with duplicate title confirmation was rejected';\n\n/**\n * @param error {Error} the error\n * @return {boolean}\n */\nfunction isErrorNonFatal(error) {\n  if (!error) return false;\n  return error.message === OVERWRITE_REJECTED || error.message === SAVE_DUPLICATE_REJECTED;\n}\n\nfunction SavedObjectProvider(Promise, Private, Notifier, confirmModalPromise, indexPatterns) {\n  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n  var SearchSource = Private(_search_source.SearchSourceProvider);\n  var mappingSetup = Private(_mapping_setup2.default);\n\n  function SavedObject(config) {\n    var _this = this;\n\n    if (!_lodash2.default.isObject(config)) config = {};\n\n    /************\n     * Initialize config vars\n     ************/\n\n    // type name for this object, used as the ES-type\n    var esType = config.type;\n\n    this.getDisplayName = function () {\n      return esType;\n    };\n\n    // NOTE: this.type (not set in this file, but somewhere else) is the sub type, e.g. 'area' or\n    // 'data table', while esType is the more generic type - e.g. 'visualization' or 'saved search'.\n    this.getEsType = function () {\n      return esType;\n    };\n\n    /**\n     * Flips to true during a save operation, and back to false once the save operation\n     * completes.\n     * @type {boolean}\n     */\n    this.isSaving = false;\n    this.defaults = config.defaults || {};\n\n    // mapping definition for the fields that this object will expose\n    var mapping = mappingSetup.expandShorthand(config.mapping);\n\n    var afterESResp = config.afterESResp || _lodash2.default.noop;\n    var customInit = config.init || _lodash2.default.noop;\n\n    // optional search source which this object configures\n    this.searchSource = config.searchSource ? new SearchSource() : undefined;\n\n    // the id of the document\n    this.id = config.id || void 0;\n\n    // Whether to create a copy when the object is saved. This should eventually go away\n    // in favor of a better rename/save flow.\n    this.copyOnSave = false;\n\n    var parseSearchSource = function parseSearchSource(searchSourceJson) {\n      if (!_this.searchSource) return;\n\n      // if we have a searchSource, set its state based on the searchSourceJSON field\n      var state = void 0;\n      try {\n        state = JSON.parse(searchSourceJson);\n      } catch (e) {\n        state = {};\n      }\n\n      var oldState = _this.searchSource.toJSON();\n      var fnProps = _lodash2.default.transform(oldState, function (dynamic, val, name) {\n        if (_lodash2.default.isFunction(val)) dynamic[name] = val;\n      }, {});\n\n      _this.searchSource.set(_lodash2.default.defaults(state, fnProps));\n\n      if (!_lodash2.default.isUndefined(_this.searchSource.getOwn('query'))) {\n        _this.searchSource.set('query', (0, _migrateLegacyQuery.migrateLegacyQuery)(_this.searchSource.getOwn('query')));\n      }\n    };\n\n    /**\n     * After creation or fetching from ES, ensure that the searchSources index indexPattern\n     * is an bonafide IndexPattern object.\n     *\n     * @return {Promise<IndexPattern | null>}\n     */\n    this.hydrateIndexPattern = function (id) {\n      if (!_this.searchSource) {\n        return Promise.resolve(null);\n      }\n\n      if (config.clearSavedIndexPattern) {\n        _this.searchSource.set('index', undefined);\n        return Promise.resolve(null);\n      }\n\n      var index = id || config.indexPattern || _this.searchSource.getOwn('index');\n\n      if (!index) {\n        return Promise.resolve(null);\n      }\n\n      // If index is not an IndexPattern object at this point, then it's a string id of an index.\n      if (!(index instanceof indexPatterns.IndexPattern)) {\n        index = indexPatterns.get(index);\n      }\n\n      // At this point index will either be an IndexPattern, if cached, or a promise that\n      // will return an IndexPattern, if not cached.\n      return Promise.resolve(index).then(function (indexPattern) {\n        _this.searchSource.set('index', indexPattern);\n      });\n    };\n\n    /**\n     * Asynchronously initialize this object - will only run\n     * once even if called multiple times.\n     *\n     * @return {Promise}\n     * @resolved {SavedObject}\n     */\n    this.init = _lodash2.default.once(function () {\n      // ensure that the esType is defined\n      if (!esType) throw new Error('You must define a type name to use SavedObject objects.');\n\n      return Promise.resolve().then(function () {\n        // If there is not id, then there is no document to fetch from elasticsearch\n        if (!_this.id) {\n          // just assign the defaults and be done\n          _lodash2.default.assign(_this, _this.defaults);\n          return _this.hydrateIndexPattern().then(function () {\n            return afterESResp.call(_this);\n          });\n        }\n\n        // fetch the object from ES\n        return savedObjectsClient.get(esType, _this.id).then(function (resp) {\n          // temporary compatability for savedObjectsClient\n\n          return {\n            _id: resp.id,\n            _type: resp.type,\n            _source: _lodash2.default.cloneDeep(resp.attributes),\n            found: resp._version ? true : false\n          };\n        }).then(_this.applyESResp).catch(_this.applyEsResp);\n      }).then(function () {\n        return customInit.call(_this);\n      }).then(function () {\n        return _this;\n      });\n    });\n\n    this.applyESResp = function (resp) {\n      _this._source = _lodash2.default.cloneDeep(resp._source);\n\n      if (resp.found != null && !resp.found) throw new _errors.SavedObjectNotFound(esType, _this.id);\n\n      var meta = resp._source.kibanaSavedObjectMeta || {};\n      delete resp._source.kibanaSavedObjectMeta;\n\n      if (!config.indexPattern && _this._source.indexPattern) {\n        config.indexPattern = _this._source.indexPattern;\n        delete _this._source.indexPattern;\n      }\n\n      // assign the defaults to the response\n      _lodash2.default.defaults(_this._source, _this.defaults);\n\n      // transform the source using _deserializers\n      _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {\n        if (fieldMapping._deserialize) {\n          _this._source[fieldName] = fieldMapping._deserialize(_this._source[fieldName], resp, fieldName, fieldMapping);\n        }\n      });\n\n      // Give obj all of the values in _source.fields\n      _lodash2.default.assign(_this, _this._source);\n      _this.lastSavedTitle = _this.title;\n\n      return Promise.try(function () {\n        parseSearchSource(meta.searchSourceJSON);\n        return _this.hydrateIndexPattern();\n      }).then(function () {\n        return Promise.cast(afterESResp.call(_this, resp));\n      });\n    };\n\n    /**\n     * Serialize this object\n     *\n     * @return {Object}\n     */\n    this.serialize = function () {\n      var body = {};\n\n      _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {\n        if (_this[fieldName] != null) {\n          body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this[fieldName]) : _this[fieldName];\n        }\n      });\n\n      if (_this.searchSource) {\n        body.kibanaSavedObjectMeta = {\n          searchSourceJSON: _angular2.default.toJson(_lodash2.default.omit(_this.searchSource.toJSON(), ['sort', 'size']))\n        };\n      }\n\n      return body;\n    };\n\n    /**\n     * Returns true if the object's original title has been changed. New objects return false.\n     * @return {boolean}\n     */\n    this.isTitleChanged = function () {\n      return _this._source && _this._source.title !== _this.title;\n    };\n\n    /**\n     * Attempts to create the current object using the serialized source. If an object already\n     * exists, a warning message requests an overwrite confirmation.\n     * @param source - serialized version of this object (return value from this.serialize())\n     * What will be indexed into elasticsearch.\n     * @returns {Promise} - A promise that is resolved with the objects id if the object is\n     * successfully indexed. If the overwrite confirmation was rejected, an error is thrown with\n     * a confirmRejected = true parameter so that case can be handled differently than\n     * a create or index error.\n     * @resolved {SavedObject}\n     */\n    var createSource = function createSource(source) {\n      return savedObjectsClient.create(esType, source, { id: _this.id }).catch(function (err) {\n        // record exists, confirm overwriting\n        if (_lodash2.default.get(err, 'statusCode') === 409) {\n          var confirmMessage = 'Are you sure you want to overwrite ' + _this.title + '?';\n\n          return confirmModalPromise(confirmMessage, { confirmButtonText: 'Overwrite ' + _this.getDisplayName() }).then(function () {\n            return savedObjectsClient.create(esType, source, { id: _this.id, overwrite: true });\n          }).catch(function () {\n            return Promise.reject(new Error(OVERWRITE_REJECTED));\n          });\n        }\n        return Promise.reject(err);\n      });\n    };\n\n    /**\n     * Returns a promise that resolves to true if either the title is unique, or if the user confirmed they\n     * wished to save the duplicate title.  Promise is rejected if the user rejects the confirmation.\n     */\n    var warnIfDuplicateTitle = function warnIfDuplicateTitle() {\n      // Don't warn if the user isn't updating the title, otherwise that would become very annoying to have\n      // to confirm the save every time, except when copyOnSave is true, then we do want to check.\n      if (_this.title === _this.lastSavedTitle && !_this.copyOnSave) {\n        return Promise.resolve();\n      }\n\n      return (0, _saved_objects.findObjectByTitle)(savedObjectsClient, _this.getEsType(), _this.title).then(function (duplicate) {\n        if (!duplicate) return true;\n        if (duplicate.id === _this.id) return true;\n\n        var confirmMessage = 'A ' + _this.getDisplayName() + ' with the title \\'' + _this.title + '\\' already exists. Would you like to save anyway?';\n\n        return confirmModalPromise(confirmMessage, { confirmButtonText: 'Save ' + _this.getDisplayName() }).catch(function () {\n          return Promise.reject(new Error(SAVE_DUPLICATE_REJECTED));\n        });\n      });\n    };\n\n    /**\n     * Saves this object.\n     *\n     * @param {object} [options={}]\n     * @property {boolean} [options.confirmOverwrite=false] - If true, attempts to create the source so it\n     * can confirm an overwrite if a document with the id already exists.\n     * @return {Promise}\n     * @resolved {String} - The id of the doc\n     */\n    this.save = function () {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          confirmOverwrite = _ref.confirmOverwrite;\n\n      // Save the original id in case the save fails.\n      var originalId = _this.id;\n      // Read https://github.com/elastic/kibana/issues/9056 and\n      // https://github.com/elastic/kibana/issues/9012 for some background into why this copyOnSave variable\n      // exists.\n      // The goal is to move towards a better rename flow, but since our users have been conditioned\n      // to expect a 'save as' flow during a rename, we are keeping the logic the same until a better\n      // UI/UX can be worked out.\n      if (_this.copyOnSave) {\n        _this.id = null;\n      }\n\n      var source = _this.serialize();\n\n      _this.isSaving = true;\n\n      return warnIfDuplicateTitle().then(function () {\n        if (confirmOverwrite) {\n          return createSource(source);\n        } else {\n          return savedObjectsClient.create(esType, source, { id: _this.id, overwrite: true });\n        }\n      }).then(function (resp) {\n        _this.id = resp.id;\n      }).then(function () {\n        _this.isSaving = false;\n        _this.lastSavedTitle = _this.title;\n        return _this.id;\n      }).catch(function (err) {\n        _this.isSaving = false;\n        _this.id = originalId;\n        if (isErrorNonFatal(err)) {\n          return;\n        }\n        return Promise.reject(err);\n      });\n    };\n\n    this.destroy = function () {\n      if (_this.searchSource) {\n        _this.searchSource.cancelQueued();\n      }\n    };\n\n    /**\n     * Delete this object from Elasticsearch\n     * @return {promise}\n     */\n    this.delete = function () {\n      return savedObjectsClient.delete(esType, _this.id);\n    };\n  }\n\n  return SavedObject;\n}",null]}