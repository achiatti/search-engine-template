{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/indexed_array/indexed_array.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/indexed_array/indexed_array.js","mtime":1515552036000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexedArray = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _inflector = require('./inflector');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar pathGetter = (0, _lodash2.default)(_lodash2.default.get).rearg(1, 0).ary(2);\nvar inflectIndex = (0, _inflector.inflector)('by');\nvar inflectOrder = (0, _inflector.inflector)('in', 'Order');\n\nvar CLEAR_CACHE = {};\nvar OPT_NAMES = ['index', 'group', 'order', 'initialSet', 'immutable'];\n\n/**\n *  Generic extension of Array class, which will index (and reindex) the\n *  objects it contains based on their properties.\n *\n *  @param {Object} config describes the properties of this registry object\n *  @param {Array<string>} [config.index] a list of props/paths that should be used to index the docs.\n *  @param {Array<string>} [config.group] a list of keys/paths to group docs by.\n *  @param {Array<string>} [config.order] a list of keys/paths to order the keys by.\n *  @param {Array<any>} [config.initialSet] the initial dataset the IndexedArray should contain.\n *  @param {boolean} [config.immutable] a flag that hints to people reading the implementation that this IndexedArray\n *                                      should not be modified\n */\n\nvar IndexedArray = exports.IndexedArray = function () {\n  function IndexedArray(config) {\n    _classCallCheck(this, IndexedArray);\n\n    config = _lodash2.default.pick(config || {}, OPT_NAMES);\n\n    // use defineProperty so that value can't be changed\n    Object.defineProperty(this, 'raw', { value: [] });\n\n    this._indexNames = _lodash2.default.union(this._setupIndex(config.group, inflectIndex, _lodash2.default.organizeBy), this._setupIndex(config.index, inflectIndex, _lodash2.default.indexBy), this._setupIndex(config.order, inflectOrder, function (raw, pluckValue) {\n      return [].concat(_toConsumableArray(raw)).sort(function (itemA, itemB) {\n        var a = String(pluckValue(itemA));\n        var b = String(pluckValue(itemB));\n        return a.toLowerCase().localeCompare(b.toLowerCase());\n      });\n    }));\n\n    if (config.initialSet) {\n      this.push.apply(this, config.initialSet);\n    }\n\n    Object.defineProperty(this, 'immutable', { value: !!config.immutable });\n  }\n\n  /**\n   * Remove items from this based on a predicate\n   * @param {Function|Object|string} predicate - the predicate used to decide what is removed\n   * @return {array} - the removed data\n   */\n\n\n  _createClass(IndexedArray, [{\n    key: 'remove',\n    value: function remove(predicate) {\n      this._assertMutable('remove');\n      var out = _lodash2.default.remove(this, predicate);\n      _lodash2.default.remove(this.raw, predicate);\n      this._clearIndices();\n      return out;\n    }\n\n    /**\n     * provide a hook for the JSON serializer\n     * @return {array} - a plain, vanilla array with our same data\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.raw;\n    }\n\n    // wrappers for mutable Array methods\n\n  }, {\n    key: 'copyWithin',\n    value: function copyWithin() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this._mutation('copyWithin', args);\n    }\n  }, {\n    key: 'fill',\n    value: function fill() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this._mutation('fill', args);\n    }\n  }, {\n    key: 'pop',\n    value: function pop() {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this._mutation('pop', args);\n    }\n  }, {\n    key: 'push',\n    value: function push() {\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return this._mutation('push', args);\n    }\n  }, {\n    key: 'reverse',\n    value: function reverse() {\n      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return this._mutation('reverse', args);\n    }\n  }, {\n    key: 'shift',\n    value: function shift() {\n      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return this._mutation('shift', args);\n    }\n  }, {\n    key: 'sort',\n    value: function sort() {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return this._mutation('sort', args);\n    }\n  }, {\n    key: 'splice',\n    value: function splice() {\n      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      return this._mutation('splice', args);\n    }\n  }, {\n    key: 'unshift',\n    value: function unshift() {\n      for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n\n      return this._mutation('unshift', args);\n    }\n\n    /**\n     *  If this instance of IndexedArray is not mutable, throw an error\n     *  @private\n     *  @param  {String} methodName - user facing method name, for error message\n     *  @return {undefined}\n     */\n\n  }, {\n    key: '_assertMutable',\n    value: function _assertMutable(methodName) {\n      if (this.immutable) {\n        throw new Error(methodName + '() is not allowed on immutable IndexedArray instances');\n      }\n    }\n\n    /**\n     *  Execute some mutable method from the Array prototype\n     *  on the IndexedArray and this.raw\n     *\n     *  @private\n     *  @param  {string} methodName\n     *  @param  {Array<any>} args\n     *  @return {any}\n     */\n\n  }, {\n    key: '_mutation',\n    value: function _mutation(methodName, args) {\n      this._assertMutable(methodName);\n      _get(IndexedArray.prototype.__proto__ || Object.getPrototypeOf(IndexedArray.prototype), methodName, this).apply(this, args);\n      this._clearIndices();\n      return _get(IndexedArray.prototype.__proto__ || Object.getPrototypeOf(IndexedArray.prototype), methodName, this).apply(this.raw, args);\n    }\n\n    /**\n     * Create indices for a group of object properties. getters and setters are used to\n     * read and control the indices.\n     * @private\n     * @param  {string[]} props   - the properties that should be used to index docs\n     * @param  {function} inflect - a function that will be called with a property name, and\n     *                            creates the public property at which the index will be exposed\n     * @param  {function} op      - the function that will be used to create the indices, it is passed\n     *                            the raw representaion of the registry, and a getter for reading the\n     *                            right prop\n     *\n     * @returns {string[]}        - the public keys of all indices created\n     */\n\n  }, {\n    key: '_setupIndex',\n    value: function _setupIndex(props, inflect, op) {\n      var _this = this;\n\n      // shortcut for empty props\n      if (!props || props.length === 0) return;\n\n      return props.map(function (prop) {\n        var indexName = inflect(prop);\n        var getIndexValueFromItem = pathGetter.partial(prop).value();\n        var cache = void 0;\n\n        Object.defineProperty(_this, indexName, {\n          enumerable: false,\n          configurable: false,\n\n          set: function set(val) {\n            // can't set any value other than the CLEAR_CACHE constant\n            if (val === CLEAR_CACHE) {\n              cache = false;\n            } else {\n              throw new TypeError(indexName + ' can not be set, it is a computed index of values');\n            }\n          },\n          get: function get() {\n            if (!cache) {\n              cache = op(_this.raw, getIndexValueFromItem);\n            }\n\n            return cache;\n          }\n        });\n\n        return indexName;\n      });\n    }\n\n    /**\n     * Clear cached index/group/order caches so they will be recreated\n     * on next access\n     * @private\n     * @return {undefined}\n     */\n\n  }, {\n    key: '_clearIndices',\n    value: function _clearIndices() {\n      var _this2 = this;\n\n      this._indexNames.forEach(function (name) {\n        _this2[name] = CLEAR_CACHE;\n      });\n    }\n  }]);\n\n  return IndexedArray;\n}();\n\n// using traditional `extends Array` syntax doesn't work with babel\n// See https://babeljs.io/docs/usage/caveats/\n\n\nIndexedArray.OPT_NAMES = OPT_NAMES;\nObject.setPrototypeOf(IndexedArray.prototype, Array.prototype);",null]}