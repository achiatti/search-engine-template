{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/tile_map/public/kibana_map.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/tile_map/public/kibana_map.js","mtime":1515552031000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KibanaMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = require('events');\n\nvar _leaflet = require('leaflet');\n\nvar _leaflet2 = _interopRequireDefault(_leaflet);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _zoom_to_precision = require('ui/utils/zoom_to_precision');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction makeFitControl(fitContainer, kibanaMap) {\n\n  var FitControl = _leaflet2.default.Control.extend({\n    options: {\n      position: 'topleft'\n    },\n    initialize: function initialize(fitContainer, kibanaMap) {\n      this._fitContainer = fitContainer;\n      this._kibanaMap = kibanaMap;\n      this._leafletMap = null;\n    },\n    onAdd: function onAdd(leafletMap) {\n      var _this = this;\n\n      this._leafletMap = leafletMap;\n      (0, _jquery2.default)(this._fitContainer).html('<a class=\"kuiIcon fa-crop\" href=\"#\" aria-label=\"Fit Data Bounds\"></a>').on('click', function (e) {\n        e.preventDefault();\n        _this._kibanaMap.fitToData();\n      });\n\n      return this._fitContainer;\n    },\n    onRemove: function onRemove() {\n      (0, _jquery2.default)(this._fitContainer).off('click');\n    }\n  });\n\n  return new FitControl(fitContainer, kibanaMap);\n}\n\nfunction makeLegedControl(container, kibanaMap, position) {\n\n  var LegendControl = _leaflet2.default.Control.extend({\n\n    options: {\n      position: 'topright'\n    },\n\n    initialize: function initialize(container, kibanaMap, position) {\n      this._legendContainer = container;\n      this._kibanaMap = kibanaMap;\n      this.options.position = position;\n    },\n\n    updateContents: function updateContents() {\n      this._legendContainer.empty();\n      var $div = (0, _jquery2.default)('<div>').addClass('tilemap-legend');\n      this._legendContainer.append($div);\n      var layers = this._kibanaMap.getLayers();\n      layers.forEach(function (layer) {\n        return layer.appendLegendContents($div);\n      });\n    },\n\n\n    onAdd: function onAdd() {\n      var _this2 = this;\n\n      this._layerUpdateHandle = function () {\n        return _this2.updateContents();\n      };\n      this._kibanaMap.on('layers:update', this._layerUpdateHandle);\n      this.updateContents();\n      return this._legendContainer.get(0);\n    },\n    onRemove: function onRemove() {\n      this._kibanaMap.removeListener('layers:update', this._layerUpdateHandle);\n      this._legendContainer.empty();\n    }\n\n  });\n\n  return new LegendControl(container, kibanaMap, position);\n}\n\n/**\n * Collects map functionality required for Kibana.\n * Serves as simple abstraction for leaflet as well.\n */\n\nvar KibanaMap = exports.KibanaMap = function (_EventEmitter) {\n  _inherits(KibanaMap, _EventEmitter);\n\n  function KibanaMap(containerNode, options) {\n    _classCallCheck(this, KibanaMap);\n\n    var _this3 = _possibleConstructorReturn(this, (KibanaMap.__proto__ || Object.getPrototypeOf(KibanaMap)).call(this));\n\n    _this3._containerNode = containerNode;\n    _this3._leafletBaseLayer = null;\n    _this3._baseLayerSettings = null;\n    _this3._baseLayerIsDesaturated = true;\n\n    _this3._leafletDrawControl = null;\n    _this3._leafletFitControl = null;\n    _this3._leafletLegendControl = null;\n    _this3._legendPosition = 'topright';\n\n    _this3._layers = [];\n    _this3._listeners = [];\n    _this3._showTooltip = false;\n\n    var leafletOptions = {\n      minZoom: options.minZoom,\n      maxZoom: options.maxZoom,\n      center: options.center ? options.center : [0, 0],\n      zoom: options.zoom ? options.zoom : 2,\n      renderer: _leaflet2.default.canvas(),\n      zoomAnimation: false // Desaturate map tiles causes animation rendering artifacts\n    };\n\n    _this3._leafletMap = _leaflet2.default.map(containerNode, leafletOptions);\n    _this3._leafletMap.attributionControl.setPrefix('');\n    _this3._leafletMap.scrollWheelZoom.disable();\n\n    var previousZoom = _this3._leafletMap.getZoom();\n    _this3._leafletMap.on('zoomend', function () {\n      if (previousZoom !== _this3._leafletMap.getZoom()) {\n        previousZoom = _this3._leafletMap.getZoom();\n        _this3.emit('zoomchange');\n      }\n    });\n    _this3._leafletMap.on('zoomend', function () {\n      return _this3.emit('zoomend');\n    });\n    _this3._leafletMap.on('dragend', function () {\n      return _this3.emit('dragend');\n    });\n\n    _this3._leafletMap.on('zoomend', function () {\n      return _this3._updateExtent();\n    });\n    _this3._leafletMap.on('dragend', function () {\n      return _this3._updateExtent();\n    });\n\n    _this3._leafletMap.on('mousemove', function (e) {\n      return _this3._layers.forEach(function (layer) {\n        return layer.movePointer('mousemove', e);\n      });\n    });\n    _this3._leafletMap.on('mouseout', function (e) {\n      return _this3._layers.forEach(function (layer) {\n        return layer.movePointer('mouseout', e);\n      });\n    });\n    _this3._leafletMap.on('mousedown', function (e) {\n      return _this3._layers.forEach(function (layer) {\n        return layer.movePointer('mousedown', e);\n      });\n    });\n    _this3._leafletMap.on('mouseup', function (e) {\n      return _this3._layers.forEach(function (layer) {\n        return layer.movePointer('mouseup', e);\n      });\n    });\n    _this3._leafletMap.on('draw:created', function (event) {\n      var drawType = event.layerType;\n      if (drawType === 'rectangle') {\n        var bounds = event.layer.getBounds();\n\n        var southEast = bounds.getSouthEast();\n        var northWest = bounds.getNorthWest();\n        var southEastLng = southEast.lng;\n        if (southEastLng > 180) {\n          southEastLng -= 360;\n        }\n        var northWestLng = northWest.lng;\n        if (northWestLng < -180) {\n          northWestLng += 360;\n        }\n\n        var southEastLat = southEast.lat;\n        var northWestLat = northWest.lat;\n\n        //Bounds cannot be created unless they form a box with larger than 0 dimensions\n        //Invalid areas are rejected by ES.\n        if (southEastLat === northWestLat || southEastLng === northWestLng) {\n          return;\n        }\n\n        _this3.emit('drawCreated:rectangle', {\n          bounds: {\n            bottom_right: {\n              lat: southEastLat,\n              lon: southEastLng\n            },\n            top_left: {\n              lat: northWestLat,\n              lon: northWestLng\n            }\n          }\n        });\n      } else if (drawType === 'polygon') {\n        var latLongs = event.layer.getLatLngs()[0];\n        _this3.emit('drawCreated:polygon', {\n          points: latLongs.map(function (leafletLatLng) {\n            return {\n              lat: leafletLatLng.lat,\n              lon: leafletLatLng.lng\n            };\n          })\n        });\n      }\n    });\n\n    _this3.resize();\n    return _this3;\n  }\n\n  _createClass(KibanaMap, [{\n    key: 'setShowTooltip',\n    value: function setShowTooltip(showTooltip) {\n      this._showTooltip = showTooltip;\n    }\n  }, {\n    key: 'getLayers',\n    value: function getLayers() {\n      return this._layers.slice();\n    }\n  }, {\n    key: 'addLayer',\n    value: function addLayer(kibanaLayer) {\n      var _this4 = this;\n\n      var onshowTooltip = function onshowTooltip(event) {\n\n        if (!_this4._showTooltip) {\n          return;\n        }\n\n        if (!_this4._popup) {\n          _this4._popup = _leaflet2.default.responsivePopup({ autoPan: false });\n          _this4._popup.setLatLng(event.position);\n          _this4._popup.setContent(event.content);\n          _this4._popup.openOn(_this4._leafletMap);\n        } else {\n          if (!_this4._popup.getLatLng().equals(event.position)) {\n            _this4._popup.setLatLng(event.position);\n          }\n          if (_this4._popup.getContent() !== event.content) {\n            _this4._popup.setContent(event.content);\n          }\n        }\n      };\n\n      kibanaLayer.on('showTooltip', onshowTooltip);\n      this._listeners.push({ name: 'showTooltip', handle: onshowTooltip, layer: kibanaLayer });\n\n      var onHideTooltip = function onHideTooltip() {\n        _this4._leafletMap.closePopup();\n        _this4._popup = null;\n      };\n      kibanaLayer.on('hideTooltip', onHideTooltip);\n      this._listeners.push({ name: 'hideTooltip', handle: onHideTooltip, layer: kibanaLayer });\n\n      var onStyleChanged = function onStyleChanged() {\n        if (_this4._leafletLegendControl) {\n          _this4._leafletLegendControl.updateContents();\n        }\n      };\n      kibanaLayer.on('styleChanged', onStyleChanged);\n      this._listeners.push({ name: 'styleChanged', handle: onStyleChanged, layer: kibanaLayer });\n\n      this._layers.push(kibanaLayer);\n      kibanaLayer.addToLeafletMap(this._leafletMap);\n      this.emit('layers:update');\n\n      this._addAttributions(kibanaLayer.getAttributions());\n    }\n  }, {\n    key: 'removeLayer',\n    value: function removeLayer(kibanaLayer) {\n      var _this5 = this;\n\n      if (!kibanaLayer) {\n        return;\n      }\n\n      this._removeAttributions(kibanaLayer.getAttributions());\n      var index = this._layers.indexOf(kibanaLayer);\n      if (index >= 0) {\n        this._layers.splice(index, 1);\n        kibanaLayer.removeFromLeafletMap(this._leafletMap);\n      }\n      this._listeners.forEach(function (listener) {\n        if (listener.layer === kibanaLayer) {\n          listener.layer.removeListener(listener.name, listener.handle);\n        }\n      });\n\n      //must readd all attributions, because we might have removed dupes\n      this._layers.forEach(function (layer) {\n        return _this5._addAttributions(layer.getAttributions());\n      });\n      if (this._baseLayerSettings) {\n        this._addAttributions(this._baseLayerSettings.options.attribution);\n      }\n    }\n  }, {\n    key: '_addAttributions',\n    value: function _addAttributions(attribution) {\n      var _this6 = this;\n\n      var attributions = getAttributionArray(attribution);\n      attributions.forEach(function (attribution) {\n        _this6._leafletMap.attributionControl.removeAttribution(attribution); //this ensures we do not add duplicates\n        _this6._leafletMap.attributionControl.addAttribution(attribution);\n      });\n    }\n  }, {\n    key: '_removeAttributions',\n    value: function _removeAttributions(attribution) {\n      var _this7 = this;\n\n      var attributions = getAttributionArray(attribution);\n      attributions.forEach(function (attribution) {\n        _this7._leafletMap.attributionControl.removeAttribution(attribution); //this ensures we do not add duplicates\n      });\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._leafletFitControl) {\n        this._leafletMap.removeControl(this._leafletFitControl);\n      }\n      if (this._leafletDrawControl) {\n        this._leafletMap.removeControl(this._leafletDrawControl);\n      }\n      if (this._leafletLegendControl) {\n        this._leafletMap.removeControl(this._leafletLegendControl);\n      }\n      this.setBaseLayer(null);\n      var layer = void 0;\n      while (this._layers.length) {\n        layer = this._layers.pop();\n        layer.removeFromLeafletMap(this._leafletMap);\n      }\n      this._leafletMap.remove();\n      this._containerNode.innerHTML = '';\n      this._listeners.forEach(function (listener) {\n        return listener.layer.removeListener(listener.name, listener.handle);\n      });\n    }\n  }, {\n    key: 'getCenter',\n    value: function getCenter() {\n      var center = this._leafletMap.getCenter();\n      return { lon: center.lng, lat: center.lat };\n    }\n  }, {\n    key: 'setCenter',\n    value: function setCenter(latitude, longitude) {\n      var latLong = _leaflet2.default.latLng(latitude, longitude);\n      if (latLong.equals && !latLong.equals(this._leafletMap.getCenter())) {\n        this._leafletMap.setView(latLong);\n      }\n    }\n  }, {\n    key: 'setZoomLevel',\n    value: function setZoomLevel(zoomLevel) {\n      if (this._leafletMap.getZoom() !== zoomLevel) {\n        this._leafletMap.setZoom(zoomLevel);\n      }\n    }\n  }, {\n    key: 'getZoomLevel',\n    value: function getZoomLevel() {\n      return this._leafletMap.getZoom();\n    }\n  }, {\n    key: 'getMaxZoomLevel',\n    value: function getMaxZoomLevel() {\n      return this._leafletMap.getMaxZoom();\n    }\n  }, {\n    key: 'getAutoPrecision',\n    value: function getAutoPrecision() {\n      return (0, _zoom_to_precision.zoomToPrecision)(this._leafletMap.getZoom(), 12, this._leafletMap.getMaxZoom());\n    }\n  }, {\n    key: 'getLeafletBounds',\n    value: function getLeafletBounds() {\n      return this._leafletMap.getBounds();\n    }\n  }, {\n    key: 'getMetersPerPixel',\n    value: function getMetersPerPixel() {\n      var pointC = this._leafletMap.latLngToContainerPoint(this._leafletMap.getCenter()); // center (pixels)\n      var pointX = [pointC.x + 1, pointC.y]; // add one pixel to x\n      var pointY = [pointC.x, pointC.y + 1]; // add one pixel to y\n\n      var latLngC = this._leafletMap.containerPointToLatLng(pointC);\n      var latLngX = this._leafletMap.containerPointToLatLng(pointX);\n      var latLngY = this._leafletMap.containerPointToLatLng(pointY);\n\n      var distanceX = latLngC.distanceTo(latLngX); // calculate distance between c and x (latitude)\n      var distanceY = latLngC.distanceTo(latLngY); // calculate distance between c and y (longitude)\n      return _lodash2.default.min([distanceX, distanceY]);\n    }\n  }, {\n    key: 'getBounds',\n    value: function getBounds() {\n\n      var bounds = this._leafletMap.getBounds();\n      if (!bounds) {\n        return null;\n      }\n\n      var southEast = bounds.getSouthEast();\n      var northWest = bounds.getNorthWest();\n      var southEastLng = southEast.lng;\n      if (southEastLng > 180) {\n        southEastLng -= 360;\n      }\n      var northWestLng = northWest.lng;\n      if (northWestLng < -180) {\n        northWestLng += 360;\n      }\n\n      var southEastLat = southEast.lat;\n      var northWestLat = northWest.lat;\n\n      //Bounds cannot be created unless they form a box with larger than 0 dimensions\n      //Invalid areas are rejected by ES.\n      if (southEastLat === northWestLat || southEastLng === northWestLng) {\n        return;\n      }\n\n      return {\n        bottom_right: {\n          lat: southEastLat,\n          lon: southEastLng\n        },\n        top_left: {\n          lat: northWestLat,\n          lon: northWestLng\n        }\n      };\n    }\n  }, {\n    key: 'getUntrimmedBounds',\n    value: function getUntrimmedBounds() {\n      var bounds = this._leafletMap.getBounds();\n      if (!bounds) {\n        return null;\n      }\n\n      var southEast = bounds.getSouthEast();\n      var northWest = bounds.getNorthWest();\n      var southEastLng = southEast.lng;\n      var northWestLng = northWest.lng;\n      var southEastLat = southEast.lat;\n      var northWestLat = northWest.lat;\n\n      // When map has not width or height, the map has no dimensions.\n      // These dimensions are enforced due to CSS style rules that enforce min-width/height of 0\n      // that enforcement also resolves errors with the heatmap layer plugin.\n\n      return {\n        bottom_right: {\n          lat: southEastLat,\n          lon: southEastLng\n        },\n        top_left: {\n          lat: northWestLat,\n          lon: northWestLng\n        }\n      };\n    }\n  }, {\n    key: 'setDesaturateBaseLayer',\n    value: function setDesaturateBaseLayer(isDesaturated) {\n      if (isDesaturated === this._baseLayerIsDesaturated) {\n        return;\n      }\n      this._baseLayerIsDesaturated = isDesaturated;\n      this._updateDesaturation();\n      this._leafletBaseLayer.redraw();\n    }\n  }, {\n    key: 'addDrawControl',\n    value: function addDrawControl() {\n      var drawColor = '#000';\n      var drawOptions = {\n        draw: {\n          polyline: false,\n          marker: false,\n          circle: false,\n          rectangle: {\n            shapeOptions: {\n              stroke: false,\n              color: drawColor\n            }\n          },\n          polygon: {\n            shapeOptions: {\n              color: drawColor\n            }\n          }\n        }\n      };\n      this._leafletDrawControl = new _leaflet2.default.Control.Draw(drawOptions);\n      this._leafletMap.addControl(this._leafletDrawControl);\n    }\n  }, {\n    key: 'addFitControl',\n    value: function addFitControl() {\n\n      if (this._leafletFitControl || !this._leafletMap) {\n        return;\n      }\n\n      var fitContainer = _leaflet2.default.DomUtil.create('div', 'leaflet-control leaflet-bar leaflet-control-fit');\n      this._leafletFitControl = makeFitControl(fitContainer, this);\n      this._leafletMap.addControl(this._leafletFitControl);\n    }\n  }, {\n    key: 'addLegendControl',\n    value: function addLegendControl() {\n      if (this._leafletLegendControl || !this._leafletMap) {\n        return;\n      }\n      this._updateLegend();\n    }\n  }, {\n    key: 'setLegendPosition',\n    value: function setLegendPosition(position) {\n      if (this._legendPosition === position) {\n        if (!this._leafletLegendControl) {\n          this._updateLegend();\n        }\n      } else {\n        this._legendPosition = position;\n        this._updateLegend();\n      }\n    }\n  }, {\n    key: '_updateLegend',\n    value: function _updateLegend() {\n      if (this._leafletLegendControl) {\n        this._leafletMap.removeControl(this._leafletLegendControl);\n      }\n      var $wrapper = (0, _jquery2.default)('<div>').addClass('tilemap-legend-wrapper');\n      this._leafletLegendControl = makeLegedControl($wrapper, this, this._legendPosition);\n      this._leafletMap.addControl(this._leafletLegendControl);\n    }\n  }, {\n    key: 'resize',\n    value: function resize() {\n      this._leafletMap.invalidateSize();\n      this._updateExtent();\n    }\n  }, {\n    key: 'setMinZoom',\n    value: function setMinZoom(zoom) {\n      this._leafletMap.setMinZoom(zoom);\n    }\n  }, {\n    key: 'setMaxZoom',\n    value: function setMaxZoom(zoom) {\n      this._leafletMap.setMaxZoom(zoom);\n    }\n  }, {\n    key: 'getLeafletBaseLayer',\n    value: function getLeafletBaseLayer() {\n      return this._leafletBaseLayer;\n    }\n  }, {\n    key: 'setBaseLayer',\n    value: function setBaseLayer(settings) {\n      var _this8 = this;\n\n      if (_lodash2.default.isEqual(settings, this._baseLayerSettings)) {\n        return;\n      }\n\n      if (settings === null) {\n        if (this._leafletBaseLayer && this._leafletMap) {\n          this._removeAttributions(this._baseLayerSettings.options.attribution);\n          this._leafletMap.removeLayer(this._leafletBaseLayer);\n          this._leafletBaseLayer = null;\n          this._baseLayerSettings = null;\n        }\n        return;\n      }\n\n      this._baseLayerSettings = settings;\n      if (this._leafletBaseLayer) {\n        this._leafletMap.removeLayer(this._leafletBaseLayer);\n        this._leafletBaseLayer = null;\n      }\n\n      var baseLayer = void 0;\n      if (settings.baseLayerType === 'wms') {\n        baseLayer = this._getWMSBaseLayer(settings.options);\n      } else if (settings.baseLayerType === 'tms') {\n        baseLayer = this._getTMSBaseLayer(settings.options);\n      }\n\n      if (baseLayer) {\n        baseLayer.on('tileload', function () {\n          return _this8._updateDesaturation();\n        });\n        baseLayer.on('load', function () {\n          _this8.emit('baseLayer:loaded');\n        });\n        baseLayer.on('loading', function () {\n          _this8.emit('baseLayer:loading');\n        });\n\n        this._leafletBaseLayer = baseLayer;\n        this._leafletBaseLayer.addTo(this._leafletMap);\n        this._leafletBaseLayer.bringToBack();\n        if (settings.options.minZoom > this._leafletMap.getZoom()) {\n          this._leafletMap.setZoom(settings.options.minZoom);\n        }\n        this._addAttributions(settings.options.attribution);\n        this.resize();\n      }\n    }\n  }, {\n    key: 'isInside',\n    value: function isInside(bucketRectBounds) {\n      var mapBounds = this._leafletMap.getBounds();\n      return mapBounds.intersects(bucketRectBounds);\n    }\n  }, {\n    key: 'fitToData',\n    value: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var _this9 = this;\n\n        var boundsArray, bounds;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this._leafletMap) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt('return');\n\n              case 2:\n                _context3.next = 4;\n                return Promise.all(this._layers.map(function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(layer) {\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return layer.getBounds();\n\n                          case 2:\n                            return _context.abrupt('return', _context.sent);\n\n                          case 3:\n                          case 'end':\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, _this9);\n                  }));\n\n                  return function (_x) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()));\n\n              case 4:\n                boundsArray = _context3.sent;\n                bounds = null;\n\n                boundsArray.forEach(function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(b) {\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            if (bounds) {\n                              bounds.extend(b);\n                            } else {\n                              bounds = b;\n                            }\n\n                          case 1:\n                          case 'end':\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, _this9);\n                  }));\n\n                  return function (_x2) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n\n                if (bounds && bounds.isValid()) {\n                  this._leafletMap.fitBounds(bounds);\n                }\n\n              case 8:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function fitToData() {\n        return _ref.apply(this, arguments);\n      }\n\n      return fitToData;\n    }()\n  }, {\n    key: '_getTMSBaseLayer',\n    value: function _getTMSBaseLayer(options) {\n      return _leaflet2.default.tileLayer(options.url, {\n        minZoom: options.minZoom,\n        maxZoom: options.maxZoom,\n        subdomains: options.subdomains || []\n      });\n    }\n  }, {\n    key: '_getWMSBaseLayer',\n    value: function _getWMSBaseLayer(options) {\n      var wmsOptions = {\n        format: options.format || '',\n        layers: options.layers || '',\n        minZoom: options.minZoom,\n        maxZoom: options.maxZoom,\n        styles: options.styles || '',\n        transparent: options.transparent,\n        version: options.version || '1.3.0'\n      };\n\n      return typeof options.url === 'string' && options.url.length ? _leaflet2.default.tileLayer.wms(options.url, wmsOptions) : null;\n    }\n  }, {\n    key: '_updateExtent',\n    value: function _updateExtent() {\n      this._layers.forEach(function (layer) {\n        return layer.updateExtent();\n      });\n    }\n  }, {\n    key: '_updateDesaturation',\n    value: function _updateDesaturation() {\n      var tiles = (0, _jquery2.default)('img.leaflet-tile-loaded');\n      if (this._baseLayerIsDesaturated) {\n        tiles.removeClass('filters-off');\n      } else if (!this._baseLayerIsDesaturated) {\n        tiles.addClass('filters-off');\n      }\n    }\n  }, {\n    key: 'persistUiStateForVisualization',\n    value: function persistUiStateForVisualization(visualization) {\n      function persistMapStateInUiState() {\n        var uiState = visualization.getUiState();\n        var centerFromUIState = uiState.get('mapCenter');\n        var zoomFromUiState = parseInt(uiState.get('mapZoom'));\n\n        if (isNaN(zoomFromUiState) || this.getZoomLevel() !== zoomFromUiState) {\n          visualization.uiStateVal('mapZoom', this.getZoomLevel());\n        }\n        var centerFromMap = this.getCenter();\n        if (!centerFromUIState || centerFromMap.lon !== centerFromUIState[1] || centerFromMap.lat !== centerFromUIState[0]) {\n          visualization.uiStateVal('mapCenter', [centerFromMap.lat, centerFromMap.lon]);\n        }\n        visualization.sessionState.mapBounds = this.getUntrimmedBounds();\n      }\n\n      this.on('dragend', persistMapStateInUiState);\n      this.on('zoomend', persistMapStateInUiState);\n    }\n  }, {\n    key: 'useUiStateFromVisualization',\n    value: function useUiStateFromVisualization(visualization) {\n      var uiState = visualization.getUiState();\n      var zoomFromUiState = parseInt(uiState.get('mapZoom'));\n      var centerFromUIState = uiState.get('mapCenter');\n      if (!isNaN(zoomFromUiState)) {\n        this.setZoomLevel(zoomFromUiState);\n      }\n      if (centerFromUIState) {\n        this.setCenter(centerFromUIState[0], centerFromUIState[1]);\n      }\n    }\n  }]);\n\n  return KibanaMap;\n}(_events.EventEmitter);\n\nfunction getAttributionArray(attribution) {\n  var attributionString = attribution || '';\n  var attributions = attributionString.split('|');\n  if (attributions.length === 1) {\n    //temp work-around due to inconsistency in manifests of how attributions are delimited\n    attributions = attributions[0].split(',');\n  }\n  return attributions;\n}",null]}