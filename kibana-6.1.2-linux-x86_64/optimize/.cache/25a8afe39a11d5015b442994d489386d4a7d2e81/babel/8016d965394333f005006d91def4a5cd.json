{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/utils/streams/promise_from_streams.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/utils/streams/promise_from_streams.js","mtime":1515552212879},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n *  Take an array of streams, pipe the output\n *  from each one into the next, listening for\n *  errors from any of the streams, and then resolve\n *  the promise once the final stream has finished\n *  writing/reading.\n *\n *  If the last stream is readable, it's final value\n *  will be provided as the promise value.\n *\n *  Errors emmitted from any stream will cause\n *  the promise to be rejected with that error.\n *\n *  @param  {Array<Stream>} streams\n *  @return {Promise<any>}\n */\nvar createPromiseFromStreams = exports.createPromiseFromStreams = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(streams) {\n    var last, anyStreamFailure, lastFinishedWriting, lastFinishedReading;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            last = streams[streams.length - 1];\n\n            // reject if any of the streams emits an error\n\n            anyStreamFailure = new Promise(function (resolve, reject) {\n              streams.forEach(function (stream, i) {\n                if (i > 0) streams[i - 1].pipe(stream);\n                stream.on('error', reject);\n                return stream;\n              });\n            });\n\n            // resolve when the last stream has finished writing, or\n            // immediately if the last stream is not writable\n\n            lastFinishedWriting = new Promise(function (resolve) {\n              if (typeof last.write !== 'function') {\n                resolve();\n                return;\n              }\n\n              last.on('finish', resolve);\n            });\n\n            // resolve with the final value provided by the last stream\n            // after the last stream has provided it, or immediately if the\n            // stream is not readable\n\n            lastFinishedReading = new Promise(function (resolve) {\n              if (typeof last.read !== 'function') {\n                resolve();\n                return;\n              }\n\n              var finalChunk = void 0;\n              last.on('data', function (chunk) {\n                finalChunk = chunk;\n              });\n              last.on('end', function () {\n                resolve(finalChunk);\n              });\n            });\n\n            // wait (and rethrow) the first error, or for the last stream\n            // to both finish writing and providing values to read\n\n            _context.next = 6;\n            return Promise.race([anyStreamFailure, Promise.all([lastFinishedWriting, lastFinishedReading])]);\n\n          case 6:\n            _context.next = 8;\n            return lastFinishedReading;\n\n          case 8:\n            return _context.abrupt('return', _context.sent);\n\n          case 9:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function createPromiseFromStreams(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);var value = info.value;\n        } catch (error) {\n          reject(error);return;\n        }if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }return step(\"next\");\n    });\n  };\n}",null]}