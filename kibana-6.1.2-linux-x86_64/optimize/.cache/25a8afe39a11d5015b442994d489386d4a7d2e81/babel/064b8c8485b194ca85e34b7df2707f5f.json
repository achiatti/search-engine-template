{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/doc_table/doc_table.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/doc_table/doc_table.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _doc_table = require('ui/doc_table/doc_table.html');\n\nvar _doc_table2 = _interopRequireDefault(_doc_table);\n\nvar _get_sort = require('ui/doc_table/lib/get_sort');\n\nrequire('ui/doc_table/doc_table.less');\n\nrequire('ui/directives/truncated');\n\nrequire('ui/directives/infinite_scroll');\n\nrequire('ui/doc_table/components/table_header');\n\nrequire('ui/doc_table/components/table_row');\n\nvar _modules = require('ui/modules');\n\nvar _doc_table_strings = require('./doc_table_strings');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_modules.uiModules.get('kibana').directive('docTable', function (config, Notifier, getAppState, pagerFactory, $filter, courier) {\n  return {\n    restrict: 'E',\n    template: _doc_table2.default,\n    scope: {\n      sorting: '=',\n      columns: '=',\n      hits: '=?', // You really want either hits & indexPattern, OR searchSource\n      indexPattern: '=?',\n      searchSource: '=?',\n      infiniteScroll: '=?',\n      filter: '=?',\n      filters: '=?',\n      minimumVisibleRows: '=?',\n      onAddColumn: '=?',\n      onChangeSortOrder: '=?',\n      onMoveColumn: '=?',\n      onRemoveColumn: '=?'\n    },\n    link: function link($scope, $el) {\n      var notify = new Notifier();\n\n      $scope.$watch('minimumVisibleRows', function (minimumVisibleRows) {\n        $scope.limit = Math.max(minimumVisibleRows || 50, $scope.limit || 50);\n      });\n\n      $scope.persist = {\n        sorting: $scope.sorting,\n        columns: $scope.columns\n      };\n\n      var limitTo = $filter('limitTo');\n      var calculateItemsOnPage = function calculateItemsOnPage() {\n        $scope.pager.setTotalItems($scope.hits.length);\n        $scope.pageOfItems = limitTo($scope.hits, $scope.pager.pageSize, $scope.pager.startIndex);\n      };\n\n      $scope.limitedResultsWarning = (0, _doc_table_strings.getLimitedSearchResultsMessage)(config.get('discover:sampleSize'));\n\n      $scope.addRows = function () {\n        $scope.limit += 50;\n      };\n\n      // This exists to fix the problem of an empty initial column list not playing nice with watchCollection.\n      $scope.$watch('columns', function (columns) {\n        if (columns.length !== 0) return;\n\n        var $state = getAppState();\n        $scope.columns.push('_source');\n        if ($state) $state.replace();\n      });\n\n      $scope.$watchCollection('columns', function (columns, oldColumns) {\n        if (oldColumns.length === 1 && oldColumns[0] === '_source' && $scope.columns.length > 1) {\n          _lodash2.default.pull($scope.columns, '_source');\n        }\n\n        if ($scope.columns.length === 0) $scope.columns.push('_source');\n      });\n\n      $scope.$watch('searchSource', function () {\n        if (!$scope.searchSource) return;\n\n        $scope.indexPattern = $scope.searchSource.get('index');\n\n        $scope.searchSource.size(config.get('discover:sampleSize'));\n        $scope.searchSource.sort((0, _get_sort.getSort)($scope.sorting, $scope.indexPattern));\n\n        // Set the watcher after initialization\n        $scope.$watchCollection('sorting', function (newSort, oldSort) {\n          // Don't react if sort values didn't really change\n          if (newSort === oldSort) return;\n          $scope.searchSource.sort((0, _get_sort.getSort)(newSort, $scope.indexPattern));\n          $scope.searchSource.fetchQueued();\n        });\n\n        $scope.$on('$destroy', function () {\n          if ($scope.searchSource) $scope.searchSource.destroy();\n        });\n\n        function onResults(resp) {\n          // Reset infinite scroll limit\n          $scope.limit = 50;\n\n          // Abort if something changed\n          if ($scope.searchSource !== $scope.searchSource) return;\n\n          $scope.hits = resp.hits.hits;\n          if ($scope.hits.length === 0) {\n            $el.trigger('renderComplete');\n          }\n          // We limit the number of returned results, but we want to show the actual number of hits, not\n          // just how many we retrieved.\n          $scope.totalHitCount = resp.hits.total;\n          $scope.pager = pagerFactory.create($scope.hits.length, 50, 1);\n          calculateItemsOnPage();\n\n          return $scope.searchSource.onResults().then(onResults);\n        }\n\n        function startSearching() {\n          $scope.searchSource.onResults().then(onResults).catch(function (error) {\n            notify.error(error);\n            startSearching();\n          });\n        }\n        startSearching();\n        courier.fetch();\n      });\n\n      $scope.pageOfItems = [];\n      $scope.onPageNext = function () {\n        $scope.pager.nextPage();\n        calculateItemsOnPage();\n      };\n\n      $scope.onPagePrevious = function () {\n        $scope.pager.previousPage();\n        calculateItemsOnPage();\n      };\n\n      $scope.shouldShowLimitedResultsWarning = function () {\n        return !$scope.pager.hasNextPage && $scope.pager.totalItems < $scope.totalHitCount;\n      };\n    }\n  };\n});",null]}