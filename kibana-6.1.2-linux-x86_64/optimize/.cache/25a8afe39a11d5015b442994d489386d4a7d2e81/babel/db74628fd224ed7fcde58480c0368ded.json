{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/lodash-mixins/function.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/lodash-mixins/function.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lodashFunctionMixin = lodashFunctionMixin;\nfunction lodashFunctionMixin(_) {\n  _.mixin({\n\n    /**\n     * Create a method that wraps another method which expects a callback as it's last\n     * argument. The wrapper method will call the wrapped function only once (the first\n     * time it is called), but will always call the callbacks passed to it. This has a\n     * similar effect to calling a promise-returning function that is wrapped with _.once\n     * but can be used outside of angular.\n     *\n     * @param  {Function} fn - the function that should only be executed once and accepts\n     *                       a callback as it's last arg\n     * @return {Function} - the wrapper method\n     */\n    onceWithCb: function onceWithCb(fn) {\n      var callbacks = [];\n\n      // on initial flush, call the init function, but ensure\n      // that it only happens once\n      var flush = _.once(function (cntx, args) {\n        args.push(function finishedOnce() {\n          // override flush to simply schedule an asynchronous clear\n          flush = function flush() {\n            setTimeout(function () {\n              _.callEach(callbacks.splice(0));\n            }, 0);\n          };\n\n          flush();\n        });\n\n        fn.apply(cntx, args);\n      });\n\n      return function runOnceWithCb() {\n        var args = [].slice.call(arguments, 0);\n        var cb = args[args.length - 1];\n\n        if (typeof cb === 'function') {\n          callbacks.push(cb);\n          // trim the arg list so the other callback can\n          // be pushed if needed\n          args = args.slice(0, -1);\n        }\n\n        // always call flush, it might not do anything\n        flush(this, args);\n      };\n    },\n\n    /**\n     * Call all of the function in an array\n     *\n     * @param  {array[functions]} arr\n     * @return {undefined}\n     */\n    callEach: function callEach(arr) {\n      return _.map(arr, function (fn) {\n        return _.isFunction(fn) ? fn() : undefined;\n      });\n    }\n\n  });\n}",null]}