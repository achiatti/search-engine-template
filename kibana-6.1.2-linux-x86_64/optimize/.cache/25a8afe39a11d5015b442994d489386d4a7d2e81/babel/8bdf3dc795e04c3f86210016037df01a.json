{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/looper/_looper.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/looper/_looper.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LooperProvider = LooperProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nrequire('ui/promises');\n\nvar _notifier = require('ui/notify/notifier');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction LooperProvider($timeout, Promise) {\n  var notify = new _notifier.Notifier();\n\n  function Looper(ms, fn) {\n    this._fn = fn;\n    this._ms = ms === void 0 ? 1500 : ms;\n    this._timer = null;\n    this._started = false;\n\n    this._loopTheLoop = _lodash2.default.bind(this._loopTheLoop, this);\n  }\n\n  /**\n   * Set the number of milliseconds between\n   * each loop\n   *\n   * @param  {integer} ms\n   * @chainable\n   */\n  Looper.prototype.ms = function (ms) {\n    this._ms = _lodash2.default.parseInt(ms) || 0;\n\n    if (!this._started) return;\n\n    if (this._ms) {\n      this.start(false);\n    } else {\n      this._unScheduleLoop();\n    }\n\n    return this;\n  };\n\n  /**\n   * Cancels the current looper while keeping internal\n   * state as started\n   *\n   * @chainable\n   */\n  Looper.prototype.pause = function () {\n    this._unScheduleLoop();\n    return this;\n  };\n\n  /**\n   * Start the looping madness\n   *\n   * @chainable\n   */\n  Looper.prototype.start = function (loopOver) {\n    if (loopOver == null) loopOver = true;\n\n    if (!this._started) {\n      this._started = true;\n    } else {\n      this._unScheduleLoop();\n    }\n\n    if (loopOver) {\n      this._loopTheLoop();\n    } else {\n      this._scheduleLoop();\n    }\n\n    return this;\n  };\n\n  /**\n   * ...\n   *\n   * @chainable\n   */\n  Looper.prototype.stop = function () {\n    this._unScheduleLoop();\n    this._started = false;\n    return this;\n  };\n\n  /**\n   * Restart the looper only if it is already started.\n   * Called automatically when ms is changed\n   *\n   * @chainable\n   */\n  Looper.prototype.restart = function () {\n    this.start(false);\n    return this;\n  };\n\n  /**\n   * Is the looper currently started/running/scheduled/going to execute\n   *\n   * @return {boolean}\n   */\n  Looper.prototype.started = function () {\n    return !!this._started;\n  };\n\n  /**\n   * Returns the current loop interval\n   *\n   * @return {number}\n   */\n  Looper.prototype.loopInterval = function () {\n    return this._ms;\n  };\n\n  /**\n   * Called when the loop is executed before the previous\n   * run has completed.\n   *\n   * @override\n   * @return {undefined}\n   */\n  Looper.prototype.onHastyLoop = function () {\n    // override this in subclasses\n  };\n\n  /**\n   * Wraps this._fn so that this._fn can be changed\n   * without rescheduling and schedules\n   * the next itteration\n   *\n   * @private\n   * @return {undefined}\n   */\n  Looper.prototype._loopTheLoop = function () {\n    var self = this;\n\n    if (self.active) {\n      self.onHastyLoop();\n      return;\n    }\n\n    self.active = Promise.try(this._fn).then(function () {\n      self._scheduleLoop();\n    }).catch(function (err) {\n      self.stop();\n      notify.fatal(err);\n    }).finally(function () {\n      self.active = null;\n    });\n  };\n\n  /**\n   * Schedule the next itteration of the loop\n   *\n   * @private\n   * @return {number} - the timer promise\n   */\n  Looper.prototype._scheduleLoop = function () {\n    this._unScheduleLoop();\n    this._timer = this._ms ? $timeout(this._loopTheLoop, this._ms) : null;\n    return this._timer;\n  };\n\n  /**\n   * Cancel the next itteration of the loop\n   *\n   * @private\n   * @return {number} - the timer promise\n   */\n  Looper.prototype._unScheduleLoop = function () {\n    if (this._timer) {\n      $timeout.cancel(this._timer);\n      this._timer = null;\n    }\n  };\n\n  /**\n   * execute the this._fn, and restart the timer\n   */\n  Looper.prototype.run = function () {\n    this.start();\n  };\n\n  return Looper;\n}",null]}