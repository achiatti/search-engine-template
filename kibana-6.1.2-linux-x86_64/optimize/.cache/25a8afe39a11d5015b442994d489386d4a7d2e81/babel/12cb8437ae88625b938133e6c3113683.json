{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/modules.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/modules.js","mtime":1515552033000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uiModules = undefined;\nexports.link = link;\nexports.get = get;\nexports.close = close;\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * This module is used by Kibana to create and reuse angular modules. Angular modules\n * can only be created once and need to have their dependencies at creation. This is\n * hard/impossible to do in require.js since all of the dependencies for a module are\n * loaded before it is.\n *\n * Here is an example:\n *\n * \tIn the scenario below, require.js would load directive.js first because it is a\n * \tdependency of app.js. This would cause the call to `angular.module('app')` to\n * \texecute before the module is actually created. This causes angular to throw an\n * \terror. This effect is magnified when app.js links off to many different modules.\n *\n * \tThis is normally solved by creating unique modules per file, listed as the 1st\n * \talternate solution below. Unfortunately this solution would have required that\n * \twe replicate our require statements.\n *\n *  \tapp.js\n *      ```\n *      angular.module('app', ['ui.bootstrap'])\n *      .controller('AppController', function () { ... });\n *\n *      require('./directive');\n *      ```\n *\n *    directive.js\n *      ```\n *      angular.module('app')\n *      .directive('someDirective', function () { ... });\n *      ```\n *\n * Before taking this approach we saw three possible solutions:\n *   1. replicate our js modules in angular modules/use a different module per file\n *   2. create a single module outside of our js modules and share it\n *   3. use a helper lib to dynamically create modules as needed.\n *\n * We decided to go with #3\n *\n * This ends up working by creating a list of modules that the code base creates by\n * calling `modules.get(name)` with different names, and then before bootstrapping\n * the application kibana uses `modules.link()` to set the dependencies of the \"kibana\"\n * module to include every defined module. This guarantees that kibana can always find\n * any angular dependecy defined in the kibana code base. This **also** means that\n * Private modules are able to find any dependency, since they are injected using the\n * \"kibana\" module's injector.\n *\n */\nvar existingModules = {};\nvar links = [];\n\n/**\n * Take an angular module and extends the dependencies for that module to include all of the modules\n * created using `ui/modules`\n *\n * @param  {AngularModule} module - the module to extend\n * @return {undefined}\n */\nfunction link(module) {\n  // as modules are defined they will be set as requirements for this app\n  links.push(module);\n\n  // merge in the existing modules\n  module.requires = _lodash2.default.union(module.requires, _lodash2.default.keys(existingModules));\n}\n\n/**\n * The primary means of interacting with `ui/modules`. Returns an angular module. If the module already\n * exists the existing version will be returned. `dependencies` are either set as or merged into the\n * modules total dependencies.\n *\n * This is in contrast to the `angular.module(name, [dependencies])` function which will only\n * create a module if the `dependencies` list is passed and get an existing module if no dependencies\n * are passed. This requires knowing the order that your files will load, which we can't guarantee.\n *\n * @param  {string} moduleName - the unique name for this module\n * @param  {array[string]} [requires=[]] - the other modules this module requires\n * @return {AngularModule}\n */\nfunction get(moduleName, requires) {\n  var module = existingModules[moduleName];\n\n  if (module === void 0) {\n    // create the module\n    module = existingModules[moduleName] = _angular2.default.module(moduleName, []);\n\n    module.close = _lodash2.default.partial(close, moduleName);\n\n    // ensure that it is required by linked modules\n    _lodash2.default.each(links, function (app) {\n      if (!~app.requires.indexOf(moduleName)) app.requires.push(moduleName);\n    });\n  }\n\n  if (requires) {\n    // update requires list with possibly new requirements\n    module.requires = _lodash2.default.union(module.requires, requires);\n  }\n\n  return module;\n}\n\nfunction close(moduleName) {\n  var module = existingModules[moduleName];\n\n  // already closed\n  if (!module) return;\n\n  // if the module is currently linked, unlink it\n  var i = links.indexOf(module);\n  if (i > -1) links.splice(i, 1);\n\n  // remove from linked modules list of required modules\n  _lodash2.default.each(links, function (app) {\n    _lodash2.default.pull(app.requires, moduleName);\n  });\n\n  // remove module from existingModules\n  delete existingModules[moduleName];\n}\n\nvar uiModules = exports.uiModules = { link: link, get: get, close: close };",null]}