{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/autocomplete.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/autocomplete.js","mtime":1515552026000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = function (editor) {\n\n  function isSeparatorToken(token) {\n    switch ((token || {}).type) {\n      case \"url.slash\":\n      case \"url.comma\":\n      case \"url.questionmark\":\n      case \"paren.lparen\":\n      case \"paren.rparen\":\n      case \"punctuation.colon\":\n      case \"punctuation.comma\":\n      case \"whitespace\":\n        return true;\n      default:\n        // standing on white space, quotes or another punctuation - no replacing\n        return false;\n    }\n  }\n\n  function isUrlPathToken(token) {\n    switch ((token || {}).type) {\n      case \"url.slash\":\n      case \"url.comma\":\n      case \"url.part\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isUrlParamsToken(token) {\n    switch ((token || {}).type) {\n      case \"url.param\":\n      case \"url.equal\":\n      case \"url.value\":\n      case \"url.questionmark\":\n      case \"url.amp\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function getAutoCompleteValueFromToken(token) {\n    switch ((token || {}).type) {\n      case \"variable\":\n      case \"string\":\n      case \"text\":\n      case \"constant.numeric\":\n      case \"constant.language.boolean\":\n        return token.value.replace(/\"/g, '');\n      case \"method\":\n      case \"url.part\":\n        return token.value;\n      default:\n        // standing on white space, quotes or another punctuation - no replacing\n        return \"\";\n    }\n  }\n\n  function addMetaToTermsList(list, meta, template) {\n    return _lodash2.default.map(list, function (t) {\n      if ((typeof t === 'undefined' ? 'undefined' : _typeof(t)) !== \"object\") {\n        t = { name: t };\n      }\n      return _lodash2.default.defaults(t, { meta: meta, template: template });\n    });\n  }\n\n  function applyTerm(term) {\n    var session = editor.getSession();\n\n    var context = term.context;\n\n    // make sure we get up to date replacement info.\n    addReplacementInfoToContext(context, editor.getCursorPosition(), term.insert_value);\n\n    var termAsString;\n    if (context.autoCompleteType == \"body\") {\n      termAsString = typeof term.insert_value == \"string\" ? '\"' + term.insert_value + '\"' : term.insert_value + \"\";\n      if (term.insert_value === \"[\" || term.insert_value === \"{\") {\n        termAsString = \"\";\n      }\n    } else {\n      termAsString = term.insert_value + \"\";\n    }\n\n    var valueToInsert = termAsString;\n    var templateInserted = false;\n    if (context.addTemplate && !_lodash2.default.isUndefined(term.template) && !_lodash2.default.isNull(term.template)) {\n      var indentedTemplateLines = _utils2.default.jsonToString(term.template, true).split(\"\\n\");\n      var currentIndentation = session.getLine(context.rangeToReplace.start.row);\n      currentIndentation = currentIndentation.match(/^\\s*/)[0];\n      for (var i = 1; i < indentedTemplateLines.length; i++) {\n        // skip first line\n        indentedTemplateLines[i] = currentIndentation + indentedTemplateLines[i];\n      }valueToInsert += \": \" + indentedTemplateLines.join(\"\\n\");\n      templateInserted = true;\n    } else {\n      templateInserted = true;\n      if (term.value === \"[\") {\n        valueToInsert += \"[]\";\n      } else if (term.value == \"{\") {\n        valueToInsert += \"{}\";\n      } else {\n        templateInserted = false;\n      }\n    }\n\n    valueToInsert = context.prefixToAdd + valueToInsert + context.suffixToAdd;\n\n    // disable listening to the changes we are making.\n    removeChangeListener();\n\n    if (context.rangeToReplace.start.column != context.rangeToReplace.end.column) {\n      session.replace(context.rangeToReplace, valueToInsert);\n    } else {\n      editor.insert(valueToInsert);\n    }\n\n    editor.clearSelection(); // for some reason the above changes selection\n\n    // go back to see whether we have one of ( : { & [ do not require a comma. All the rest do.\n    var newPos = {\n      row: context.rangeToReplace.start.row,\n      column: context.rangeToReplace.start.column + termAsString.length + context.prefixToAdd.length + (templateInserted ? 0 : context.suffixToAdd.length)\n    };\n\n    var tokenIter = editor.iterForPosition(newPos.row, newPos.column);\n\n    if (context.autoCompleteType === \"body\") {\n      // look for the next place stand, just after a comma, {\n      var nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);\n      switch (nonEmptyToken ? nonEmptyToken.type : \"NOTOKEN\") {\n        case \"paren.rparen\":\n          newPos = { row: tokenIter.getCurrentTokenRow(), column: tokenIter.getCurrentTokenColumn() };\n          break;\n        case \"punctuation.colon\":\n          nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);\n          if ((nonEmptyToken || {}).type == \"paren.lparen\") {\n            nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);\n            newPos = { row: tokenIter.getCurrentTokenRow(), column: tokenIter.getCurrentTokenColumn() };\n            if (nonEmptyToken && nonEmptyToken.value.indexOf('\"') === 0) {\n              newPos.column++;\n            } // don't stand on \"\n          }\n          break;\n        case \"paren.lparen\":\n        case \"punctuation.comma\":\n          tokenIter.stepForward();\n          newPos = { row: tokenIter.getCurrentTokenRow(), column: tokenIter.getCurrentTokenColumn() };\n          break;\n      }\n      editor.moveCursorToPosition(newPos);\n    }\n\n    // re-enable listening to typing\n    addChangeListener();\n  }\n\n  function getAutoCompleteContext(editor, session, pos) {\n    // deduces all the parameters need to position and insert the auto complete\n    var context = {\n      autoCompleteSet: null, // instructions for what can be here\n      endpoint: null,\n      urlPath: null,\n      method: null,\n      activeScheme: null,\n      editor: editor\n    };\n\n    //  context.updatedForToken = session.getTokenAt(pos.row, pos.column);\n    //\n    //  if (!context.updatedForToken)\n    //    context.updatedForToken = { value: \"\", start: pos.column }; // empty line\n    //\n    //  context.updatedForToken.row = pos.row; // extend\n\n    context.autoCompleteType = getAutoCompleteType(pos);\n    switch (context.autoCompleteType) {\n      case \"path\":\n        addPathAutoCompleteSetToContext(context, pos);\n        break;\n      case \"url_params\":\n        addUrlParamsAutoCompleteSetToContext(context, pos);\n        break;\n      case \"method\":\n        addMethodAutoCompleteSetToContext(context, pos);\n        break;\n      case \"body\":\n        addBodyAutoCompleteSetToContext(context, pos);\n        break;\n      default:\n        return null;\n    }\n\n    if (!context.autoCompleteSet) {\n      return null; // nothing to do..\n    }\n\n    addReplacementInfoToContext(context, pos);\n\n    context.createdWithToken = _lodash2.default.clone(context.updatedForToken);\n\n    return context;\n  }\n\n  function getAutoCompleteType(pos) {\n    // return \"method\", \"path\" or \"body\" to determine auto complete type.\n\n    var rowMode = editor.parser.getRowParseMode(pos.row);\n\n    //noinspection JSBitwiseOperatorUsage\n    if (rowMode & editor.parser.MODE.IN_REQUEST) {\n      return \"body\";\n    }\n    //noinspection JSBitwiseOperatorUsage\n    if (rowMode & editor.parser.MODE.REQUEST_START) {\n      // on url path, url params or method.\n      var tokenIter = editor.iterForPosition(pos.row, pos.column);\n      var t = tokenIter.getCurrentToken();\n\n      while (t.type == \"url.comma\") {\n        t = tokenIter.stepBackward();\n      }\n      switch (t.type) {\n        case \"method\":\n          return \"method\";\n        case \"whitespace\":\n          t = editor.parser.prevNonEmptyToken(tokenIter);\n\n          switch ((t || {}).type) {\n            case \"method\":\n              // we moved one back\n              return \"path\";\n              break;\n            default:\n              if (isUrlPathToken(t)) {\n                return \"path\";\n              }\n              if (isUrlParamsToken(t)) {\n                return \"url_params\";\n              }\n              return null;\n          }\n          break;\n        default:\n          if (isUrlPathToken(t)) {\n            return \"path\";\n          }\n          if (isUrlParamsToken(t)) {\n            return \"url_params\";\n          }\n          return null;\n      }\n    }\n\n    // after start to avoid single line url only requests\n    //noinspection JSBitwiseOperatorUsage\n    if (rowMode & editor.parser.MODE.REQUEST_END) {\n      return \"body\";\n    }\n\n    // in between request on an empty\n    if ((editor.getSession().getLine(pos.row) || \"\").trim() === \"\") {\n      // check if the previous line is a single line begging of a new request\n      rowMode = editor.parser.getRowParseMode(pos.row - 1);\n      //noinspection JSBitwiseOperatorUsage\n      if (rowMode & editor.parser.MODE.REQUEST_START && rowMode & editor.parser.MODE.REQUEST_END) {\n        return \"body\";\n      }\n      //o.w suggest a method\n      return \"method\";\n    }\n\n    return null;\n  }\n\n  function addReplacementInfoToContext(context, pos, replacingTerm) {\n    // extract the initial value, rangeToReplace & textBoxPosition\n\n    // Scenarios for current token:\n    //   -  Nice token { \"bla|\"\n    //   -  Broken text token {   bla|\n    //   -  No token : { |\n    //   - Broken scenario { , bla|\n    //   - Nice token, broken before: {, \"bla\"\n\n    var session = editor.getSession();\n\n    context.updatedForToken = _lodash2.default.clone(session.getTokenAt(pos.row, pos.column));\n    if (!context.updatedForToken) {\n      context.updatedForToken = { value: \"\", start: pos.column };\n    } // empty line\n\n    var anchorToken = context.createdWithToken;\n    if (!anchorToken) {\n      anchorToken = context.updatedForToken;\n    }\n\n    switch (context.updatedForToken.type) {\n      case \"variable\":\n      case \"string\":\n      case \"text\":\n      case \"constant.numeric\":\n      case \"constant.language.boolean\":\n      case \"method\":\n      case \"url.index\":\n      case \"url.type\":\n      case \"url.id\":\n      case \"url.method\":\n      case \"url.endpoint\":\n      case \"url.part\":\n      case \"url.param\":\n      case \"url.value\":\n        context.rangeToReplace = new AceRange(pos.row, anchorToken.start, pos.row, context.updatedForToken.start + context.updatedForToken.value.length);\n        context.replacingToken = true;\n        break;\n      default:\n        if (replacingTerm && context.updatedForToken.value == replacingTerm) {\n          context.rangeToReplace = new AceRange(pos.row, anchorToken.start, pos.row, context.updatedForToken.start + context.updatedForToken.value.length);\n          context.replacingToken = true;\n        } else {\n          // standing on white space, quotes or another punctuation - no replacing\n          context.rangeToReplace = new AceRange(pos.row, pos.column, pos.row, pos.column);\n          context.replacingToken = false;\n        }\n        break;\n    }\n\n    context.textBoxPosition = { row: context.rangeToReplace.start.row, column: context.rangeToReplace.start.column };\n\n    switch (context.autoCompleteType) {\n      case \"path\":\n        addPathPrefixSuffixToContext(context);\n        break;\n      case \"url_params\":\n        addUrlParamsPrefixSuffixToContext(context);\n        break;\n      case \"method\":\n        addMethodPrefixSuffixToContext(context);\n        break;\n      case \"body\":\n        addBodyPrefixSuffixToContext(context);\n        break;\n    }\n  }\n\n  function addBodyPrefixSuffixToContext(context) {\n    // Figure out what happens next to the token to see whether it needs trailing commas etc.\n\n    // Templates will be used if not destroying existing structure.\n    // -> token : {} or token ]/} or token , but not token : SOMETHING ELSE\n\n    context.prefixToAdd = \"\";\n    context.suffixToAdd = \"\";\n\n    var tokenIter = editor.iterForCurrentLoc();\n    var nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);\n    switch (nonEmptyToken ? nonEmptyToken.type : \"NOTOKEN\") {\n      case \"NOTOKEN\":\n      case \"paren.lparen\":\n      case \"paren.rparen\":\n      case \"punctuation.comma\":\n        context.addTemplate = true;\n        break;\n      case \"punctuation.colon\":\n        // test if there is an empty object - if so we replace it\n        context.addTemplate = false;\n\n        nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);\n        if (!(nonEmptyToken && nonEmptyToken.value == \"{\")) {\n          break;\n        }\n        nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);\n        if (!(nonEmptyToken && nonEmptyToken.value == \"}\")) {\n          break;\n        }\n        context.addTemplate = true;\n        // extend range to replace to include all up to token\n        context.rangeToReplace.end.row = tokenIter.getCurrentTokenRow();\n        context.rangeToReplace.end.column = tokenIter.getCurrentTokenColumn() + nonEmptyToken.value.length;\n\n        // move one more time to check if we need a trailing comma\n        nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);\n        switch (nonEmptyToken ? nonEmptyToken.type : \"NOTOKEN\") {\n          case \"NOTOKEN\":\n          case \"paren.rparen\":\n          case \"punctuation.comma\":\n          case \"punctuation.colon\":\n            break;\n          default:\n            context.suffixToAdd = \", \";\n        }\n\n        break;\n      default:\n        context.addTemplate = true;\n        context.suffixToAdd = \", \";\n        break; // for now play safe and do nothing. May be made smarter.\n    }\n\n    // go back to see whether we have one of ( : { & [ do not require a comma. All the rest do.\n    tokenIter = editor.iterForCurrentLoc();\n    nonEmptyToken = tokenIter.getCurrentToken();\n    var insertingRelativeToToken; // -1 is before token, 0 middle, +1 after token\n    if (context.replacingToken) {\n      insertingRelativeToToken = 0;\n    } else {\n      var pos = editor.getCursorPosition();\n      if (pos.column == context.updatedForToken.start) {\n        insertingRelativeToToken = -1;\n      } else if (pos.column < context.updatedForToken.start + context.updatedForToken.value.length) {\n        insertingRelativeToToken = 0;\n      } else {\n        insertingRelativeToToken = 1;\n      }\n    }\n    // we should actually look at what's happening before this token\n    if (editor.parser.isEmptyToken(nonEmptyToken) || insertingRelativeToToken <= 0) {\n      nonEmptyToken = editor.parser.prevNonEmptyToken(tokenIter);\n    }\n\n    switch (nonEmptyToken ? nonEmptyToken.type : \"NOTOKEN\") {\n      case \"NOTOKEN\":\n      case \"paren.lparen\":\n      case \"punctuation.comma\":\n      case \"punctuation.colon\":\n      case \"method\":\n        break;\n      default:\n        if (nonEmptyToken && nonEmptyToken.type.indexOf(\"url\") < 0) {\n          context.prefixToAdd = \", \";\n        }\n    }\n\n    return context;\n  }\n\n  function addUrlParamsPrefixSuffixToContext(context) {\n    context.prefixToAdd = \"\";\n    context.suffixToAdd = \"\";\n  }\n\n  function addMethodPrefixSuffixToContext(context) {\n    context.prefixToAdd = \"\";\n    context.suffixToAdd = \"\";\n    var tokenIter = editor.iterForCurrentLoc();\n    var row = tokenIter.getCurrentTokenRow();\n    var t = editor.parser.nextNonEmptyToken(tokenIter);\n\n    if (tokenIter.getCurrentTokenRow() != row || !t) {\n      // we still have nothing next to the method, add a space..\n      context.suffixToAdd = \" \";\n    }\n  }\n\n  function addPathPrefixSuffixToContext(context) {\n    context.prefixToAdd = \"\";\n    context.suffixToAdd = \"\";\n  }\n\n  function addMethodAutoCompleteSetToContext(context) {\n    context.autoCompleteSet = [\"GET\", \"PUT\", \"POST\", \"DELETE\", \"HEAD\"].map(function (m, i) {\n      return {\n        name: m,\n        score: -i,\n        meta: 'method'\n      };\n    });\n  }\n\n  function addPathAutoCompleteSetToContext(context, pos) {\n    var ret = getCurrentMethodAndTokenPaths(pos);\n    context.method = ret.method;\n    context.token = ret.token;\n    context.otherTokenValues = ret.otherTokenValues;\n    context.urlTokenPath = ret.urlTokenPath;\n    (0, _engine.populateContext)(ret.urlTokenPath, context, editor, true, (0, _kb.getTopLevelUrlCompleteComponents)());\n    context.autoCompleteSet = addMetaToTermsList(context.autoCompleteSet, \"endpoint\");\n  }\n\n  function addUrlParamsAutoCompleteSetToContext(context, pos) {\n    var ret = getCurrentMethodAndTokenPaths(pos);\n    context.method = ret.method;\n    context.otherTokenValues = ret.otherTokenValues;\n    context.urlTokenPath = ret.urlTokenPath;\n    if (!ret.urlTokenPath) {\n      // zero length tokenPath is true\n\n      console.log(\"Can't extract a valid url token path.\");\n      return context;\n    }\n\n    (0, _engine.populateContext)(ret.urlTokenPath, context, editor, false, (0, _kb.getTopLevelUrlCompleteComponents)());\n\n    if (!context.endpoint) {\n      console.log(\"couldn't resolve an endpoint.\");\n      return context;\n    }\n\n    if (!ret.urlParamsTokenPath) {\n      // zero length tokenPath is true\n      console.log(\"Can't extract a valid urlParams token path.\");\n      return context;\n    }\n    var tokenPath = [],\n        currentParam = ret.urlParamsTokenPath.pop();\n    if (currentParam) {\n      tokenPath = Object.keys(currentParam); // single key object\n      context.otherTokenValues = currentParam[tokenPath[0]];\n    }\n\n    (0, _engine.populateContext)(tokenPath, context, editor, true, context.endpoint.paramsAutocomplete.getTopLevelComponents());\n    return context;\n  }\n\n  function addBodyAutoCompleteSetToContext(context, pos) {\n\n    var ret = getCurrentMethodAndTokenPaths(pos);\n    context.method = ret.method;\n    context.otherTokenValues = ret.otherTokenValues;\n    context.urlTokenPath = ret.urlTokenPath;\n    context.requestStartRow = ret.requestStartRow;\n    if (!ret.urlTokenPath) {\n      // zero length tokenPath is true\n      console.log(\"Can't extract a valid url token path.\");\n      return context;\n    }\n\n    (0, _engine.populateContext)(ret.urlTokenPath, context, editor, false, (0, _kb.getTopLevelUrlCompleteComponents)());\n\n    context.bodyTokenPath = ret.bodyTokenPath;\n    if (!ret.bodyTokenPath) {\n      // zero length tokenPath is true\n\n      console.log(\"Can't extract a valid body token path.\");\n      return context;\n    }\n\n    // needed for scope linking + global term resolving\n    context.endpointComponentResolver = _kb.getEndpointBodyCompleteComponents;\n    context.globalComponentResolver = _kb.getGlobalAutocompleteComponents;\n    var components;\n    if (context.endpoint) {\n      components = context.endpoint.bodyAutocompleteRootComponents;\n    } else {\n      components = (0, _kb.getUnmatchedEndpointComponents)();\n    }\n    (0, _engine.populateContext)(ret.bodyTokenPath, context, editor, true, components);\n\n    return context;\n  }\n\n  function getCurrentMethodAndTokenPaths(pos) {\n    var tokenIter = editor.iterForPosition(pos.row, pos.column);\n    var startPos = pos;\n    var bodyTokenPath = [],\n        ret = {};\n\n    var STATES = {\n      looking_for_key: 0, // looking for a key but without jumping over anything but white space and colon.\n      looking_for_scope_start: 1, // skip everything until scope start\n      start: 3\n    };\n    var state = STATES.start;\n\n    // initialization problems -\n    var t = tokenIter.getCurrentToken();\n    if (t) {\n      if (startPos.column == 0) {\n        // if we are at the beginning of the line, the current token is the one after cursor, not before which\n        // deviates from the standard.\n        t = tokenIter.stepBackward();\n        state = STATES.looking_for_scope_start;\n      }\n    } else {\n      if (startPos.column == 0) {\n        // empty lines do no have tokens, move one back\n        t = tokenIter.stepBackward();\n        state = STATES.start;\n      }\n    }\n\n    var walkedSomeBody = false;\n\n    // climb one scope at a time and get the scope key\n    for (; t && t.type.indexOf(\"url\") == -1 && t.type != \"method\"; t = tokenIter.stepBackward()) {\n\n      if (t.type != \"whitespace\") {\n        walkedSomeBody = true;\n      } // marks we saw something\n\n      switch (t.type) {\n        case \"variable\":\n          if (state == STATES.looking_for_key) {\n            bodyTokenPath.unshift(t.value.trim().replace(/\"/g, ''));\n          }\n          state = STATES.looking_for_scope_start; // skip everything until the beginning of this scope\n          break;\n\n        case \"paren.lparen\":\n          bodyTokenPath.unshift(t.value);\n          if (state == STATES.looking_for_scope_start) {\n            // found it. go look for the relevant key\n            state = STATES.looking_for_key;\n          }\n          break;\n        case \"paren.rparen\":\n          // reset he search for key\n          state = STATES.looking_for_scope_start;\n          // and ignore this sub scope..\n          var parenCount = 1;\n          t = tokenIter.stepBackward();\n          while (t && parenCount > 0) {\n            switch (t.type) {\n              case \"paren.lparen\":\n                parenCount--;\n                break;\n              case \"paren.rparen\":\n                parenCount++;\n                break;\n            }\n            if (parenCount > 0) {\n              t = tokenIter.stepBackward();\n            }\n          }\n          if (!t) // oops we run out.. we don't know what's up return null;\n            {\n              return {};\n            }\n          continue;\n        case \"punctuation.end_triple_quote\":\n          // reset the search for key\n          state = STATES.looking_for_scope_start;\n          for (t = tokenIter.stepBackward(); t; t = tokenIter.stepBackward()) {\n            if (t.type === \"punctuation.start_tripple_qoute\") {\n              t = tokenIter.stepBackward();\n              break;\n            }\n          }\n          if (!t) // oops we run out.. we don't know what's up return null;\n            {\n              return {};\n            }\n          continue;\n        case \"punctuation.start_triple_quote\":\n          if (state == STATES.start) {\n            state = STATES.looking_for_key;\n          } else if (state == STATES.looking_for_key) {\n            state = STATES.looking_for_scope_start;\n          }\n          bodyTokenPath.unshift('\"\"\"');\n          continue;\n        case \"string\":\n        case \"constant.numeric\":\n        case \"constant.language.boolean\":\n        case \"text\":\n          if (state == STATES.start) {\n            state = STATES.looking_for_key;\n          } else if (state == STATES.looking_for_key) {\n            state = STATES.looking_for_scope_start;\n          }\n\n          break;\n        case \"punctuation.comma\":\n          if (state == STATES.start) {\n            state = STATES.looking_for_scope_start;\n          }\n          break;\n        case \"punctuation.colon\":\n        case \"whitespace\":\n          if (state == STATES.start) {\n            state = STATES.looking_for_key;\n          }\n          break; // skip white space\n\n      }\n    }\n\n    if (walkedSomeBody && (!bodyTokenPath || bodyTokenPath.length == 0)) {\n      // we had some content and still no path -> the cursor is position after a closed body -> no auto complete\n      return {};\n    }\n\n    if (tokenIter.getCurrentTokenRow() == startPos.row) {\n      if (t.type === \"url.part\" || t.type === \"url.param\" || t.type === \"url.value\") {\n        // we are on the same line as cursor and dealing with a url. Current token is not part of the context\n        t = tokenIter.stepBackward();\n      }\n      bodyTokenPath = null; // no not on a body line.\n    }\n\n    ret.bodyTokenPath = bodyTokenPath;\n    ret.urlTokenPath = [];\n    ret.urlParamsTokenPath = null;\n    ret.requestStartRow = tokenIter.getCurrentTokenRow();\n    var curUrlPart;\n\n    while (t && isUrlParamsToken(t)) {\n      switch (t.type) {\n        case \"url.value\":\n          if (Array.isArray(curUrlPart)) {\n            curUrlPart.unshift(t.value);\n          } else if (curUrlPart) {\n            curUrlPart = [t.value, curUrlPart];\n          } else {\n            curUrlPart = t.value;\n          }\n          break;\n        case \"url.comma\":\n          if (!curUrlPart) {\n            curUrlPart = [];\n          } else if (!Array.isArray(curUrlPart)) {\n            curUrlPart = [curUrlPart];\n          }\n          break;\n        case \"url.param\":\n          var v = curUrlPart;\n          curUrlPart = {};\n          curUrlPart[t.value] = v;\n          break;\n        case \"url.amp\":\n        case \"url.questionmark\":\n          if (!ret.urlParamsTokenPath) {\n            ret.urlParamsTokenPath = [];\n          }\n          ret.urlParamsTokenPath.unshift(curUrlPart || {});\n          curUrlPart = null;\n          break;\n      }\n      t = tokenIter.stepBackward();\n    }\n\n    curUrlPart = null;\n    while (t && t.type.indexOf(\"url\") != -1) {\n      switch (t.type) {\n        case \"url.part\":\n          if (Array.isArray(curUrlPart)) {\n            curUrlPart.unshift(t.value);\n          } else if (curUrlPart) {\n            curUrlPart = [t.value, curUrlPart];\n          } else {\n            curUrlPart = t.value;\n          }\n          break;\n        case \"url.comma\":\n          if (!curUrlPart) {\n            curUrlPart = [];\n          } else if (!Array.isArray(curUrlPart)) {\n            curUrlPart = [curUrlPart];\n          }\n          break;\n        case \"url.slash\":\n          ret.urlTokenPath.unshift(curUrlPart);\n          curUrlPart = null;\n          break;\n      }\n      t = editor.parser.prevNonEmptyToken(tokenIter);\n    }\n\n    if (curUrlPart) {\n      ret.urlTokenPath.unshift(curUrlPart);\n    }\n\n    if (!ret.bodyTokenPath && !ret.urlParamsTokenPath) {\n\n      if (ret.urlTokenPath.length > 0) {\n        // started on the url, first token is current token\n        ret.otherTokenValues = ret.urlTokenPath.splice(-1)[0];\n      }\n    } else {\n      // mark the url as completed.\n      ret.urlTokenPath.push(_url_pattern_matcher.URL_PATH_END_MARKER);\n    }\n\n    if (t && t.type == \"method\") {\n      ret.method = t.value;\n    }\n    return ret;\n  }\n\n  var evaluateCurrentTokenAfterAChange = _lodash2.default.debounce(function evaluateCurrentTokenAfterAChange(pos) {\n    var session = editor.getSession();\n    var currentToken = session.getTokenAt(pos.row, pos.column);\n\n    if (!currentToken) {\n      if (pos.row == 0) {\n        LAST_EVALUATED_TOKEN = null;\n        return;\n      }\n      currentToken = { start: 0, value: \"\" }; // empty row\n    }\n\n    currentToken.row = pos.row; // extend token with row. Ace doesn't supply it by default\n    if (editor.parser.isEmptyToken(currentToken)) {\n      // empty token. check what's coming next\n      var nextToken = session.getTokenAt(pos.row, pos.column + 1);\n      if (editor.parser.isEmptyToken(nextToken)) {\n        // Empty line, or we're not on the edge of current token. Save the current position as base\n        currentToken.start = pos.column;\n        LAST_EVALUATED_TOKEN = currentToken;\n      } else {\n        nextToken.row = pos.row;\n        LAST_EVALUATED_TOKEN = nextToken;\n      }\n      return;\n    }\n\n    if (!LAST_EVALUATED_TOKEN) {\n      LAST_EVALUATED_TOKEN = currentToken;\n      return; // wait for the next typing.\n    }\n\n    if (LAST_EVALUATED_TOKEN.start != currentToken.start || LAST_EVALUATED_TOKEN.row != currentToken.row || LAST_EVALUATED_TOKEN.value === currentToken.value) {\n      // not on the same place or nothing changed, cache and wait for the next time\n      LAST_EVALUATED_TOKEN = currentToken;\n      return;\n    }\n\n    // don't automatically open the auto complete if some just hit enter (new line) or open a parentheses\n    switch (currentToken.type || \"UNKNOWN\") {\n      case \"paren.lparen\":\n      case \"paren.rparen\":\n      case \"punctuation.colon\":\n      case \"punctuation.comma\":\n      case \"UNKOWN\":\n        return;\n    }\n\n    LAST_EVALUATED_TOKEN = currentToken;\n    editor.execCommand(\"startAutocomplete\");\n  }, 100);\n\n  function editorChangeListener() {\n    var cursor = editor.selection.lead;\n    if (editor.__ace.completer && editor.__ace.completer.activated) {\n      return;\n    }\n    evaluateCurrentTokenAfterAChange(cursor);\n  }\n\n  function addChangeListener() {\n    editor.on(\"changeSelection\", editorChangeListener);\n  }\n\n  function removeChangeListener() {\n    editor.off(\"changeSelection\", editorChangeListener);\n  }\n\n  function getCompletions(aceEditor, session, pos, prefix, callback) {\n    try {\n\n      var context = getAutoCompleteContext(editor, session, pos);\n      if (!context) {\n        callback(null, []);\n      } else {\n        var terms = _lodash2.default.map(context.autoCompleteSet, function (term) {\n          if ((typeof term === 'undefined' ? 'undefined' : _typeof(term)) !== \"object\") {\n            term = {\n              name: term\n            };\n          } else {\n            term = _lodash2.default.clone(term);\n          }\n\n          return _lodash2.default.defaults(term, {\n            value: term.name,\n            meta: \"API\",\n            score: 0,\n            context: context,\n            completer: {\n              insertMatch: function insertMatch() {\n                applyTerm(term);\n              }\n            }\n          });\n        });\n\n        terms.sort(function (t1, t2) {\n          /* score sorts from high to low */\n          if (t1.score > t2.score) {\n            return -1;\n          }\n          if (t1.score < t2.score) {\n            return 1;\n          }\n          /* names sort from low to high */\n          if (t1.name < t2.name) {\n            return -1;\n          }\n          if (t1.name === t2.name) {\n            return 0;\n          }\n          return 1;\n        });\n\n        callback(null, _lodash2.default.map(terms, function (t, i) {\n          t.insert_value = t.insert_value || t.value;\n          t.value = '' + t.value; // normalize to strings\n          t.score = -i;\n          return t;\n        }));\n      }\n    } catch (e) {\n      console.log(\"error while getting completion terms\", e);\n      callback(e, null);\n    }\n  }\n\n  addChangeListener();\n\n  // Hook into Ace\n\n  // disable standard context based autocompletion.\n  _ace2.default.define('ace/autocomplete/text_completer', ['require', 'exports', 'module'], function (require, exports) {\n    exports.getCompletions = function (editor, session, pos, prefix, callback) {\n      callback(null, []);\n    };\n  });\n\n  var langTools = _ace2.default.require('ace/ext/language_tools');\n  var aceUtils = _ace2.default.require('ace/autocomplete/util');\n  var aceAutoComplete = _ace2.default.require('ace/autocomplete');\n\n  langTools.addCompleter({\n    getCompletions: getCompletions\n  });\n\n  editor.setOptions({\n    enableBasicAutocompletion: true\n  });\n\n  // Ace doesn't care about tokenization when calculating prefix. It will thus stop on . in keys names.\n  // we patch this behavior.\n  // CHECK ON ACE UPDATE\n  var aceAutoCompleteInstance = new aceAutoComplete.Autocomplete();\n  aceAutoCompleteInstance.autoInsert = false;\n  aceAutoCompleteInstance.gatherCompletions = function (ace_editor, callback) {\n    var session = ace_editor.getSession();\n    var pos = ace_editor.getCursorPosition();\n    var prefix = \"\";\n    // change starts here\n    var token = session.getTokenAt(pos.row, pos.column);\n    this.base = _lodash2.default.clone(pos);\n    if (!editor.parser.isEmptyToken(token) && !isSeparatorToken(token)) {\n      if (token.value.indexOf('\"') == 0) {\n        this.base.column = token.start + 1;\n      } else {\n        this.base.column = token.start;\n      }\n\n      prefix = getAutoCompleteValueFromToken(token);\n    }\n\n    var matches = [];\n    aceUtils.parForEach(ace_editor.completers, function (completer, next) {\n      completer.getCompletions(ace_editor, session, pos, prefix, function (err, results) {\n        if (!err) {\n          matches = matches.concat(results);\n        }\n        next();\n      });\n    }, function () {\n      callback(null, {\n        prefix: prefix,\n        matches: matches\n      });\n    });\n    return true;\n  };\n\n  editor.__ace.completer = aceAutoCompleteInstance;\n\n  return {\n    _test: {\n      getCompletions: getCompletions,\n      addReplacementInfoToContext: addReplacementInfoToContext,\n      addChangeListener: addChangeListener,\n      removeChangeListener: removeChangeListener\n    }\n  };\n};\n\nvar _kb = require('./kb');\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _engine = require('./autocomplete/engine');\n\nvar _url_pattern_matcher = require('./autocomplete/url_pattern_matcher');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _ace = require('ace');\n\nvar _ace2 = _interopRequireDefault(_ace);\n\nrequire('ace/ext-language_tools');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar AceRange = _ace2.default.require('ace/range').Range;\n\nvar LAST_EVALUATED_TOKEN = null;\n\nmodule.exports = exports['default'];",null]}