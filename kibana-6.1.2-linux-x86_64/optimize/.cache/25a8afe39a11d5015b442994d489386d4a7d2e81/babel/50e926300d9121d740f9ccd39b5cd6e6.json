{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/timelion/public/directives/timelion_expression_input.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/timelion/public/directives/timelion_expression_input.js","mtime":1515552031000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _pegjs = require('pegjs');\n\nvar _pegjs2 = _interopRequireDefault(_pegjs);\n\nvar _chain = require('raw-loader!../chain.peg');\n\nvar _chain2 = _interopRequireDefault(_chain);\n\nrequire('./timelion_expression_suggestions/timelion_expression_suggestions');\n\nvar _timelion_expression_input = require('./timelion_expression_input.html');\n\nvar _timelion_expression_input2 = _interopRequireDefault(_timelion_expression_input);\n\nvar _timelion_expression_input_helpers = require('./timelion_expression_input_helpers');\n\nvar _services = require('ui_framework/services');\n\nvar _arg_value_suggestions = require('./timelion_expression_suggestions/arg_value_suggestions');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Timelion Expression Autocompleter\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * This directive allows users to enter multiline timelion expressions. If the user has entered\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * a valid expression and then types a \".\", this directive will display a list of suggestions.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Users can navigate suggestions using the arrow keys. When a user selects a suggestion, it's\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * inserted into the expression and the caret position is updated to be inside of the newly-\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * added function's parentheses.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Beneath the hood, we use a PEG grammar to validate the Timelion expression and detect if\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * the caret is in a position within the expression that allows functions to be suggested.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * NOTE: This directive doesn't work well with contenteditable divs. Challenges include:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   - You have to replace markup with newline characters and spaces when passing the expression\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     to the grammar.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   - You have to do the opposite when loading a saved expression, so that it appears correctly\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     within the contenteditable (i.e. replace newlines with <br> markup).\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   - The Range and Selection APIs ignore newlines when providing caret position, so there is\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     literally no way to insert suggestions into the correct place in a multiline expression\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     that has more than a single consecutive newline.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\nvar Parser = _pegjs2.default.buildParser(_chain2.default);\nvar app = require('ui/modules').get('apps/timelion', []);\n\napp.directive('timelionExpressionInput', function ($document, $http, $interval, $timeout, Private) {\n  return {\n    restrict: 'E',\n    scope: {\n      rows: '=',\n      sheet: '=',\n      updateChart: '&',\n      shouldPopoverSuggestions: '@'\n    },\n    replace: true,\n    template: _timelion_expression_input2.default,\n    link: function link(scope, elem) {\n      var getSuggestions = function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n          var suggestions;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return (0, _timelion_expression_input_helpers.suggest)(scope.sheet, functionReference.list, Parser, getCursorPosition(), argValueSuggestions);\n\n                case 2:\n                  suggestions = _context.sent;\n\n\n                  // We're using ES6 Promises, not $q, so we have to wrap this in $apply.\n                  scope.$apply(function () {\n                    if (suggestions) {\n                      scope.suggestions.setList(suggestions.list, suggestions.type);\n                      scope.suggestions.show();\n                      suggestibleFunctionLocation = suggestions.location;\n                      $timeout(function () {\n                        var suggestionsList = (0, _jquery2.default)('[data-suggestions-list]');\n                        suggestionsList.scrollTop(0);\n                      }, 0);\n                      return;\n                    }\n\n                    suggestibleFunctionLocation = undefined;\n                    scope.suggestions.reset();\n                  });\n\n                case 4:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        return function getSuggestions() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var argValueSuggestions = Private(_arg_value_suggestions.ArgValueSuggestionsProvider);\n      var expressionInput = elem.find('[data-expression-input]');\n      var functionReference = {};\n      var suggestibleFunctionLocation = {};\n\n      scope.suggestions = new _timelion_expression_input_helpers.Suggestions();\n\n      function init() {\n        $http.get('../api/timelion/functions').then(function (resp) {\n          Object.assign(functionReference, {\n            byName: _lodash2.default.indexBy(resp.data, 'name'),\n            list: resp.data\n          });\n        });\n      }\n\n      function setCaretOffset(caretOffset) {\n        // Wait for Angular to update the input with the new expression and *then* we can set\n        // the caret position.\n        $timeout(function () {\n          expressionInput.focus();\n          expressionInput[0].selectionStart = expressionInput[0].selectionEnd = caretOffset;\n          scope.$apply();\n        }, 0);\n      }\n\n      function insertSuggestionIntoExpression(suggestionIndex) {\n        if (scope.suggestions.isEmpty()) {\n          return;\n        }\n\n        var _suggestibleFunctionL = suggestibleFunctionLocation,\n            min = _suggestibleFunctionL.min,\n            max = _suggestibleFunctionL.max;\n\n        var insertedValue = void 0;\n        var insertPositionMinOffset = 0;\n\n        switch (scope.suggestions.type) {\n          case _timelion_expression_input_helpers.SUGGESTION_TYPE.FUNCTIONS:\n            {\n              // Position the caret inside of the function parentheses.\n              insertedValue = scope.suggestions.list[suggestionIndex].name + '()';\n\n              // min advanced one to not replace function '.'\n              insertPositionMinOffset = 1;\n              break;\n            }\n          case _timelion_expression_input_helpers.SUGGESTION_TYPE.ARGUMENTS:\n            {\n              // Position the caret after the '='\n              insertedValue = scope.suggestions.list[suggestionIndex].name + '=';\n              break;\n            }\n          case _timelion_expression_input_helpers.SUGGESTION_TYPE.ARGUMENT_VALUE:\n            {\n              // Position the caret after the argument value\n              insertedValue = '' + scope.suggestions.list[suggestionIndex].name;\n              break;\n            }\n        }\n\n        var updatedExpression = (0, _timelion_expression_input_helpers.insertAtLocation)(insertedValue, scope.sheet, min + insertPositionMinOffset, max);\n        scope.sheet = updatedExpression;\n\n        var newCaretOffset = min + insertedValue.length;\n        setCaretOffset(newCaretOffset);\n      }\n\n      function scrollToSuggestionAt(index) {\n        // We don't cache these because the list changes based on user input.\n        var suggestionsList = (0, _jquery2.default)('[data-suggestions-list]');\n        var suggestionListItem = (0, _jquery2.default)('[data-suggestion-list-item]')[index];\n        // Scroll to the position of the item relative to the list, not to the window.\n        suggestionsList.scrollTop(suggestionListItem.offsetTop - suggestionsList[0].offsetTop);\n      }\n\n      function getCursorPosition() {\n        if (expressionInput.length) {\n          return expressionInput[0].selectionStart;\n        }\n        return null;\n      }\n\n      function isNavigationalKey(keyCode) {\n        var keyCodes = _lodash2.default.values(_services.comboBoxKeyCodes);\n        return keyCodes.includes(keyCode);\n      }\n\n      scope.onFocusInput = function () {\n        // Wait for the caret position of the input to update and then we can get suggestions\n        // (which depends on the caret position).\n        $timeout(getSuggestions, 0);\n      };\n\n      scope.onBlurInput = function () {\n        scope.suggestions.hide();\n      };\n\n      scope.onKeyDownInput = function (e) {\n        // If we've pressed any non-navigational keys, then the user has typed something and we\n        // can exit early without doing any navigation. The keyup handler will pull up suggestions.\n        if (!isNavigationalKey(e.keyCode)) {\n          return;\n        }\n\n        switch (e.keyCode) {\n          case _services.comboBoxKeyCodes.UP:\n            if (scope.suggestions.isVisible) {\n              // Up and down keys navigate through suggestions.\n              e.preventDefault();\n              scope.suggestions.stepForward();\n              scrollToSuggestionAt(scope.suggestions.index);\n            }\n            break;\n\n          case _services.comboBoxKeyCodes.DOWN:\n            if (scope.suggestions.isVisible) {\n              // Up and down keys navigate through suggestions.\n              e.preventDefault();\n              scope.suggestions.stepBackward();\n              scrollToSuggestionAt(scope.suggestions.index);\n            }\n            break;\n\n          case _services.comboBoxKeyCodes.TAB:\n            // If there are no suggestions or none is selected, the user tabs to the next input.\n            if (scope.suggestions.isEmpty() || scope.suggestions.index < 0) {\n              // Before letting the tab be handled to focus the next element\n              // we need to hide the suggestions, otherwise it will focus these\n              // instead of the time interval select.\n              scope.suggestions.hide();\n              return;\n            }\n\n            // If we have suggestions, complete the selected one.\n            e.preventDefault();\n            insertSuggestionIntoExpression(scope.suggestions.index);\n            break;\n\n          case _services.comboBoxKeyCodes.ENTER:\n            if (e.metaKey || e.ctrlKey) {\n              // Re-render the chart when the user hits CMD+ENTER.\n              e.preventDefault();\n              scope.updateChart();\n            } else if (!scope.suggestions.isEmpty()) {\n              // If the suggestions are open, complete the expression with the suggestion.\n              e.preventDefault();\n              insertSuggestionIntoExpression(scope.suggestions.index);\n            }\n            break;\n\n          case _services.comboBoxKeyCodes.ESCAPE:\n            e.preventDefault();\n            scope.suggestions.hide();\n            break;\n        }\n      };\n\n      scope.onKeyUpInput = function (e) {\n        // If the user isn't navigating, then we should update the suggestions based on their input.\n        if (!isNavigationalKey(e.keyCode)) {\n          getSuggestions();\n        }\n      };\n\n      scope.onClickExpression = function () {\n        getSuggestions();\n      };\n\n      scope.onClickSuggestion = function (index) {\n        insertSuggestionIntoExpression(index);\n      };\n\n      scope.getActiveSuggestionId = function () {\n        if (scope.suggestions.isVisible && scope.suggestions.index > -1) {\n          return 'timelionSuggestion' + scope.suggestions.index;\n        }\n        return '';\n      };\n\n      init();\n    }\n  };\n});",null]}