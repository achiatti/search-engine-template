{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/call_client.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/call_client.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallClientProvider = CallClientProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _error_allow_explicit_index = require('ui/error_allow_explicit_index');\n\nvar _is_request = require('./is_request');\n\nvar _merge_duplicate_requests = require('./merge_duplicate_requests');\n\nvar _req_status = require('./req_status');\n\nvar _request_fetch_params_to_body_provider = require('./request/request_fetch_params_to_body_provider');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction CallClientProvider(Private, Promise, es) {\n  var errorAllowExplicitIndex = Private(_error_allow_explicit_index.ErrorAllowExplicitIndexProvider);\n  var isRequest = Private(_is_request.IsRequestProvider);\n  var mergeDuplicateRequests = Private(_merge_duplicate_requests.MergeDuplicatesRequestProvider);\n  var requestFetchParamsToBody = Private(_request_fetch_params_to_body_provider.RequestFetchParamsToBodyProvider);\n\n  var ABORTED = _req_status.RequestStatus.ABORTED;\n  var DUPLICATE = _req_status.RequestStatus.DUPLICATE;\n\n  function callClient(requests) {\n    // merging docs can change status to DUPLICATE, capture new statuses\n    var statuses = mergeDuplicateRequests(requests);\n\n    // get the actual list of requests that we will be fetching\n    var requestsToFetch = statuses.filter(isRequest);\n    var execCount = requestsToFetch.length;\n\n    if (!execCount) return Promise.resolve([]);\n\n    // resolved by respond()\n    var esPromise = void 0;\n    var defer = Promise.defer();\n\n    // for each respond with either the response or ABORTED\n    var respond = function respond(responses) {\n      responses = responses || [];\n      return Promise.map(requests, function (request, i) {\n        switch (statuses[i]) {\n          case ABORTED:\n            return ABORTED;\n          case DUPLICATE:\n            return request._uniq.resp;\n          default:\n            var index = _lodash2.default.findIndex(requestsToFetch, request);\n            if (index < 0) {\n              // This means the request failed.\n              return ABORTED;\n            }\n            return responses[index];\n        }\n      }).then(function (res) {\n        return defer.resolve(res);\n      }, function (err) {\n        return defer.reject(err);\n      });\n    };\n\n    // handle a request being aborted while being fetched\n    var requestWasAborted = Promise.method(function (req, i) {\n      if (statuses[i] === ABORTED) {\n        defer.reject(new Error('Request was aborted twice?'));\n      }\n\n      execCount -= 1;\n      if (execCount > 0) {\n        // the multi-request still contains other requests\n        return;\n      }\n\n      if (esPromise && _lodash2.default.isFunction(esPromise.abort)) {\n        esPromise.abort();\n      }\n\n      esPromise = ABORTED;\n\n      return respond();\n    });\n\n    // attach abort handlers, close over request index\n    statuses.forEach(function (req, i) {\n      if (!isRequest(req)) return;\n      req.whenAborted(function () {\n        requestWasAborted(req, i).catch(defer.reject);\n      });\n    });\n\n    // Now that all of THAT^^^ is out of the way, lets actually\n    // call out to elasticsearch\n    Promise.map(requestsToFetch, function (request) {\n      return Promise.try(request.getFetchParams, void 0, request).then(function (fetchParams) {\n        return request.fetchParams = fetchParams;\n      }).then(function (value) {\n        return { resolved: value };\n      }).catch(function (error) {\n        return { rejected: error };\n      });\n    }).then(function (results) {\n      var requestsWithFetchParams = [];\n      // Gather the fetch param responses from all the successful requests.\n      results.forEach(function (result, index) {\n        if (result.resolved) {\n          requestsWithFetchParams.push(result.resolved);\n        } else {\n          var request = requestsToFetch[index];\n          request.handleFailure(result.rejected);\n          requestsToFetch[index] = undefined;\n        }\n      });\n      // The index of the request inside requestsToFetch determines which response is mapped to it. If a request\n      // won't generate a response, since it already failed, we need to remove the request\n      // from the requestsToFetch array so the indexes will continue to match up to the responses correctly.\n      requestsToFetch = requestsToFetch.filter(function (request) {\n        return request !== undefined;\n      });\n      return requestFetchParamsToBody(requestsWithFetchParams);\n    }).then(function (body) {\n      // while the strategy was converting, our request was aborted\n      if (esPromise === ABORTED) {\n        throw ABORTED;\n      }\n\n      return esPromise = es.msearch({ body: body });\n    }).then(function (clientResponse) {\n      return respond(clientResponse.responses);\n    }).catch(function (error) {\n      if (errorAllowExplicitIndex.test(error)) {\n        return errorAllowExplicitIndex.takeover();\n      }\n\n      if (error === ABORTED) respond();else defer.reject(error);\n    });\n\n    // return our promise, but catch any errors we create and\n    // send them to the requests\n    return defer.promise.catch(function (err) {\n      requests.forEach(function (req, i) {\n        if (statuses[i] !== ABORTED) {\n          req.handleFailure(err);\n        }\n      });\n    });\n  }\n\n  return callClient;\n}",null]}