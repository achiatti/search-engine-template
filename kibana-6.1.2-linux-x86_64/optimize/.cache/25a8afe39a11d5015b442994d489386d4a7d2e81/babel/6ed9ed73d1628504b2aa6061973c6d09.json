{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_response/tabify/_response_writer.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/agg_response/tabify/_response_writer.js","mtime":1515552033000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TabbedAggResponseWriterProvider = TabbedAggResponseWriterProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _agg_config_result = require('ui/vis/agg_config_result');\n\nvar _agg_config_result2 = _interopRequireDefault(_agg_config_result);\n\nvar _table = require('ui/agg_response/tabify/_table');\n\nvar _table_group = require('ui/agg_response/tabify/_table_group');\n\nvar _get_columns = require('ui/agg_response/tabify/_get_columns');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction TabbedAggResponseWriterProvider(Private) {\n  var Table = Private(_table.AggResponseTabifyTableProvider);\n  var TableGroup = Private(_table_group.AggResponseTabifyTableGroupProvider);\n  var getColumns = Private(_get_columns.AggResponseGetColumnsProvider);\n\n  _lodash2.default.class(SplitAcr).inherits(_agg_config_result2.default);\n  function SplitAcr(agg, parent, key) {\n    SplitAcr.Super.call(this, agg, parent, key, key);\n  }\n\n  /**\n   * Writer class that collects information about an aggregation response and\n   * produces a table, or a series of tables.\n   *\n   * @param {Vis} vis - the vis object to which the aggregation response correlates\n   */\n  function TabbedAggResponseWriter(vis, opts) {\n    this.vis = vis;\n    this.opts = opts || {};\n    this.rowBuffer = [];\n\n    var visIsHier = vis.isHierarchical();\n\n    // do the options allow for splitting? we will only split if true and\n    // tabify calls the split method.\n    this.canSplit = this.opts.canSplit !== false;\n\n    // should we allow partial rows to be included in the tables? if a\n    // partial row is found, it is filled with empty strings ''\n    this.partialRows = this.opts.partialRows == null ? visIsHier : this.opts.partialRows;\n\n    // if true, we will not place metric columns after every bucket\n    // even if the vis is hierarchical. if false, and the vis is\n    // hierarchical, then we will display metric columns after\n    // every bucket col\n    this.minimalColumns = visIsHier ? !!this.opts.minimalColumns : true;\n\n    // true if we can expect metrics to have been calculated\n    // for every bucket\n    this.metricsForAllBuckets = visIsHier;\n\n    // if true, values will be wrapped in aggConfigResult objects which link them\n    // to their aggConfig and enable the filterbar and tooltip formatters\n    this.asAggConfigResults = !!this.opts.asAggConfigResults;\n\n    this.columns = getColumns(vis, this.minimalColumns);\n    this.aggStack = _lodash2.default.pluck(this.columns, 'aggConfig');\n\n    this.root = new TableGroup();\n    this.acrStack = [];\n    this.splitStack = [this.root];\n  }\n\n  /**\n   * Create a Table of TableGroup object, link it to it's parent (if any), and determine if\n   * it's the root\n   *\n   * @param  {boolean} group - is this a TableGroup or just a normal Table\n   * @param  {AggConfig} agg - the aggregation that create this table, only applies to groups\n   * @param  {any} key - the bucketKey that this table relates to\n   * @return {Table/TableGroup} table - the created table\n   */\n  TabbedAggResponseWriter.prototype._table = function (group, agg, key) {\n    var Class = group ? TableGroup : Table;\n    var table = new Class();\n    var parent = this.splitStack[0];\n\n    if (group) {\n      table.aggConfig = agg;\n      table.key = key;\n      table.title = table.fieldFormatter()(key);\n      // aggs that don't implement makeLabel should not add to title\n      if (agg.makeLabel() !== agg.name) {\n        table.title += ': ' + agg.makeLabel();\n      }\n    }\n\n    // link the parent and child\n    table.$parent = parent;\n    parent.tables.push(table);\n\n    return table;\n  };\n\n  /**\n   * Enter into a split table, called for each bucket of a splitting agg. The new table\n   * is either created or located using the agg and key arguments, and then the block is\n   * executed with the table as it's this context. Within this function, you should\n   * walk into the remaining branches and end up writing some rows to the table.\n   *\n   * @param  {aggConfig} agg - the aggConfig that created this split\n   * @param  {Buckets} buckets - the buckets produces by the agg\n   * @param  {function} block - a function to execute for each sub bucket\n   */\n  TabbedAggResponseWriter.prototype.split = function (agg, buckets, block) {\n    var self = this;\n\n    if (!self.canSplit) {\n      throw new Error('attempted to split when splitting is disabled');\n    }\n\n    self._removeAggFromColumns(agg);\n\n    buckets.forEach(function (bucket, key) {\n      // find the existing split that we should extend\n      var tableGroup = _lodash2.default.find(self.splitStack[0].tables, { aggConfig: agg, key: key });\n      // create the split if it doesn't exist yet\n      if (!tableGroup) tableGroup = self._table(true, agg, key);\n\n      var splitAcr = false;\n      if (self.asAggConfigResults) {\n        splitAcr = self._injectParentSplit(agg, key);\n      }\n\n      // push the split onto the stack so that it will receive written tables\n      self.splitStack.unshift(tableGroup);\n\n      // call the block\n      if (_lodash2.default.isFunction(block)) block.call(self, bucket, key);\n\n      // remove the split from the stack\n      self.splitStack.shift();\n      splitAcr && _lodash2.default.pull(self.acrStack, splitAcr);\n    });\n  };\n\n  TabbedAggResponseWriter.prototype._removeAggFromColumns = function (agg) {\n    var i = _lodash2.default.findIndex(this.columns, function (col) {\n      return col.aggConfig === agg;\n    });\n\n    // we must have already removed this column\n    if (i === -1) return;\n\n    this.columns.splice(i, 1);\n\n    if (this.minimalColumns) return;\n\n    // hierarchical vis creats additional columns for each bucket\n    // we will remove those too\n    var mCol = this.columns.splice(i, 1).pop();\n    var mI = _lodash2.default.findIndex(this.aggStack, function (agg) {\n      return agg === mCol.aggConfig;\n    });\n\n    if (mI > -1) this.aggStack.splice(mI, 1);\n  };\n\n  /**\n   * When a split is found while building the aggConfigResult tree, we\n   * want to push the split into the tree at another point. Since each\n   * branch in the tree is a double-linked list we need do some special\n   * shit to pull this off.\n   *\n   * @private\n   * @param {AggConfig} - The agg which produced the split bucket\n   * @param {any} - The value which identifies the bucket\n   * @return {SplitAcr} - the AggConfigResult created for the split bucket\n   */\n  TabbedAggResponseWriter.prototype._injectParentSplit = function (agg, key) {\n    var oldList = this.acrStack;\n    var newList = this.acrStack = [];\n\n    // walk from right to left through the old stack\n    // and move things to the new stack\n    var injected = false;\n\n    if (!oldList.length) {\n      injected = new SplitAcr(agg, null, key);\n      newList.unshift(injected);\n      return injected;\n    }\n\n    // walk from right to left, emptying the previous list\n    while (oldList.length) {\n      var acr = oldList.pop();\n\n      // ignore other splits\n      if (acr instanceof SplitAcr) {\n        newList.unshift(acr);\n        continue;\n      }\n\n      // inject the split\n      if (!injected) {\n        injected = new SplitAcr(agg, newList[0], key);\n        newList.unshift(injected);\n      }\n\n      var newAcr = new _agg_config_result2.default(acr.aggConfig, newList[0], acr.value, acr.aggConfig.getKey(acr));\n      newList.unshift(newAcr);\n\n      // and replace the acr in the row buffer if its there\n      var rowI = this.rowBuffer.indexOf(acr);\n      if (rowI > -1) {\n        this.rowBuffer[rowI] = newAcr;\n      }\n    }\n\n    return injected;\n  };\n\n  /**\n   * Push a value into the row, then run a block. Once the block is\n   * complete the value is pulled from the stack.\n   *\n   * @param  {any} value - the value that should be added to the row\n   * @param  {function} block - the function to run while this value is in the row\n   * @return {any} - the value that was added\n   */\n  TabbedAggResponseWriter.prototype.cell = function (agg, value, block) {\n    if (this.asAggConfigResults) {\n      value = new _agg_config_result2.default(agg, this.acrStack[0], value, value);\n    }\n\n    var staskResult = this.asAggConfigResults && value.type === 'bucket';\n\n    this.rowBuffer.push(value);\n    if (staskResult) this.acrStack.unshift(value);\n\n    if (_lodash2.default.isFunction(block)) block.call(this);\n\n    this.rowBuffer.pop(value);\n    if (staskResult) this.acrStack.shift();\n\n    return value;\n  };\n\n  /**\n   * Create a new row by reading the row buffer. This will do nothing if\n   * the row is incomplete and the vis this data came from is NOT flagged as\n   * hierarchical.\n   *\n   * @param  {array} [buffer] - optional buffer to use in place of the stored rowBuffer\n   * @return {undefined}\n   */\n  TabbedAggResponseWriter.prototype.row = function (buffer) {\n    var cells = buffer || this.rowBuffer.slice(0);\n\n    if (!this.partialRows && cells.length < this.columns.length) {\n      return;\n    }\n\n    var split = this.splitStack[0];\n    var table = split.tables[0] || this._table(false);\n\n    while (cells.length < this.columns.length) {\n      cells.push('');\n    }table.rows.push(cells);\n    return table;\n  };\n\n  /**\n   * Get the actual response\n   *\n   * @return {object} - the final table-tree\n   */\n  TabbedAggResponseWriter.prototype.response = function () {\n    var columns = this.columns;\n\n    // give the columns some metadata\n    columns.map(function (col) {\n      col.title = col.aggConfig.makeLabel();\n    });\n\n    // walk the tree and write the columns to each table\n    (function step(table) {\n      if (table.tables) table.tables.forEach(step);else table.columns = columns.slice(0);\n    })(this.root);\n\n    if (this.canSplit) return this.root;\n\n    var table = this.root.tables[0];\n    if (!table) return;\n\n    delete table.$parent;\n    return table;\n  };\n\n  return TabbedAggResponseWriter;\n}",null]}