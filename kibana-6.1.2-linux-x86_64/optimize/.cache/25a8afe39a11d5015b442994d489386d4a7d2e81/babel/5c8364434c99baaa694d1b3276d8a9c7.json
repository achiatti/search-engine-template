{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/app.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/app.js","mtime":1515552026000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = init;\nvar $ = require('jquery');\n\nvar history = require('./history');\nvar mappings = require('./mappings');\n\nfunction init(input, output) {\n  var sourceLocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'stored';\n\n  $(document.body).removeClass('fouc');\n\n  // set the value of the input and clear the output\n  function resetToValues(content) {\n    if (content != null) {\n      input.update(content);\n    }\n    output.update(\"\");\n  }\n\n  function loadSavedState() {\n    var previousSaveState = history.getSavedEditorState();\n\n    if (sourceLocation == \"stored\") {\n      if (previousSaveState) {\n        resetToValues(previousSaveState.content);\n      } else {\n        resetToValues();\n        input.autoIndent();\n      }\n    } else if (/^https?:\\/\\//.test(sourceLocation)) {\n      var loadFrom = { url: sourceLocation, dataType: \"text\", kbnXsrfToken: false };\n      if (/https?:\\/\\/api.github.com/.test(sourceLocation)) {\n        loadFrom.headers = { Accept: \"application/vnd.github.v3.raw\" };\n      }\n      $.ajax(loadFrom).done(function (data) {\n        resetToValues(data);\n        input.moveToNextRequestEdge(true);\n        input.highlightCurrentRequestsAndUpdateActionBar();\n        input.updateActionsBar();\n      });\n    } else {\n      resetToValues();\n    }\n    input.moveToNextRequestEdge(true);\n  }\n\n  function setupAutosave() {\n    var timer;\n    var saveDelay = 500;\n\n    input.getSession().on(\"change\", function onChange() {\n      if (timer) {\n        timer = clearTimeout(timer);\n      }\n      timer = setTimeout(saveCurrentState, saveDelay);\n    });\n  }\n\n  function saveCurrentState() {\n    try {\n      var content = input.getValue();\n      history.updateCurrentState(content);\n    } catch (e) {\n      console.log(\"Ignoring saving error: \" + e);\n    }\n  }\n\n  // stupid simple restore function, called when the user\n  // chooses to restore a request from the history\n  // PREVENTS history from needing to know about the input\n  history.restoreFromHistory = function applyHistoryElem(req) {\n    var session = input.getSession();\n    var pos = input.getCursorPosition();\n    var prefix = \"\";\n    var suffix = \"\\n\";\n    if (input.parser.isStartRequestRow(pos.row)) {\n      pos.column = 0;\n      suffix += \"\\n\";\n    } else if (input.parser.isEndRequestRow(pos.row)) {\n      var line = session.getLine(pos.row);\n      pos.column = line.length;\n      prefix = \"\\n\\n\";\n    } else if (input.parser.isInBetweenRequestsRow(pos.row)) {\n      pos.column = 0;\n    } else {\n      pos = input.nextRequestEnd(pos);\n      prefix = \"\\n\\n\";\n    }\n\n    var s = prefix + req.method + \" \" + req.endpoint;\n    if (req.data) {\n      s += \"\\n\" + req.data;\n    }\n\n    s += suffix;\n\n    session.insert(pos, s);\n    input.clearSelection();\n    input.moveCursorTo(pos.row + prefix.length, 0);\n    input.focus();\n  };\n\n  loadSavedState();\n  setupAutosave();\n  mappings.startRetrievingAutoCompleteInfo();\n}\nmodule.exports = exports['default'];",null]}