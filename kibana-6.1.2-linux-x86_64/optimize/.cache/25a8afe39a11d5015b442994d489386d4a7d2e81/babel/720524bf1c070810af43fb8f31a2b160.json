{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/request/search_request.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/request/search_request.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.SearchRequestProvider = SearchRequestProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _request_queue = require('../../_request_queue');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction SearchRequestProvider(Promise) {\n\n  return function () {\n    function SearchRequest(source, defer) {\n      _classCallCheck(this, SearchRequest);\n\n      this.source = source;\n      this.defer = defer || Promise.defer();\n      this.abortedDefer = Promise.defer();\n      this.type = 'search';\n      _request_queue.requestQueue.push(this);\n    }\n\n    /**\n     *  Called by the loopers to find requests that should be sent to the\n     *  fetch() module. When a module is sent to fetch() it's _fetchRequested flag\n     *  is set, and this consults that flag so requests are not send to fetch()\n     *  multiple times.\n     *\n     *  @return {Boolean}\n     */\n\n\n    _createClass(SearchRequest, [{\n      key: 'canStart',\n      value: function canStart() {\n        return !this._fetchRequested && !this.stopped && !this.source._fetchDisabled;\n      }\n\n      /**\n       *  Used to find requests that were previously sent to the fetch() module but\n       *  have not been started yet, so they can be started.\n       *\n       *  @return {Boolean}\n       */\n\n    }, {\n      key: 'isFetchRequestedAndPending',\n      value: function isFetchRequestedAndPending() {\n        return this._fetchRequested && !this.started;\n      }\n\n      /**\n       *  Called by the fetch() module when this request has been sent to\n       *  be fetched. At that point the request is somewhere between `ready-to-start`\n       *  and `started`. The fetch module then waits a short period of time to\n       *  allow requests to build up in the request queue, and then immediately\n       *  fetches all requests that return true from `isFetchRequestedAndPending()`\n       *\n       *  @return {undefined}\n       */\n\n    }, {\n      key: '_setFetchRequested',\n      value: function _setFetchRequested() {\n        this._fetchRequested = true;\n      }\n    }, {\n      key: 'start',\n      value: function start() {\n        if (this.started) {\n          throw new TypeError('Unable to start request because it has already started');\n        }\n\n        this.started = true;\n        this.moment = (0, _moment2.default)();\n\n        return this.source.requestIsStarting(this);\n      }\n    }, {\n      key: 'getFetchParams',\n      value: function getFetchParams() {\n        return this.source._flatten();\n      }\n    }, {\n      key: 'filterError',\n      value: function filterError() {\n        return false;\n      }\n    }, {\n      key: 'handleResponse',\n      value: function handleResponse(resp) {\n        this.success = true;\n        this.resp = resp;\n      }\n    }, {\n      key: 'handleFailure',\n      value: function handleFailure(error) {\n        this.success = false;\n        this.resp = error && error.resp;\n        return this.errorHandler(this, error);\n      }\n    }, {\n      key: 'isIncomplete',\n      value: function isIncomplete() {\n        return false;\n      }\n    }, {\n      key: 'continue',\n      value: function _continue() {\n        throw new Error('Unable to continue ' + this.type + ' request');\n      }\n    }, {\n      key: 'retry',\n      value: function retry() {\n        var clone = this.clone();\n        this.abort();\n        return clone;\n      }\n    }, {\n      key: '_markStopped',\n      value: function _markStopped() {\n        if (this.stopped) return;\n        this.stopped = true;\n        this.source.requestIsStopped(this);\n        _lodash2.default.pull(_request_queue.requestQueue, this);\n      }\n    }, {\n      key: 'abort',\n      value: function abort() {\n        this._markStopped();\n        this.defer = null;\n        this.aborted = true;\n        this.abortedDefer.resolve();\n        this.abortedDefer = null;\n      }\n    }, {\n      key: 'whenAborted',\n      value: function whenAborted(cb) {\n        this.abortedDefer.promise.then(cb);\n      }\n    }, {\n      key: 'complete',\n      value: function complete() {\n        this._markStopped();\n        this.ms = this.moment.diff() * -1;\n        this.defer.resolve(this.resp);\n      }\n    }, {\n      key: 'getCompletePromise',\n      value: function getCompletePromise() {\n        return this.defer.promise;\n      }\n    }, {\n      key: 'getCompleteOrAbortedPromise',\n      value: function getCompleteOrAbortedPromise() {\n        return Promise.race([this.defer.promise, this.abortedDefer.promise]);\n      }\n    }, {\n      key: 'clone',\n      value: function clone() {\n        return new this.constructor(this.source, this.defer);\n      }\n    }, {\n      key: 'setErrorHandler',\n      value: function setErrorHandler(errorHandler) {\n        this.errorHandler = errorHandler;\n      }\n    }]);\n\n    return SearchRequest;\n  }();\n}",null]}