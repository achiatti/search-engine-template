{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/discover/controllers/discover.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/discover/controllers/discover.js","mtime":1515552028000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _get_sort = require('ui/doc_table/lib/get_sort');\n\nvar _columns = require('ui/doc_table/actions/columns');\n\nvar columnActions = _interopRequireWildcard(_columns);\n\nvar _filter = require('ui/doc_table/actions/filter');\n\nvar filterActions = _interopRequireWildcard(_filter);\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nrequire('ui/doc_table');\n\nrequire('ui/visualize');\n\nrequire('ui/notify');\n\nrequire('ui/fixed_scroll');\n\nrequire('ui/directives/validate_json');\n\nrequire('ui/filters/moment');\n\nrequire('ui/courier');\n\nrequire('ui/index_patterns');\n\nrequire('ui/state_management/app_state');\n\nrequire('ui/timefilter');\n\nrequire('ui/share');\n\nrequire('ui/query_bar');\n\nvar _vis = require('ui/vis');\n\nvar _basic = require('ui/vis/response_handlers/basic');\n\nvar _doc_title = require('ui/doc_title');\n\nvar _hit_sort_fn = require('plugins/kibana/discover/_hit_sort_fn');\n\nvar _hit_sort_fn2 = _interopRequireDefault(_hit_sort_fn);\n\nvar _query_filter = require('ui/filter_bar/query_filter');\n\nvar _interval_options = require('ui/agg_types/buckets/_interval_options');\n\nvar _state_monitor_factory = require('ui/state_management/state_monitor_factory');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _modules = require('ui/modules');\n\nvar _index = require('plugins/kibana/discover/index.html');\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _state = require('ui/state_management/state');\n\nvar _migrateLegacyQuery = require('ui/utils/migrateLegacyQuery');\n\nvar _filter_manager = require('ui/filter_manager');\n\nvar _saved_objects = require('ui/saved_objects');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nvar app = _modules.uiModules.get('apps/discover', ['kibana/notify', 'kibana/courier', 'kibana/index_patterns']);\n\n_routes2.default.defaults(/discover/, {\n  requireDefaultIndex: true\n}).when('/discover/:id?', {\n  template: _index2.default,\n  reloadOnSearch: false,\n  resolve: {\n    ip: function ip(Promise, courier, config, $location, Private) {\n      var State = Private(_state.StateProvider);\n      var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n\n      return savedObjectsClient.find({\n        type: 'index-pattern',\n        fields: ['title'],\n        perPage: 10000\n      }).then(function (_ref) {\n        var savedObjects = _ref.savedObjects;\n\n        /**\n        *  In making the indexPattern modifiable it was placed in appState. Unfortunately,\n        *  the load order of AppState conflicts with the load order of many other things\n        *  so in order to get the name of the index we should use, and to switch to the\n        *  default if necessary, we parse the appState with a temporary State object and\n        *  then destroy it immediatly after we're done\n        *\n        *  @type {State}\n        */\n        var state = new State('_a', {});\n\n        var specified = !!state.index;\n        var exists = _lodash2.default.findIndex(savedObjects, function (o) {\n          return o.id === state.index;\n        }) > -1;\n        var id = exists ? state.index : config.get('defaultIndex');\n        state.destroy();\n\n        return Promise.props({\n          list: savedObjects,\n          loaded: courier.indexPatterns.get(id),\n          stateVal: state.index,\n          stateValFound: specified && exists\n        });\n      });\n    },\n    savedSearch: function savedSearch(courier, savedSearches, $route) {\n      return savedSearches.get($route.current.params.id).catch(courier.redirectWhenMissing({\n        'search': '/discover',\n        'index-pattern': '/management/kibana/objects/savedSearches/' + $route.current.params.id\n      }));\n    }\n  }\n});\n\napp.directive('discoverApp', function () {\n  return {\n    restrict: 'E',\n    controllerAs: 'discoverApp',\n    controller: discoverController\n  };\n});\n\nfunction discoverController($element, $route, $scope, $timeout, $window, AppState, Notifier, Private, Promise, config, courier, kbnUrl, timefilter) {\n  var _this = this;\n\n  var Vis = Private(_vis.VisProvider);\n  var docTitle = Private(_doc_title.DocTitleProvider);\n  var HitSortFn = Private(_hit_sort_fn2.default);\n  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);\n  var responseHandler = Private(_basic.BasicResponseHandlerProvider).handler;\n  var filterManager = Private(_filter_manager.FilterManagerProvider);\n  var notify = new Notifier({\n    location: 'Discover'\n  });\n\n  $scope.intervalOptions = Private(_interval_options.AggTypesBucketsIntervalOptionsProvider);\n  $scope.showInterval = false;\n  $scope.minimumVisibleRows = 50;\n\n  $scope.intervalEnabled = function (interval) {\n    return interval.val !== 'custom';\n  };\n\n  $scope.topNavMenu = [{\n    key: 'new',\n    description: 'New Search',\n    run: function run() {\n      kbnUrl.change('/discover');\n    },\n    testId: 'discoverNewButton'\n  }, {\n    key: 'save',\n    description: 'Save Search',\n    template: require('plugins/kibana/discover/partials/save_search.html'),\n    testId: 'discoverSaveButton'\n  }, {\n    key: 'open',\n    description: 'Open Saved Search',\n    template: require('plugins/kibana/discover/partials/load_search.html'),\n    testId: 'discoverOpenButton'\n  }, {\n    key: 'share',\n    description: 'Share Search',\n    template: require('plugins/kibana/discover/partials/share_search.html'),\n    testId: 'discoverShareButton'\n  }];\n  $scope.timefilter = timefilter;\n\n  // the saved savedSearch\n  var savedSearch = $route.current.locals.savedSearch;\n  $scope.$on('$destroy', savedSearch.destroy);\n\n  // the actual courier.SearchSource\n  $scope.searchSource = savedSearch.searchSource;\n  $scope.indexPattern = resolveIndexPatternLoading();\n  $scope.searchSource.set('index', $scope.indexPattern).highlightAll(true).version(true);\n\n  var pageTitleSuffix = savedSearch.id && savedSearch.title ? ': ' + savedSearch.title : '';\n  docTitle.change('Discover' + pageTitleSuffix);\n\n  var stateMonitor = void 0;\n  var $appStatus = $scope.appStatus = this.appStatus = {\n    dirty: !savedSearch.id\n  };\n\n  var $state = $scope.state = new AppState(getStateDefaults());\n\n  var getFieldCounts = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if ($scope.fetchStatus) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt('return', $scope.fieldCounts);\n\n            case 2:\n              _context.next = 4;\n              return new Promise(function (resolve) {\n                var unwatch = $scope.$watch('fetchStatus', function (newValue) {\n                  if (newValue) {\n                    return;\n                  }\n\n                  unwatch();\n                  resolve($scope.fieldCounts);\n                });\n              });\n\n            case 4:\n              return _context.abrupt('return', _context.sent);\n\n            case 5:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, _this);\n    }));\n\n    return function getFieldCounts() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var getSharingDataFields = function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n      var selectedFields, fieldCounts, timeFieldName, fields;\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              selectedFields = $state.columns;\n\n              if (!(selectedFields.length === 1 && selectedFields[0] === '_source')) {\n                _context2.next = 6;\n                break;\n              }\n\n              _context2.next = 4;\n              return getFieldCounts();\n\n            case 4:\n              fieldCounts = _context2.sent;\n              return _context2.abrupt('return', {\n                searchFields: null,\n                selectFields: _lodash2.default.keys(fieldCounts).sort()\n              });\n\n            case 6:\n              timeFieldName = $scope.indexPattern.timeFieldName;\n              fields = timeFieldName ? [timeFieldName].concat(_toConsumableArray(selectedFields)) : selectedFields;\n              return _context2.abrupt('return', {\n                searchFields: fields,\n                selectFields: fields\n              });\n\n            case 9:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, _this);\n    }));\n\n    return function getSharingDataFields() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  this.getSharingData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n    var searchSource, _ref5, searchFields, selectFields, body;\n\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            searchSource = $scope.searchSource.clone();\n            _context3.next = 3;\n            return getSharingDataFields();\n\n          case 3:\n            _ref5 = _context3.sent;\n            searchFields = _ref5.searchFields;\n            selectFields = _ref5.selectFields;\n\n            searchSource.set('fields', searchFields);\n            searchSource.set('sort', (0, _get_sort.getSort)($state.sort, $scope.indexPattern));\n            searchSource.set('highlight', null);\n            searchSource.set('highlightAll', null);\n            searchSource.set('aggs', null);\n            searchSource.set('size', null);\n\n            _context3.next = 14;\n            return searchSource.getSearchRequestBody();\n\n          case 14:\n            body = _context3.sent;\n            return _context3.abrupt('return', {\n              searchRequest: {\n                index: searchSource.get('index').title,\n                body: body\n              },\n              fields: selectFields,\n              metaFields: $scope.indexPattern.metaFields,\n              conflictedTypesFields: $scope.indexPattern.fields.filter(function (f) {\n                return f.type === 'conflict';\n              }).map(function (f) {\n                return f.name;\n              }),\n              indexPatternId: searchSource.get('index').id\n            });\n\n          case 16:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, _this);\n  }));\n\n  this.getSharingType = function () {\n    return 'search';\n  };\n\n  this.getSharingTitle = function () {\n    return savedSearch.title;\n  };\n\n  $scope.uiState = $state.makeStateful('uiState');\n\n  function getStateDefaults() {\n    return {\n      query: $scope.searchSource.get('query') || { query: '', language: config.get('search:queryLanguage') },\n      sort: _get_sort.getSort.array(savedSearch.sort, $scope.indexPattern, config.get('discover:sort:defaultOrder')),\n      columns: savedSearch.columns.length > 0 ? savedSearch.columns : config.get('defaultColumns').slice(),\n      index: $scope.indexPattern.id,\n      interval: 'auto',\n      filters: _lodash2.default.cloneDeep($scope.searchSource.getOwn('filter'))\n    };\n  }\n\n  $state.index = $scope.indexPattern.id;\n  $state.sort = _get_sort.getSort.array($state.sort, $scope.indexPattern);\n\n  $scope.$watchCollection('state.columns', function () {\n    $state.save();\n  });\n\n  $scope.opts = {\n    // number of records to fetch, then paginate through\n    sampleSize: config.get('discover:sampleSize'),\n    timefield: $scope.indexPattern.timeFieldName,\n    savedSearch: savedSearch,\n    indexPatternList: $route.current.locals.ip.list,\n    timefilter: $scope.timefilter\n  };\n\n  var init = _lodash2.default.once(function () {\n    var showTotal = 5;\n    $scope.failuresShown = showTotal;\n    $scope.showAllFailures = function () {\n      $scope.failuresShown = $scope.failures.length;\n    };\n    $scope.showLessFailures = function () {\n      $scope.failuresShown = showTotal;\n    };\n\n    stateMonitor = _state_monitor_factory.stateMonitorFactory.create($state, getStateDefaults());\n    stateMonitor.onChange(function (status) {\n      $appStatus.dirty = status.dirty || !savedSearch.id;\n    });\n    $scope.$on('$destroy', function () {\n      return stateMonitor.destroy();\n    });\n\n    $scope.updateDataSource().then(function () {\n      $scope.$listen(timefilter, 'fetch', function () {\n        $scope.fetch();\n      });\n\n      $scope.$watchCollection('state.sort', function (sort) {\n        if (!sort) return;\n\n        // get the current sort from {key: val} to [\"key\", \"val\"];\n        var currentSort = _lodash2.default.pairs($scope.searchSource.get('sort')).pop();\n\n        // if the searchSource doesn't know, tell it so\n        if (!_angular2.default.equals(sort, currentSort)) $scope.fetch();\n      });\n\n      // update data source when filters update\n      $scope.$listen(queryFilter, 'update', function () {\n        return $scope.updateDataSource().then(function () {\n          $state.save();\n        });\n      });\n\n      // update data source when hitting forward/back and the query changes\n      $scope.$listen($state, 'fetch_with_changes', function (diff) {\n        if (diff.indexOf('query') >= 0) $scope.fetch();\n      });\n\n      // fetch data when filters fire fetch event\n      $scope.$listen(queryFilter, 'fetch', $scope.fetch);\n\n      $scope.$watch('opts.timefield', function (timefield) {\n        timefilter.enabled = !!timefield;\n      });\n\n      $scope.$watch('state.interval', function () {\n        $scope.fetch();\n      });\n\n      $scope.$watch('vis.aggs', function () {\n        // no timefield, no vis, nothing to update\n        if (!$scope.opts.timefield) return;\n\n        var buckets = $scope.vis.getAggConfig().bySchemaGroup.buckets;\n\n        if (buckets && buckets.length === 1) {\n          $scope.bucketInterval = buckets[0].buckets.getInterval();\n        }\n      });\n\n      $scope.$watch('state.query', $scope.updateQueryAndFetch);\n\n      $scope.$watchMulti(['rows', 'fetchStatus'], function updateResultState() {\n        var prev = {};\n        var status = {\n          LOADING: 'loading', // initial data load\n          READY: 'ready', // results came back\n          NO_RESULTS: 'none' // no results came back\n        };\n\n        function pick(rows, oldRows, fetchStatus) {\n          // initial state, pretend we are loading\n          if (rows == null && oldRows == null) return status.LOADING;\n\n          var rowsEmpty = _lodash2.default.isEmpty(rows);\n          // An undefined fetchStatus means the requests are still being\n          // prepared to be sent. When all requests are completed,\n          // fetchStatus is set to null, so it's important that we\n          // specifically check for undefined to determine a loading status.\n          var preparingForFetch = _lodash2.default.isUndefined(fetchStatus);\n          if (preparingForFetch) return status.LOADING;else if (rowsEmpty && fetchStatus) return status.LOADING;else if (!rowsEmpty) return status.READY;else return status.NO_RESULTS;\n        }\n\n        return function () {\n          var current = {\n            rows: $scope.rows,\n            fetchStatus: $scope.fetchStatus\n          };\n\n          $scope.resultState = pick(current.rows, prev.rows, current.fetchStatus, prev.fetchStatus);\n\n          prev = current;\n        };\n      }());\n\n      if ($scope.opts.timefield) {\n        setupVisualization();\n        $scope.updateTime();\n      }\n\n      init.complete = true;\n      $state.replace();\n    });\n  });\n\n  $scope.opts.saveDataSource = function () {\n    return $scope.updateDataSource().then(function () {\n      savedSearch.columns = $scope.state.columns;\n      savedSearch.sort = $scope.state.sort;\n\n      return savedSearch.save().then(function (id) {\n        stateMonitor.setInitialState($state.toJSON());\n        $scope.kbnTopNav.close('save');\n\n        if (id) {\n          notify.info('Saved Data Source \"' + savedSearch.title + '\"');\n          if (savedSearch.id !== $route.current.params.id) {\n            kbnUrl.change('/discover/{{id}}', { id: savedSearch.id });\n          } else {\n            // Update defaults so that \"reload saved query\" functions correctly\n            $state.setDefaults(getStateDefaults());\n            docTitle.change(savedSearch.lastSavedTitle);\n          }\n        }\n      });\n    }).catch(notify.error);\n  };\n\n  $scope.opts.fetch = $scope.fetch = function () {\n    // ignore requests to fetch before the app inits\n    if (!init.complete) return;\n\n    $scope.updateTime();\n\n    $scope.updateDataSource().then(setupVisualization).then(function () {\n      $state.save();\n      return courier.fetch();\n    }).catch(notify.error);\n  };\n\n  $scope.updateQueryAndFetch = function (query) {\n    // reset state if language changes\n    if ($state.query.language && $state.query.language !== query.language) {\n      $state.filters = [];\n    }\n    $state.query = (0, _migrateLegacyQuery.migrateLegacyQuery)(query);\n    $scope.fetch();\n  };\n\n  function initSegmentedFetch(segmented) {\n    function flushResponseData() {\n      $scope.hits = 0;\n      $scope.faliures = [];\n      $scope.rows = [];\n      $scope.fieldCounts = {};\n    }\n\n    if (!$scope.rows) flushResponseData();\n\n    var sort = $state.sort;\n    var timeField = $scope.indexPattern.timeFieldName;\n\n    /**\n     * Basically an emum.\n     *\n     * opts:\n     *   \"time\" - sorted by the timefield\n     *   \"non-time\" - explicitly sorted by a non-time field, NOT THE SAME AS `sortBy !== \"time\"`\n     *   \"implicit\" - no sorting set, NOT THE SAME AS \"non-time\"\n     *\n     * @type {String}\n     */\n    var sortBy = function () {\n      if (!Array.isArray(sort)) return 'implicit';else if (sort[0] === '_score') return 'implicit';else if (sort[0] === timeField) return 'time';else return 'non-time';\n    }();\n\n    var sortFn = null;\n    if (sortBy !== 'implicit') {\n      sortFn = new HitSortFn(sort[1]);\n    }\n\n    $scope.updateTime();\n    if (sort[0] === '_score') segmented.setMaxSegments(1);\n    segmented.setDirection(sortBy === 'time' ? sort[1] || 'desc' : 'desc');\n    segmented.setSortFn(sortFn);\n    segmented.setSize($scope.opts.sampleSize);\n\n    // triggered when the status updated\n    segmented.on('status', function (status) {\n      $scope.fetchStatus = status;\n    });\n\n    segmented.on('first', function () {\n      flushResponseData();\n    });\n\n    segmented.on('segment', notify.timed('handle each segment', function (resp) {\n      if (resp._shards.failed > 0) {\n        $scope.failures = _lodash2.default.union($scope.failures, resp._shards.failures);\n        $scope.failures = _lodash2.default.uniq($scope.failures, false, function (failure) {\n          return failure.index + failure.shard + failure.reason;\n        });\n      }\n    }));\n\n    segmented.on('mergedSegment', function (merged) {\n      $scope.mergedEsResp = merged;\n\n      if ($scope.opts.timefield) {\n        $scope.searchSource.rawResponse = merged;\n        Promise.resolve(responseHandler($scope.vis, merged)).then(function (resp) {\n          $scope.visData = resp;\n        });\n      }\n\n      $scope.hits = merged.hits.total;\n\n      var indexPattern = $scope.searchSource.get('index');\n\n      // the merge rows, use a new array to help watchers\n      $scope.rows = merged.hits.hits.slice();\n\n      notify.event('flatten hit and count fields', function () {\n        var counts = $scope.fieldCounts;\n\n        // if we haven't counted yet, or need a fresh count because we are sorting, reset the counts\n        if (!counts || sortFn) counts = $scope.fieldCounts = {};\n\n        $scope.rows.forEach(function (hit) {\n          // skip this work if we have already done it\n          if (hit.$$_counted) return;\n\n          // when we are sorting results, we need to redo the counts each time because the\n          // \"top 500\" may change with each response, so don't mark this as counted\n          if (!sortFn) hit.$$_counted = true;\n\n          var fields = _lodash2.default.keys(indexPattern.flattenHit(hit));\n          var n = fields.length;\n          var field = void 0;\n          while (field = fields[--n]) {\n            if (counts[field]) counts[field] += 1;else counts[field] = 1;\n          }\n        });\n      });\n    });\n\n    segmented.on('complete', function () {\n      if ($scope.fetchStatus.hitCount === 0) {\n        flushResponseData();\n      }\n\n      $scope.fetchStatus = null;\n    });\n  }\n\n  function beginSegmentedFetch() {\n    $scope.searchSource.onBeginSegmentedFetch(initSegmentedFetch).catch(function (error) {\n      notify.error(error);\n      // Restart.\n      beginSegmentedFetch();\n    });\n  }\n  beginSegmentedFetch();\n\n  $scope.updateTime = function () {\n    $scope.timeRange = {\n      from: _datemath2.default.parse(timefilter.time.from),\n      to: _datemath2.default.parse(timefilter.time.to, true)\n    };\n  };\n\n  $scope.resetQuery = function () {\n    kbnUrl.change('/discover/{{id}}', { id: $route.current.params.id });\n  };\n\n  $scope.newQuery = function () {\n    kbnUrl.change('/discover');\n  };\n\n  $scope.updateDataSource = Promise.method(function updateDataSource() {\n    $scope.searchSource.size($scope.opts.sampleSize).sort((0, _get_sort.getSort)($state.sort, $scope.indexPattern)).query(!$state.query ? null : $state.query).set('filter', queryFilter.getFilters());\n  });\n\n  $scope.setSortOrder = function setSortOrder(columnName, direction) {\n    $scope.state.sort = [columnName, direction];\n  };\n\n  // TODO: On array fields, negating does not negate the combination, rather all terms\n  $scope.filterQuery = function (field, values, operation) {\n    $scope.indexPattern.popularizeField(field, 1);\n    filterActions.addFilter(field, values, operation, $scope.indexPattern.id, $scope.state, filterManager);\n  };\n\n  $scope.addColumn = function addColumn(columnName) {\n    $scope.indexPattern.popularizeField(columnName, 1);\n    columnActions.addColumn($scope.state.columns, columnName);\n  };\n\n  $scope.removeColumn = function removeColumn(columnName) {\n    $scope.indexPattern.popularizeField(columnName, 1);\n    columnActions.removeColumn($scope.state.columns, columnName);\n  };\n\n  $scope.moveColumn = function moveColumn(columnName, newIndex) {\n    columnActions.moveColumn($scope.state.columns, columnName, newIndex);\n  };\n\n  $scope.scrollToTop = function () {\n    $window.scrollTo(0, 0);\n  };\n\n  $scope.scrollToBottom = function () {\n    // delay scrolling to after the rows have been rendered\n    $timeout(function () {\n      $element.find('#discoverBottomMarker').focus();\n    }, 0);\n  };\n\n  $scope.showAllRows = function () {\n    $scope.minimumVisibleRows = $scope.hits;\n  };\n\n  function setupVisualization() {\n    // If no timefield has been specified we don't create a histogram of messages\n    if (!$scope.opts.timefield) return;\n\n    var visStateAggs = [{\n      type: 'count',\n      schema: 'metric'\n    }, {\n      type: 'date_histogram',\n      schema: 'segment',\n      params: {\n        field: $scope.opts.timefield,\n        interval: $state.interval\n      }\n    }];\n\n    // we have a vis, just modify the aggs\n    if ($scope.vis) {\n      var visState = $scope.vis.getEnabledState();\n      visState.aggs = visStateAggs;\n\n      $scope.vis.setState(visState);\n    } else {\n      $scope.vis = new Vis($scope.indexPattern, {\n        title: savedSearch.title,\n        type: 'histogram',\n        params: {\n          addLegend: false,\n          addTimeMarker: true\n        },\n        aggs: visStateAggs\n      });\n\n      $scope.searchSource.onRequestStart(function (searchSource, searchRequest) {\n        return $scope.vis.onSearchRequestStart(searchSource, searchRequest);\n      });\n\n      $scope.searchSource.aggs(function () {\n        return $scope.vis.getAggConfig().toDsl();\n      });\n    }\n  }\n\n  function resolveIndexPatternLoading() {\n    var props = $route.current.locals.ip;\n    var loaded = props.loaded;\n    var stateVal = props.stateVal;\n    var stateValFound = props.stateValFound;\n\n    var own = $scope.searchSource.getOwn('index');\n\n    if (own && !stateVal) return own;\n    if (stateVal && !stateValFound) {\n      var err = '\"' + stateVal + '\" is not a configured pattern ID. ';\n      if (own) {\n        notify.warning(err + ' Using the saved index pattern: \"' + own.title + '\" (' + own.id + ')');\n        return own;\n      }\n\n      notify.warning(err + ' Using the default index pattern: \"' + loaded.title + '\" (' + loaded.id + ')');\n    }\n    return loaded;\n  }\n\n  init();\n}",null]}