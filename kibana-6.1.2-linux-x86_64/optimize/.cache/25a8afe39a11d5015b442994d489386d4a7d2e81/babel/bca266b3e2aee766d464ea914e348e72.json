{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/directives/saved_object_finder.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/directives/saved_object_finder.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _risonNode = require('rison-node');\n\nvar _risonNode2 = _interopRequireDefault(_risonNode);\n\nvar _key_map = require('ui/utils/key_map');\n\nvar _saved_object_registry = require('ui/saved_objects/saved_object_registry');\n\nvar _modules = require('ui/modules');\n\nvar _saved_object_finder = require('ui/partials/saved_object_finder.html');\n\nvar _saved_object_finder2 = _interopRequireDefault(_saved_object_finder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _module = _modules.uiModules.get('kibana');\n\n_module.directive('savedObjectFinder', function ($location, $injector, kbnUrl, Private, config) {\n\n  var services = Private(_saved_object_registry.SavedObjectRegistryProvider).byLoaderPropertiesName;\n\n  return {\n    restrict: 'E',\n    scope: {\n      type: '@',\n      // optional make-url attr, sets the userMakeUrl in our scope\n      userMakeUrl: '=?makeUrl',\n      // optional on-choose attr, sets the userOnChoose in our scope\n      userOnChoose: '=?onChoose',\n      // optional useLocalManagement attr,  removes link to management section\n      useLocalManagement: '=?useLocalManagement',\n      /**\n       * @type {function} - an optional function. If supplied an `Add new X` button is shown\n       * and this function is called when clicked.\n       */\n      onAddNew: '=',\n      /**\n       * @{type} boolean - set this to true, if you don't want the search box above the\n       * table to automatically gain focus once loaded\n       */\n      disableAutoFocus: '='\n    },\n    template: _saved_object_finder2.default,\n    controllerAs: 'finder',\n    controller: function controller($scope, $element) {\n      var self = this;\n\n      // the text input element\n      var $input = $element.find('input[ng-model=filter]');\n\n      // The number of items to show in the list\n      $scope.perPage = config.get('savedObjects:perPage');\n\n      // the list that will hold the suggestions\n      var $list = $element.find('ul');\n\n      // the current filter string, used to check that returned results are still useful\n      var currentFilter = $scope.filter;\n\n      // the most recently entered search/filter\n      var prevSearch = void 0;\n\n      // the list of hits, used to render display\n      self.hits = [];\n\n      self.service = services[$scope.type];\n      self.properties = self.service.loaderProperties;\n\n      filterResults();\n\n      /**\n       * Boolean that keeps track of whether hits are sorted ascending (true)\n       * or descending (false) by title\n       * @type {Boolean}\n       */\n      self.isAscending = true;\n\n      /**\n       * Sorts saved object finder hits either ascending or descending\n       * @param  {Array} hits Array of saved finder object hits\n       * @return {Array} Array sorted either ascending or descending\n       */\n      self.sortHits = function (hits) {\n        self.isAscending = !self.isAscending;\n        self.hits = self.isAscending ? _lodash2.default.sortBy(hits, 'title') : _lodash2.default.sortBy(hits, 'title').reverse();\n      };\n\n      /**\n       * Passed the hit objects and will determine if the\n       * hit should have a url in the UI, returns it if so\n       * @return {string|null} - the url or nothing\n       */\n      self.makeUrl = function (hit) {\n        if ($scope.userMakeUrl) {\n          return $scope.userMakeUrl(hit);\n        }\n\n        if (!$scope.userOnChoose) {\n          return hit.url;\n        }\n\n        return '#';\n      };\n\n      self.preventClick = function ($event) {\n        $event.preventDefault();\n      };\n\n      /**\n       * Called when a hit object is clicked, can override the\n       * url behavior if necessary.\n       */\n      self.onChoose = function (hit, $event) {\n        if ($scope.userOnChoose) {\n          $scope.userOnChoose(hit, $event);\n        }\n\n        var url = self.makeUrl(hit);\n        if (!url || url === '#' || url.charAt(0) !== '#') return;\n\n        $event.preventDefault();\n\n        // we want the '/path', not '#/path'\n        kbnUrl.change(url.substr(1));\n      };\n\n      $scope.$watch('filter', function (newFilter) {\n        // ensure that the currentFilter changes from undefined to ''\n        // which triggers\n        currentFilter = newFilter || '';\n        filterResults();\n      });\n\n      $scope.pageFirstItem = 0;\n      $scope.pageLastItem = 0;\n      $scope.onPageChanged = function (page) {\n        $scope.pageFirstItem = page.firstItem;\n        $scope.pageLastItem = page.lastItem;\n      };\n\n      //manages the state of the keyboard selector\n      self.selector = {\n        enabled: false,\n        index: -1\n      };\n\n      //key handler for the filter text box\n      self.filterKeyDown = function ($event) {\n        switch (_key_map.keyMap[$event.keyCode]) {\n          case 'enter':\n            if (self.hitCount !== 1) return;\n\n            var hit = self.hits[0];\n            if (!hit) return;\n\n            self.onChoose(hit, $event);\n            $event.preventDefault();\n            break;\n        }\n      };\n\n      //key handler for the list items\n      self.hitKeyDown = function ($event, page, paginate) {\n        switch (_key_map.keyMap[$event.keyCode]) {\n          case 'tab':\n            if (!self.selector.enabled) break;\n\n            self.selector.index = -1;\n            self.selector.enabled = false;\n\n            //if the user types shift-tab return to the textbox\n            //if the user types tab, set the focus to the currently selected hit.\n            if ($event.shiftKey) {\n              $input.focus();\n            } else {\n              $list.find('li.active a').focus();\n            }\n\n            $event.preventDefault();\n            break;\n          case 'down':\n            if (!self.selector.enabled) break;\n\n            if (self.selector.index + 1 < page.length) {\n              self.selector.index += 1;\n            }\n            $event.preventDefault();\n            break;\n          case 'up':\n            if (!self.selector.enabled) break;\n\n            if (self.selector.index > 0) {\n              self.selector.index -= 1;\n            }\n            $event.preventDefault();\n            break;\n          case 'right':\n            if (!self.selector.enabled) break;\n\n            if (page.number < page.count) {\n              paginate.goToPage(page.number + 1);\n              self.selector.index = 0;\n              selectTopHit();\n            }\n            $event.preventDefault();\n            break;\n          case 'left':\n            if (!self.selector.enabled) break;\n\n            if (page.number > 1) {\n              paginate.goToPage(page.number - 1);\n              self.selector.index = 0;\n              selectTopHit();\n            }\n            $event.preventDefault();\n            break;\n          case 'escape':\n            if (!self.selector.enabled) break;\n\n            $input.focus();\n            $event.preventDefault();\n            break;\n          case 'enter':\n            if (!self.selector.enabled) break;\n\n            var hitIndex = (page.number - 1) * paginate.perPage + self.selector.index;\n            var hit = self.hits[hitIndex];\n            if (!hit) break;\n\n            self.onChoose(hit, $event);\n            $event.preventDefault();\n            break;\n          case 'shift':\n            break;\n          default:\n            $input.focus();\n            break;\n        }\n      };\n\n      self.hitBlur = function () {\n        self.selector.index = -1;\n        self.selector.enabled = false;\n      };\n\n      self.manageObjects = function (type) {\n        $location.url('/management/kibana/objects?_a=' + _risonNode2.default.encode({ tab: type }));\n      };\n\n      self.hitCountNoun = function () {\n        return (self.hitCount === 1 ? self.properties.noun : self.properties.nouns).toLowerCase();\n      };\n\n      function selectTopHit() {\n        setTimeout(function () {\n          //triggering a focus event kicks off a new angular digest cycle.\n          $list.find('a:first').focus();\n        }, 0);\n      }\n\n      function filterResults() {\n        if (!self.service) return;\n        if (!self.properties) return;\n\n        // track the filter that we use for this search,\n        // but ensure that we don't search for the same\n        // thing twice. This is called from multiple places\n        // and needs to be smart about when it actually searches\n        var filter = currentFilter;\n        if (prevSearch === filter) return;\n\n        prevSearch = filter;\n\n        var isLabsEnabled = config.get('visualize:enableLabs');\n        self.service.find(filter).then(function (hits) {\n\n          hits.hits = hits.hits.filter(function (hit) {\n            return isLabsEnabled || hit.type.stage !== 'lab';\n          });\n          hits.total = hits.hits.length;\n\n          // ensure that we don't display old results\n          // as we can't really cancel requests\n          if (currentFilter === filter) {\n            self.hitCount = hits.total;\n            self.hits = _lodash2.default.sortBy(hits.hits, 'title');\n          }\n        });\n      }\n    }\n  };\n});",null]}