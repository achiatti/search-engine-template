{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/dispatch.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/dispatch.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.VislibLibDispatchProvider = VislibLibDispatchProvider;\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _simple_emitter = require('ui/utils/simple_emitter');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction VislibLibDispatchProvider(Private, config) {\n\n  /**\n   * Handles event responses\n   *\n   * @class Dispatch\n   * @constructor\n   * @param handler {Object} Reference to Handler Class Object\n   */\n\n  var Dispatch = function (_SimpleEmitter) {\n    _inherits(Dispatch, _SimpleEmitter);\n\n    function Dispatch(handler) {\n      _classCallCheck(this, Dispatch);\n\n      var _this = _possibleConstructorReturn(this, (Dispatch.__proto__ || Object.getPrototypeOf(Dispatch)).call(this));\n\n      _this.handler = handler;\n      _this._listeners = {};\n      return _this;\n    }\n\n    /**\n     * Response to click and hover events\n     *\n     * @param d {Object} Data point\n     * @param i {Number} Index number of data point\n     * @returns {{value: *, point: *, label: *, color: *, pointIndex: *,\n     * series: *, config: *, data: (Object|*),\n     * e: (d3.event|*), handler: (Object|*)}} Event response object\n     */\n\n\n    _createClass(Dispatch, [{\n      key: 'eventResponse',\n      value: function eventResponse(d, i) {\n        var datum = d._input || d;\n        var data = _d2.default.event.target.nearestViewportElement ? _d2.default.event.target.nearestViewportElement.__data__ : _d2.default.event.target.__data__;\n        var label = d.label ? d.label : d.series || 'Count';\n        var isSeries = !!(data && data.series);\n        var isSlices = !!(data && data.slices);\n        var series = isSeries ? data.series : undefined;\n        var slices = isSlices ? data.slices : undefined;\n        var handler = this.handler;\n        var color = _lodash2.default.get(handler, 'data.color');\n\n        var eventData = {\n          value: d.y,\n          point: datum,\n          datum: datum,\n          label: label,\n          color: color ? color(label) : undefined,\n          pointIndex: i,\n          series: series,\n          slices: slices,\n          config: handler && handler.visConfig,\n          data: data,\n          e: _d2.default.event,\n          handler: handler\n        };\n\n        if (isSeries) {\n          var percentageMode = false;\n          //only series charts work in percentage mode.\n          var isSeriesChart = handler.charts && handler.charts[0] && handler.charts[0].getSeries;\n          var parentNode = _d2.default.event.target.parentNode;\n          var parentData = parentNode ? parentNode.__data__ : null;\n          if (isSeriesChart && parentData) {\n            var aggId = parentData.aggId;\n            var seriesFromAggId = handler.charts[0].getSeries(aggId);\n            if (seriesFromAggId && seriesFromAggId.getValueAxis) {\n              percentageMode = seriesFromAggId.getValueAxis().axisConfig.isPercentage();\n            }\n          }\n\n          var object = _lodash2.default.find(series, { 'label': label });\n          if (object) {\n            eventData.value = +object.values[i].y;\n\n            if (percentageMode) {\n              // Add the formatted percentage to the point object\n              eventData.percent = (100 * d.y).toFixed(1) + '%';\n            }\n          }\n        }\n\n        return eventData;\n      }\n\n      /**\n       * Returns a function that adds events and listeners to a D3 selection\n       *\n       * @method addEvent\n       * @param event {String}\n       * @param callback {Function}\n       * @returns {Function}\n       */\n\n    }, {\n      key: 'addEvent',\n      value: function addEvent(event, callback) {\n        return function (selection) {\n          selection.each(function () {\n            var element = _d2.default.select(this);\n\n            if (typeof callback === 'function') {\n              return element.on(event, callback);\n            }\n          });\n        };\n      }\n\n      /**\n       *\n       * @method addHoverEvent\n       * @returns {Function}\n       */\n\n    }, {\n      key: 'addHoverEvent',\n      value: function addHoverEvent() {\n        var self = this;\n        var isClickable = this.listenerCount('click') > 0;\n        var addEvent = this.addEvent;\n        var $el = this.handler.el;\n        if (!this.handler.highlight) {\n          this.handler.highlight = self.highlight;\n        }\n\n        function hover(d, i) {\n          // Add pointer if item is clickable\n          if (isClickable) {\n            self.addMousePointer.call(this, arguments);\n          }\n\n          self.handler.highlight.call(this, $el);\n          self.emit('hover', self.eventResponse(d, i));\n        }\n\n        return addEvent('mouseover', hover);\n      }\n\n      /**\n       *\n       * @method addMouseoutEvent\n       * @returns {Function}\n       */\n\n    }, {\n      key: 'addMouseoutEvent',\n      value: function addMouseoutEvent() {\n        var self = this;\n        var addEvent = this.addEvent;\n        var $el = this.handler.el;\n        if (!this.handler.unHighlight) {\n          this.handler.unHighlight = self.unHighlight;\n        }\n\n        function mouseout() {\n          self.handler.unHighlight.call(this, $el);\n        }\n\n        return addEvent('mouseout', mouseout);\n      }\n\n      /**\n       *\n       * @method addClickEvent\n       * @returns {Function}\n       */\n\n    }, {\n      key: 'addClickEvent',\n      value: function addClickEvent() {\n        var self = this;\n        var addEvent = this.addEvent;\n\n        function click(d, i) {\n          self.emit('click', self.eventResponse(d, i));\n        }\n\n        return addEvent('click', click);\n      }\n\n      /**\n       * Determine if we will allow brushing\n       *\n       * @method allowBrushing\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: 'allowBrushing',\n      value: function allowBrushing() {\n        var xAxis = this.handler.categoryAxes[0];\n\n        //Allow brushing for ordered axis - date histogram and histogram\n        return Boolean(xAxis.ordered);\n      }\n\n      /**\n       * Determine if brushing is currently enabled\n       *\n       * @method isBrushable\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: 'isBrushable',\n      value: function isBrushable() {\n        return this.allowBrushing() && this.listenerCount('brush') > 0;\n      }\n\n      /**\n       *\n       * @param svg\n       * @returns {Function}\n       */\n\n    }, {\n      key: 'addBrushEvent',\n      value: function addBrushEvent(svg) {\n        if (!this.isBrushable()) return;\n\n        var self = this;\n        var xScale = this.handler.categoryAxes[0].getScale();\n        var brush = this.createBrush(xScale, svg);\n\n        function simulateClickWithBrushEnabled(d, i) {\n          if (!validBrushClick(_d2.default.event)) return;\n\n          if (isQuantitativeScale(xScale)) {\n            var bar = _d2.default.select(this);\n            var startX = _d2.default.mouse(svg.node());\n            var startXInv = xScale.invert(startX[0]);\n\n            // Reset the brush value\n            brush.extent([startXInv, startXInv]);\n\n            // Magic!\n            // Need to call brush on svg to see brush when brushing\n            // while on top of bars.\n            // Need to call brush on bar to allow the click event to be registered\n            svg.call(brush);\n            bar.call(brush);\n          } else {\n            self.emit('click', self.eventResponse(d, i));\n          }\n        }\n\n        return this.addEvent('mousedown', simulateClickWithBrushEnabled);\n      }\n\n      /**\n       * Mouseover Behavior\n       *\n       * @method addMousePointer\n       * @returns {d3.Selection}\n       */\n\n    }, {\n      key: 'addMousePointer',\n      value: function addMousePointer() {\n        return _d2.default.select(this).style('cursor', 'pointer');\n      }\n\n      /**\n       * Highlight the element that is under the cursor\n       * by reducing the opacity of all the elements on the graph.\n       * @param element {d3.Selection}\n       * @method highlight\n       */\n\n    }, {\n      key: 'highlight',\n      value: function highlight(element) {\n        var label = this.getAttribute('data-label');\n        if (!label) return;\n\n        var dimming = config.get('visualization:dimmingOpacity');\n        (0, _jquery2.default)(element).parent().find('[data-label]').css('opacity', 1) //Opacity 1 is needed to avoid the css application\n        .not(function (els, el) {\n          return String((0, _jquery2.default)(el).data('label')) === label;\n        }).css('opacity', justifyOpacity(dimming));\n      }\n\n      /**\n       * Mouseout Behavior\n       *\n       * @param element {d3.Selection}\n       * @method unHighlight\n       */\n\n    }, {\n      key: 'unHighlight',\n      value: function unHighlight(element) {\n        (0, _jquery2.default)('[data-label]', element.parentNode).css('opacity', 1);\n      }\n\n      /**\n       * Adds D3 brush to SVG and returns the brush function\n       *\n       * @param xScale {Function} D3 xScale function\n       * @param svg {HTMLElement} Reference to SVG\n       * @returns {*} Returns a D3 brush function and a SVG with a brush group attached\n       */\n\n    }, {\n      key: 'createBrush',\n      value: function createBrush(xScale, svg) {\n        var self = this;\n        var visConfig = self.handler.visConfig;\n\n        var _svg$node$getBBox = svg.node().getBBox(),\n            width = _svg$node$getBBox.width,\n            height = _svg$node$getBBox.height;\n\n        var isHorizontal = self.handler.categoryAxes[0].axisConfig.isHorizontal();\n\n        // Brush scale\n        var brush = _d2.default.svg.brush();\n        if (isHorizontal) {\n          brush.x(xScale);\n        } else {\n          brush.y(xScale);\n        }\n\n        brush.on('brushend', function brushEnd() {\n\n          // Assumes data is selected at the chart level\n          // In this case, the number of data objects should always be 1\n          var data = _d2.default.select(this).data()[0];\n          var isTimeSeries = data.ordered && data.ordered.date;\n\n          // Allows for brushing on d3.scale.ordinal()\n          var selected = xScale.domain().filter(function (d) {\n            return brush.extent()[0] <= xScale(d) && xScale(d) <= brush.extent()[1];\n          });\n          var range = isTimeSeries ? brush.extent() : selected;\n\n          return self.emit('brush', {\n            range: range,\n            config: visConfig,\n            e: _d2.default.event,\n            data: data\n          });\n        });\n\n        // if `addBrushing` is true, add brush canvas\n        if (self.listenerCount('brush')) {\n          var rect = svg.insert('g', 'g').attr('class', 'brush').call(brush).call(function (brushG) {\n            // hijack the brush start event to filter out right/middle clicks\n            var brushHandler = brushG.on('mousedown.brush');\n            if (!brushHandler) return; // touch events in use\n            brushG.on('mousedown.brush', function () {\n              if (validBrushClick(_d2.default.event)) brushHandler.apply(this, arguments);\n            });\n          }).selectAll('rect');\n\n          if (isHorizontal) {\n            rect.attr('height', height);\n          } else {\n            rect.attr('width', width);\n          }\n\n          return brush;\n        }\n      }\n    }]);\n\n    return Dispatch;\n  }(_simple_emitter.SimpleEmitter);\n\n  /**\n   * Determine if d3.Scale is quantitative\n   *\n   * @param element {d3.Scale}\n   * @method isQuantitativeScale\n   * @returns {boolean}\n   */\n\n\n  function isQuantitativeScale(scale) {\n    //Invert is a method that only exists on quantitative scales\n    if (scale.invert) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function validBrushClick(event) {\n    return event.button === 0;\n  }\n\n  function justifyOpacity(opacity) {\n    var decimalNumber = parseFloat(opacity, 10);\n    var fallbackOpacity = 0.5;\n    return 0 <= decimalNumber && decimalNumber <= 1 ? decimalNumber : fallbackOpacity;\n  }\n\n  return Dispatch;\n}",null]}