{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/filter_bar/query_filter.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/filter_bar/query_filter.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilterBarQueryFilterProvider = FilterBarQueryFilterProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _only_disabled = require('ui/filter_bar/lib/only_disabled');\n\nvar _only_state_changed = require('ui/filter_bar/lib/only_state_changed');\n\nvar _uniq_filters = require('ui/filter_bar/lib/uniq_filters');\n\nvar _compare_filters = require('ui/filter_bar/lib/compare_filters');\n\nvar _events = require('ui/events');\n\nvar _map_and_flatten_filters = require('ui/filter_bar/lib/map_and_flatten_filters');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction FilterBarQueryFilterProvider(Private, $rootScope, getAppState, globalState, config) {\n  var EventEmitter = Private(_events.EventsProvider);\n  var mapAndFlattenFilters = Private(_map_and_flatten_filters.FilterBarLibMapAndFlattenFiltersProvider);\n\n  var queryFilter = new EventEmitter();\n\n  queryFilter.getFilters = function () {\n    var compareOptions = { disabled: true, negate: true };\n    var appFilters = queryFilter.getAppFilters();\n    var globalFilters = queryFilter.getGlobalFilters();\n\n    return (0, _uniq_filters.uniqFilters)(globalFilters.concat(appFilters), compareOptions);\n  };\n\n  queryFilter.getAppFilters = function () {\n    var appState = getAppState();\n    if (!appState || !appState.filters) return [];\n\n    // Work around for https://github.com/elastic/kibana/issues/5896\n    appState.filters = validateStateFilters(appState);\n\n    return appState.filters ? _lodash2.default.map(appState.filters, appendStoreType('appState')) : [];\n  };\n\n  queryFilter.getGlobalFilters = function () {\n    if (!globalState.filters) return [];\n\n    // Work around for https://github.com/elastic/kibana/issues/5896\n    globalState.filters = validateStateFilters(globalState);\n\n    return _lodash2.default.map(globalState.filters, appendStoreType('globalState'));\n  };\n\n  /**\n   * Adds new filters to the scope and state\n   * @param {object|array} filters Filter(s) to add\n   * @param {bool} global Whether the filter should be added to global state\n   * @returns {Promise} filter map promise\n   */\n  queryFilter.addFilters = function (filters, global) {\n\n    if (global === undefined) {\n      var configDefault = config.get('filters:pinnedByDefault');\n\n      if (configDefault === false || configDefault === true) {\n        global = configDefault;\n      }\n    }\n\n    // Determine the state for the new filter (whether to pass the filter through other apps or not)\n    var appState = getAppState();\n    var filterState = global ? globalState : appState;\n\n    if (!Array.isArray(filters)) {\n      filters = [filters];\n    }\n\n    return mapAndFlattenFilters(filters).then(function (filters) {\n      if (!filterState.filters) {\n        filterState.filters = [];\n      }\n\n      filterState.filters = filterState.filters.concat(filters);\n    });\n  };\n\n  /**\n   * Removes the filter from the proper state\n   * @param {object} matchFilter The filter to remove\n   */\n  queryFilter.removeFilter = function (matchFilter) {\n    var appState = getAppState();\n    var filter = _lodash2.default.omit(matchFilter, ['$$hashKey']);\n    var state = void 0;\n    var index = void 0;\n\n    // check for filter in appState\n    if (appState) {\n      index = _lodash2.default.findIndex(appState.filters, filter);\n      if (index !== -1) state = appState;\n    }\n\n    // if not found, check for filter in globalState\n    if (!state) {\n      index = _lodash2.default.findIndex(globalState.filters, filter);\n      if (index !== -1) state = globalState;else return; // not found in either state, do nothing\n    }\n\n    state.filters.splice(index, 1);\n  };\n\n  /**\n   * Removes all filters\n   */\n  queryFilter.removeAll = function () {\n    var appState = getAppState();\n    appState.filters = [];\n    globalState.filters = [];\n  };\n\n  /**\n   * Toggles the filter between enabled/disabled.\n   * @param {object} filter The filter to toggle\n   & @param {boolean} force Disabled true/false\n   * @returns {object} updated filter\n   */\n  queryFilter.toggleFilter = function (filter, force) {\n    // Toggle the disabled flag\n    var disabled = _lodash2.default.isUndefined(force) ? !filter.meta.disabled : !!force;\n    filter.meta.disabled = disabled;\n    return filter;\n  };\n\n  /**\n   * Disables all filters\n   * @params {boolean} force Disable/enable all filters\n   */\n  queryFilter.toggleAll = function (force) {\n    function doToggle(filter) {\n      queryFilter.toggleFilter(filter, force);\n    }\n\n    executeOnFilters(doToggle);\n  };\n\n  /**\n   * Inverts the nagate value on the filter\n   * @param {object} filter The filter to toggle\n   * @returns {object} updated filter\n   */\n  queryFilter.invertFilter = function (filter) {\n    // Toggle the negate meta state\n    filter.meta.negate = !filter.meta.negate;\n    return filter;\n  };\n\n  /**\n   * Inverts all filters\n   * @returns {object} Resulting updated filter list\n   */\n  queryFilter.invertAll = function () {\n    executeOnFilters(queryFilter.invertFilter);\n  };\n\n  /**\n   * Pins the filter to the global state\n   * @param {object} filter The filter to pin\n   * @param {boolean} force pinned state\n   * @returns {object} updated filter\n   */\n  queryFilter.pinFilter = function (filter, force) {\n    var appState = getAppState();\n    if (!appState) return filter;\n\n    // ensure that both states have a filters property\n    if (!Array.isArray(globalState.filters)) globalState.filters = [];\n    if (!Array.isArray(appState.filters)) appState.filters = [];\n\n    var appIndex = _lodash2.default.findIndex(appState.filters, function (appFilter) {\n      return _lodash2.default.isEqual(appFilter, filter);\n    });\n\n    if (appIndex !== -1 && force !== false) {\n      appState.filters.splice(appIndex, 1);\n      globalState.filters.push(filter);\n    } else {\n      var globalIndex = _lodash2.default.findIndex(globalState.filters, function (globalFilter) {\n        return _lodash2.default.isEqual(globalFilter, filter);\n      });\n\n      if (globalIndex === -1 || force === true) return filter;\n\n      globalState.filters.splice(globalIndex, 1);\n      appState.filters.push(filter);\n    }\n\n    return filter;\n  };\n\n  /**\n   * Pins all filters\n   * @params {boolean} force Pin/Unpin all filters\n   */\n  queryFilter.pinAll = function (force) {\n    function pin(filter) {\n      queryFilter.pinFilter(filter, force);\n    }\n\n    executeOnFilters(pin);\n  };\n\n  initWatchers();\n\n  return queryFilter;\n\n  /**\n   * Rids filter list of null values and replaces state if any nulls are found\n   */\n  function validateStateFilters(state) {\n    var compacted = _lodash2.default.compact(state.filters);\n    if (state.filters.length !== compacted.length) {\n      state.filters = compacted;\n      state.replace();\n    }\n    return state.filters;\n  }\n\n  /**\n   * Saves both app and global states, ensuring filters are persisted\n   * @returns {object} Resulting filter list, app and global combined\n   */\n  function saveState() {\n    var appState = getAppState();\n    if (appState) appState.save();\n    globalState.save();\n  }\n\n  function appendStoreType(type) {\n    return function (filter) {\n      filter.$state = {\n        store: type\n      };\n      return filter;\n    };\n  }\n\n  // helper to run a function on all filters in all states\n  function executeOnFilters(fn) {\n    var appState = getAppState();\n    var globalFilters = [];\n    var appFilters = [];\n\n    if (globalState.filters) globalFilters = globalState.filters;\n    if (appState && appState.filters) appFilters = appState.filters;\n\n    globalFilters.concat(appFilters).forEach(fn);\n  }\n\n  function mergeStateFilters(gFilters, aFilters, compareOptions) {\n    // ensure we don't mutate the filters passed in\n    var globalFilters = gFilters ? _lodash2.default.cloneDeep(gFilters) : [];\n    var appFilters = aFilters ? _lodash2.default.cloneDeep(aFilters) : [];\n    compareOptions = _lodash2.default.defaults(compareOptions || {}, { disabled: true });\n\n    // existing globalFilters should be mutated by appFilters\n    _lodash2.default.each(appFilters, function (filter, i) {\n      var match = _lodash2.default.find(globalFilters, function (globalFilter) {\n        return (0, _compare_filters.compareFilters)(globalFilter, filter, compareOptions);\n      });\n\n      // no match, do nothing\n      if (!match) return;\n\n      // matching filter in globalState, update global and remove from appState\n      _lodash2.default.assign(match.meta, filter.meta);\n      appFilters.splice(i, 1);\n    });\n\n    return [(0, _uniq_filters.uniqFilters)(globalFilters, { disabled: true }), (0, _uniq_filters.uniqFilters)(appFilters, { disabled: true })];\n  }\n\n  /**\n   * Initializes state watchers that use the event emitter\n   * @returns {void}\n   */\n  function initWatchers() {\n    var removeAppStateWatchers = void 0;\n\n    $rootScope.$watch(getAppState, function () {\n      removeAppStateWatchers && removeAppStateWatchers();\n      removeAppStateWatchers = initAppStateWatchers();\n    });\n\n    function initAppStateWatchers() {\n      // multi watch on the app and global states\n      var stateWatchers = [{\n        fn: $rootScope.$watch,\n        deep: true,\n        get: queryFilter.getGlobalFilters\n      }, {\n        fn: $rootScope.$watch,\n        deep: true,\n        get: queryFilter.getAppFilters\n      }];\n\n      // when states change, use event emitter to trigger updates and fetches\n      return $rootScope.$watchMulti(stateWatchers, function (next, prev) {\n        // prevent execution on watcher instantiation\n        if (_lodash2.default.isEqual(next, prev)) return;\n\n        var doUpdate = false;\n        var doFetch = false;\n\n        // reconcile filter in global and app states\n        var filters = mergeStateFilters(next[0], next[1]);\n        var globalFilters = filters[0];\n        var appFilters = filters[1];\n        var appState = getAppState();\n\n        // save the state, as it may have updated\n        var globalChanged = !_lodash2.default.isEqual(next[0], globalFilters);\n        var appChanged = !_lodash2.default.isEqual(next[1], appFilters);\n\n        // the filters were changed, apply to state (re-triggers this watcher)\n        if (globalChanged || appChanged) {\n          globalState.filters = globalFilters;\n          if (appState) appState.filters = appFilters;\n          return;\n        }\n\n        // check for actions, bail if we're done\n        getActions();\n        if (!doUpdate) return;\n\n        // save states and emit the required events\n        saveState();\n        queryFilter.emit('update').then(function () {\n          if (!doFetch) return;\n          queryFilter.emit('fetch');\n        });\n\n        // iterate over each state type, checking for changes\n        function getActions() {\n          var newFilters = [];\n          var oldFilters = [];\n\n          stateWatchers.forEach(function (watcher, i) {\n            var nextVal = next[i];\n            var prevVal = prev[i];\n            newFilters = newFilters.concat(nextVal);\n            oldFilters = oldFilters.concat(prevVal);\n\n            // no update or fetch if there was no change\n            if (nextVal === prevVal) return;\n\n            if (nextVal) doUpdate = true;\n\n            // don't trigger fetch when only disabled filters\n            if (!(0, _only_disabled.onlyDisabled)(nextVal, prevVal)) doFetch = true;\n          });\n\n          // make sure change wasn't only a state move\n          // checking length first is an optimization\n          if (doFetch && newFilters.length === oldFilters.length) {\n            if ((0, _only_state_changed.onlyStateChanged)(newFilters, oldFilters)) doFetch = false;\n          }\n        }\n      });\n    }\n  }\n}",null]}