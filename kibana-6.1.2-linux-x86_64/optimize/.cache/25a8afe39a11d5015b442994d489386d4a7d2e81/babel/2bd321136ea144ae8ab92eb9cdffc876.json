{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/management/sections/indices/create_index_pattern_wizard/create_index_pattern_wizard.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/management/sections/indices/create_index_pattern_wizard/create_index_pattern_wizard.js","mtime":1515552029000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _errors = require('ui/errors');\n\nrequire('ui/directives/validate_index_pattern');\n\nrequire('ui/directives/auto_select_if_only_one');\n\nrequire('ui/directives/documentation_href');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _modules = require('ui/modules');\n\nvar _create_index_pattern_wizard = require('./create_index_pattern_wizard.html');\n\nvar _create_index_pattern_wizard2 = _interopRequireDefault(_create_index_pattern_wizard);\n\nvar _send_create_index_pattern_request = require('./send_create_index_pattern_request');\n\nrequire('./step_index_pattern');\n\nrequire('./step_time_field');\n\nrequire('./matching_indices_list');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n_routes2.default.when('/management/kibana/index', {\n  template: _create_index_pattern_wizard2.default\n});\n\n_modules.uiModules.get('apps/management').controller('managementIndicesCreate', function ($routeParams, $scope, $timeout, config, es, indexPatterns, kbnUrl, Notifier, Promise) {\n  var _this = this;\n\n  // This isn't ideal. We want to avoid searching for 20 indices\n  // then filtering out the majority of them because they are sysetm indices.\n  // We'd like to filter system indices out in the query\n  // so if we can accomplish that in the future, this logic can go away\n  var ESTIMATED_NUMBER_OF_SYSTEM_INDICES = 20;\n  var MAX_NUMBER_OF_MATCHING_INDICES = 20;\n  var MAX_SEARCH_SIZE = MAX_NUMBER_OF_MATCHING_INDICES + ESTIMATED_NUMBER_OF_SYSTEM_INDICES;\n  var notify = new Notifier();\n  var disabledDividerOption = {\n    isDisabled: true,\n    display: '───'\n  };\n  var noTimeFieldOption = {\n    display: 'I don\\'t want to use the Time Filter'\n  };\n\n  // Configure the new index pattern we're going to create.\n  this.formValues = {\n    id: $routeParams.id ? decodeURIComponent($routeParams.id) : undefined,\n    name: '',\n    expandWildcard: false,\n    timeFieldOption: undefined\n  };\n\n  // UI state.\n  this.timeFieldOptions = [];\n  this.wizardStep = 'indexPattern';\n  this.isFetchingExistingIndices = true;\n  this.isFetchingMatchingIndices = false;\n  this.isFetchingTimeFieldOptions = false;\n  this.isCreatingIndexPattern = false;\n  this.doesIncludeSystemIndices = false;\n  var allIndices = [];\n  var matchingIndices = [];\n  var partialMatchingIndices = [];\n  this.allIndices = [];\n  this.matchingIndices = [];\n  this.partialMatchingIndices = [];\n\n  function createReasonableWait() {\n    return new Promise(function (resolve) {\n      // Make every fetch take a set amount of time so the user gets some feedback that something\n      // is happening.\n      $timeout(function () {\n        resolve();\n      }, 500);\n    });\n  }\n\n  function getIndices(rawPattern) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_SEARCH_SIZE;\n\n    var pattern = rawPattern.trim();\n\n    // Searching for `*:` fails for CCS environments. The search request\n    // is worthless anyways as the we should only send a request\n    // for a specific query (where we do not append *) if there is at\n    // least a single character being searched for.\n    if (pattern === '*:') {\n      return [];\n    }\n\n    var params = {\n      index: pattern,\n      ignore: [404],\n      body: {\n        size: 0, // no hits\n        aggs: {\n          indices: {\n            terms: {\n              field: '_index',\n              size: limit\n            }\n          }\n        }\n      }\n    };\n\n    return es.search(params).then(function (response) {\n      if (!response || response.error || !response.aggregations) {\n        return [];\n      }\n\n      return _lodash2.default.sortBy(response.aggregations.indices.buckets.map(function (bucket) {\n        return {\n          name: bucket.key\n        };\n      }), 'name');\n    }).catch(function (err) {\n      var type = _lodash2.default.get(err, 'body.error.caused_by.type');\n      if (type === 'index_not_found_exception') {\n        // This happens in a CSS environment when the controlling node returns a 500 even though the data\n        // nodes returned a 404. Remove this when/if this is handled: https://github.com/elastic/elasticsearch/issues/27461\n        return [];\n      }\n      throw err;\n    });\n  }\n\n  var whiteListIndices = function whiteListIndices(indices) {\n    if (!indices) {\n      return indices;\n    }\n\n    var acceptableIndices = _this.doesIncludeSystemIndices ? indices\n    // All system indices begin with a period.\n    : indices.filter(function (index) {\n      return !index.name.startsWith('.');\n    });\n\n    return acceptableIndices.slice(0, MAX_NUMBER_OF_MATCHING_INDICES);\n  };\n\n  var updateWhiteListedIndices = function updateWhiteListedIndices() {\n    _this.allIndices = whiteListIndices(allIndices);\n    _this.matchingIndices = whiteListIndices(matchingIndices);\n    _this.partialMatchingIndices = whiteListIndices(partialMatchingIndices);\n  };\n\n  this.onIncludeSystemIndicesChange = function () {\n    updateWhiteListedIndices();\n  };\n\n  var mostRecentFetchMatchingIndicesRequest = void 0;\n\n  this.fetchMatchingIndices = function () {\n    _this.isFetchingMatchingIndices = true;\n\n    // Default to searching for all indices.\n    var exactSearchQuery = _this.formValues.name;\n    var partialSearchQuery = _this.formValues.name;\n\n    if (!_lodash2.default.endsWith(partialSearchQuery, '*')) {\n      partialSearchQuery = partialSearchQuery + '*';\n    }\n    if (!_lodash2.default.startsWith(partialSearchQuery, '*')) {\n      partialSearchQuery = '*' + partialSearchQuery;\n    }\n\n    var thisFetchMatchingIndicesRequest = mostRecentFetchMatchingIndicesRequest = Promise.all([getIndices(exactSearchQuery), getIndices(partialSearchQuery), createReasonableWait()]).then(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          matchingIndicesResponse = _ref2[0],\n          partialMatchingIndicesResponse = _ref2[1];\n\n      if (thisFetchMatchingIndicesRequest === mostRecentFetchMatchingIndicesRequest) {\n        matchingIndices = matchingIndicesResponse;\n        partialMatchingIndices = partialMatchingIndicesResponse;\n        updateWhiteListedIndices();\n        _this.isFetchingMatchingIndices = false;\n      }\n    }).catch(function (error) {\n      notify.error(error);\n    });\n  };\n\n  this.fetchExistingIndices = function () {\n    _this.isFetchingExistingIndices = true;\n    var allExistingLocalIndicesPattern = '*';\n\n    Promise.all([getIndices(allExistingLocalIndicesPattern), createReasonableWait()]).then(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          allIndicesResponse = _ref4[0];\n\n      // Cache all indices.\n      allIndices = allIndicesResponse;\n      updateWhiteListedIndices();\n      _this.isFetchingExistingIndices = false;\n    }).catch(function (error) {\n      notify.error(error);\n      _this.isFetchingExistingIndices = false;\n    });\n  };\n\n  this.isSystemIndicesCheckBoxVisible = function () {\n    return _this.wizardStep === 'indexPattern';\n  };\n\n  this.goToIndexPatternStep = function () {\n    _this.wizardStep = 'indexPattern';\n  };\n\n  this.goToTimeFieldStep = function () {\n    // Re-initialize this step.\n    _this.formValues.timeFieldOption = undefined;\n    _this.fetchTimeFieldOptions();\n    _this.wizardStep = 'timeField';\n  };\n\n  this.hasIndices = function () {\n    return _this.allIndices.length;\n  };\n\n  var extractTimeFieldsFromFields = function extractTimeFieldsFromFields(fields) {\n    var dateFields = fields.filter(function (field) {\n      return field.type === 'date';\n    });\n\n    if (dateFields.length === 0) {\n      return [{\n        display: 'The indices which match this index pattern don\\'t contain any time fields.'\n      }];\n    }\n\n    return [].concat(_toConsumableArray(dateFields.map(function (field) {\n      return {\n        display: field.name,\n        fieldName: field.name\n      };\n    })), [disabledDividerOption, noTimeFieldOption]);\n  };\n\n  this.fetchTimeFieldOptions = function () {\n    _this.isFetchingTimeFieldOptions = true;\n    _this.formValues.timeFieldOption = undefined;\n    _this.timeFieldOptions = [];\n\n    Promise.all([indexPatterns.fieldsFetcher.fetchForWildcard(_this.formValues.name), createReasonableWait()]).then(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          fields = _ref6[0];\n\n      _this.timeFieldOptions = extractTimeFieldsFromFields(fields);\n    }).catch(function (error) {\n      notify.error(error);\n    }).finally(function () {\n      _this.isFetchingTimeFieldOptions = false;\n    });\n  };\n\n  this.createIndexPattern = function () {\n    _this.isCreatingIndexPattern = true;\n\n    var _formValues = _this.formValues,\n        id = _formValues.id,\n        name = _formValues.name,\n        timeFieldOption = _formValues.timeFieldOption;\n\n\n    var timeFieldName = timeFieldOption ? timeFieldOption.fieldName : undefined;\n\n    (0, _send_create_index_pattern_request.sendCreateIndexPatternRequest)(indexPatterns, {\n      id: id,\n      name: name,\n      timeFieldName: timeFieldName\n    }).then(function (createdId) {\n      if (!createdId) {\n        return;\n      }\n\n      if (!config.get('defaultIndex')) {\n        config.set('defaultIndex', createdId);\n      }\n\n      indexPatterns.cache.clear(createdId);\n      kbnUrl.change('/management/kibana/indices/' + createdId);\n    }).catch(function (err) {\n      if (err instanceof _errors.IndexPatternMissingIndices) {\n        return notify.error('Couldn\\'t locate any indices matching that pattern. Please add the index to Elasticsearch');\n      }\n\n      notify.fatal(err);\n    }).finally(function () {\n      _this.isCreatingIndexPattern = false;\n    });\n  };\n\n  this.fetchExistingIndices();\n});",null]}