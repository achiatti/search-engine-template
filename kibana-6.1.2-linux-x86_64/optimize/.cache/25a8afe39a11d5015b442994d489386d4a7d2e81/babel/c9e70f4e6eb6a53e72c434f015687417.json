{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/dashboard/dashboard_state_manager.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/dashboard/dashboard_state_manager.js","mtime":1515552028000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DashboardStateManager = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _dashboard_view_mode = require('./dashboard_view_mode');\n\nvar _filter_utils = require('./lib/filter_utils');\n\nvar _panel_utils = require('./panel/panel_utils');\n\nvar _store = require('../store');\n\nvar _actions = require('./actions');\n\nvar _state_monitor_factory = require('ui/state_management/state_monitor_factory');\n\nvar _panel = require('./panel');\n\nvar _lib = require('./lib');\n\nvar _selectors = require('../selectors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dashboard state manager handles connecting angular and redux state between the angular and react portions of the\n * app. There are two \"sources of truth\" that need to stay in sync - AppState and the Store. They aren't complete\n * duplicates of each other as AppState has state that the Store doesn't, and vice versa.\n *\n * State that is only stored in AppState:\n *  - title\n *  - description\n *  - timeRestore\n *  - query\n *  - uiState\n *  - filters\n *\n * State that is only stored in the Store:\n *  - embeddables\n *  - maximizedPanelId\n *\n * State that is shared and needs to be synced:\n * - fullScreenMode - changes propagate from AppState -> Store and from Store -> AppState.\n * - viewMode - changes only propagate from AppState -> Store\n * - panels - changes propagate from AppState -> Store and from Store -> AppState.\n *\n *\n */\nvar DashboardStateManager = exports.DashboardStateManager = function () {\n  /**\n   *\n   * @param savedDashboard {SavedDashboard}\n   * @param AppState {AppState} The AppState class to use when instantiating a new AppState instance.\n   * @param hideWriteControls {boolean} true if write controls should be hidden.\n   */\n  function DashboardStateManager(savedDashboard, AppState, hideWriteControls) {\n    var _this = this;\n\n    _classCallCheck(this, DashboardStateManager);\n\n    this.savedDashboard = savedDashboard;\n    this.hideWriteControls = hideWriteControls;\n\n    this.stateDefaults = (0, _lib.getAppStateDefaults)(this.savedDashboard, this.hideWriteControls);\n\n    this.appState = new AppState(this.stateDefaults);\n    this.uiState = this.appState.makeStateful('uiState');\n    this.isDirty = false;\n\n    // We can't compare the filters stored on this.appState to this.savedDashboard because in order to apply\n    // the filters to the visualizations, we need to save it on the dashboard. We keep track of the original\n    // filter state in order to let the user know if their filters changed and provide this specific information\n    // in the 'lose changes' warning message.\n    this.lastSavedDashboardFilters = this.getFilterState();\n\n    // A mapping of panel index to the index pattern it uses.\n    this.panelIndexPatternMapping = {};\n\n    _panel_utils.PanelUtils.initPanelIndexes(this.getPanels());\n    this.createStateMonitor();\n\n    // Always start out with all panels minimized when a dashboard is first loaded.\n    _store.store.dispatch((0, _actions.minimizePanel)());\n    _store.store.dispatch((0, _actions.setPanels)(this.getPanels()));\n    _store.store.dispatch((0, _actions.updateViewMode)(this.getViewMode()));\n    _store.store.dispatch((0, _actions.updateUseMargins)(this.getUseMargins()));\n    _store.store.dispatch((0, _actions.updateHidePanelTitles)(this.getHidePanelTitles()));\n    _store.store.dispatch((0, _actions.updateIsFullScreenMode)(this.getFullScreenMode()));\n    _store.store.dispatch((0, _actions.updateTitle)(this.getTitle()));\n    _store.store.dispatch((0, _actions.updateDescription)(this.getDescription()));\n\n    this.changeListeners = [];\n\n    this.unsubscribe = _store.store.subscribe(function () {\n      return _this._handleStoreChanges();\n    });\n    this.stateMonitor.onChange(function (status) {\n      _this.changeListeners.forEach(function (listener) {\n        return listener(status);\n      });\n      _this._pushAppStateChangesToStore();\n    });\n  }\n\n  _createClass(DashboardStateManager, [{\n    key: 'registerChangeListener',\n    value: function registerChangeListener(callback) {\n      this.changeListeners.push(callback);\n    }\n  }, {\n    key: '_areStoreAndAppStatePanelsEqual',\n    value: function _areStoreAndAppStatePanelsEqual() {\n      var state = _store.store.getState();\n      // We need to run this comparison check or we can enter an infinite loop.\n      var differencesFound = false;\n      for (var i = 0; i < this.appState.panels.length; i++) {\n        var appStatePanel = this.appState.panels[i];\n        var storePanel = (0, _selectors.getPanel)(state, appStatePanel.panelIndex);\n        if (!_lodash2.default.isEqual(appStatePanel, storePanel)) {\n          differencesFound = true;\n          break;\n        }\n      }\n\n      return !differencesFound;\n    }\n\n    /**\n     * Changes made to app state outside of direct calls to this class will need to be propagated to the store.\n     * @private\n     */\n\n  }, {\n    key: '_pushAppStateChangesToStore',\n    value: function _pushAppStateChangesToStore() {\n      // We need these checks, or you can get into a loop where a change is triggered by the store, which updates\n      // AppState, which then dispatches the change here, which will end up triggering setState warnings.\n      if (!this._areStoreAndAppStatePanelsEqual()) {\n        _store.store.dispatch((0, _actions.setPanels)(this.getPanels()));\n      }\n\n      var state = _store.store.getState();\n      if ((0, _selectors.getViewMode)(state) !== this.getViewMode()) {\n        _store.store.dispatch((0, _actions.updateViewMode)(this.getViewMode()));\n      }\n\n      if ((0, _selectors.getUseMargins)(state) !== this.getUseMargins()) {\n        _store.store.dispatch((0, _actions.updateUseMargins)(this.getUseMargins()));\n      }\n\n      if ((0, _selectors.getHidePanelTitles)(state) !== this.getHidePanelTitles()) {\n        _store.store.dispatch((0, _actions.updateHidePanelTitles)(this.getHidePanelTitles()));\n      }\n\n      if ((0, _selectors.getFullScreenMode)(state) !== this.getFullScreenMode()) {\n        _store.store.dispatch((0, _actions.updateIsFullScreenMode)(this.getFullScreenMode()));\n      }\n\n      if ((0, _selectors.getTitle)(state) !== this.getTitle()) {\n        _store.store.dispatch((0, _actions.updateTitle)(this.getTitle()));\n      }\n\n      if ((0, _selectors.getDescription)(state) !== this.getDescription()) {\n        _store.store.dispatch((0, _actions.updateDescription)(this.getDescription()));\n      }\n    }\n  }, {\n    key: '_handleStoreChanges',\n    value: function _handleStoreChanges() {\n      var _this2 = this;\n\n      var dirty = false;\n      if (!this._areStoreAndAppStatePanelsEqual()) {\n        var panels = (0, _selectors.getPanels)(_store.store.getState());\n        this.appState.panels = [];\n        Object.values(panels).map(function (panel) {\n          _this2.appState.panels.push(panel);\n        });\n        dirty = true;\n      }\n\n      var fullScreen = (0, _selectors.getFullScreenMode)(_store.store.getState());\n      if (fullScreen !== this.getFullScreenMode()) {\n        this.setFullScreenMode(fullScreen);\n      }\n\n      this.changeListeners.forEach(function (listener) {\n        return listener({ dirty: dirty });\n      });\n      this.saveState();\n    }\n  }, {\n    key: 'getFullScreenMode',\n    value: function getFullScreenMode() {\n      return this.appState.fullScreenMode;\n    }\n  }, {\n    key: 'setFullScreenMode',\n    value: function setFullScreenMode(fullScreenMode) {\n      this.appState.fullScreenMode = fullScreenMode;\n      this.saveState();\n    }\n  }, {\n    key: 'registerPanelIndexPatternMap',\n    value: function registerPanelIndexPatternMap(panelIndex, indexPattern) {\n      if (indexPattern) {\n        this.panelIndexPatternMapping[panelIndex] = indexPattern;\n      }\n    }\n  }, {\n    key: 'getPanelIndexPatterns',\n    value: function getPanelIndexPatterns() {\n      return _lodash2.default.uniq(Object.values(this.panelIndexPatternMapping));\n    }\n\n    /**\n     * Resets the state back to the last saved version of the dashboard.\n     */\n\n  }, {\n    key: 'resetState',\n    value: function resetState() {\n      // In order to show the correct warning for the saved-object-save-as-check-box we have to store the unsaved\n      // title on the dashboard object. We should fix this at some point, but this is how all the other object\n      // save panels work at the moment.\n      this.savedDashboard.title = this.savedDashboard.lastSavedTitle;\n\n      // appState.reset uses the internal defaults to reset the state, but some of the default settings (e.g. the panels\n      // array) point to the same object that is stored on appState and is getting modified.\n      // The right way to fix this might be to ensure the defaults object stored on state is a deep\n      // clone, but given how much code uses the state object, I determined that to be too risky of a change for\n      // now.  TODO: revisit this!\n      this.stateDefaults = (0, _lib.getAppStateDefaults)(this.savedDashboard, this.hideWriteControls);\n      // The original query won't be restored by the above because the query on this.savedDashboard is applied\n      // in place in order for it to affect the visualizations.\n      this.stateDefaults.query = this.lastSavedDashboardFilters.query;\n      // Need to make a copy to ensure they are not overwritten.\n      this.stateDefaults.filters = [].concat(_toConsumableArray(this.getLastSavedFilterBars()));\n\n      this.isDirty = false;\n      this.appState.setDefaults(this.stateDefaults);\n      this.appState.reset();\n      this.stateMonitor.setInitialState(this.appState.toJSON());\n    }\n\n    /**\n     * Returns an object which contains the current filter state of this.savedDashboard.\n     * @returns {{timeTo: String, timeFrom: String, filterBars: Array, query: Object}}\n     */\n\n  }, {\n    key: 'getFilterState',\n    value: function getFilterState() {\n      return {\n        timeTo: this.savedDashboard.timeTo,\n        timeFrom: this.savedDashboard.timeFrom,\n        filterBars: this.getDashboardFilterBars(),\n        query: this.getDashboardQuery()\n      };\n    }\n  }, {\n    key: 'getTitle',\n    value: function getTitle() {\n      return this.appState.title;\n    }\n  }, {\n    key: 'getDescription',\n    value: function getDescription() {\n      return this.appState.description;\n    }\n  }, {\n    key: 'setDescription',\n    value: function setDescription(description) {\n      this.appState.description = description;\n      this.saveState();\n    }\n  }, {\n    key: 'setTitle',\n    value: function setTitle(title) {\n      this.appState.title = title;\n      // The saved-object-save-as-check-box shows a warning if the current object title is different then\n      // the existing object title. It calculates this difference by comparing this.dashboard.title to\n      // this.dashboard.lastSavedTitle, so we need to push the temporary, unsaved title, onto the dashboard.\n      this.savedDashboard.title = title;\n      this.saveState();\n    }\n  }, {\n    key: 'getAppState',\n    value: function getAppState() {\n      return this.appState;\n    }\n  }, {\n    key: 'getQuery',\n    value: function getQuery() {\n      return this.appState.query;\n    }\n  }, {\n    key: 'getUseMargins',\n    value: function getUseMargins() {\n      // Existing dashboards that don't define this should default to false.\n      return this.appState.options.useMargins === undefined ? false : this.appState.options.useMargins;\n    }\n  }, {\n    key: 'setUseMargins',\n    value: function setUseMargins(useMargins) {\n      this.appState.options.useMargins = useMargins;\n      this.saveState();\n    }\n  }, {\n    key: 'getHidePanelTitles',\n    value: function getHidePanelTitles() {\n      return this.appState.options.hidePanelTitles;\n    }\n  }, {\n    key: 'setHidePanelTitles',\n    value: function setHidePanelTitles(hidePanelTitles) {\n      this.appState.options.hidePanelTitles = hidePanelTitles;\n      this.saveState();\n    }\n  }, {\n    key: 'getDarkTheme',\n    value: function getDarkTheme() {\n      return this.appState.options.darkTheme;\n    }\n  }, {\n    key: 'setDarkTheme',\n    value: function setDarkTheme(darkTheme) {\n      this.appState.options.darkTheme = darkTheme;\n      this.saveState();\n    }\n  }, {\n    key: 'getTimeRestore',\n    value: function getTimeRestore() {\n      return this.appState.timeRestore;\n    }\n  }, {\n    key: 'setTimeRestore',\n    value: function setTimeRestore(timeRestore) {\n      this.appState.timeRestore = timeRestore;\n      this.saveState();\n    }\n\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'getIsTimeSavedWithDashboard',\n    value: function getIsTimeSavedWithDashboard() {\n      return this.savedDashboard.timeRestore;\n    }\n  }, {\n    key: 'getDashboardFilterBars',\n    value: function getDashboardFilterBars() {\n      return _filter_utils.FilterUtils.getFilterBarsForDashboard(this.savedDashboard);\n    }\n  }, {\n    key: 'getDashboardQuery',\n    value: function getDashboardQuery() {\n      return _filter_utils.FilterUtils.getQueryFilterForDashboard(this.savedDashboard);\n    }\n  }, {\n    key: 'getLastSavedFilterBars',\n    value: function getLastSavedFilterBars() {\n      return this.lastSavedDashboardFilters.filterBars;\n    }\n  }, {\n    key: 'getLastSavedQuery',\n    value: function getLastSavedQuery() {\n      return this.lastSavedDashboardFilters.query;\n    }\n\n    /**\n     * @returns {boolean} True if the query changed since the last time the dashboard was saved, or if it's a\n     * new dashboard, if the query differs from the default.\n     */\n\n  }, {\n    key: 'getQueryChanged',\n    value: function getQueryChanged() {\n      var currentQuery = this.appState.query;\n      var lastSavedQuery = this.getLastSavedQuery();\n\n      var isLegacyStringQuery = _lodash2.default.isString(lastSavedQuery) && _lodash2.default.isPlainObject(currentQuery) && _lodash2.default.has(currentQuery, 'query');\n      if (isLegacyStringQuery) {\n        return lastSavedQuery !== currentQuery.query;\n      }\n\n      return !_lodash2.default.isEqual(currentQuery, lastSavedQuery);\n    }\n\n    /**\n     * @returns {boolean} True if the filter bar state has changed since the last time the dashboard was saved,\n     * or if it's a new dashboard, if the query differs from the default.\n     */\n\n  }, {\n    key: 'getFilterBarChanged',\n    value: function getFilterBarChanged() {\n      return !_lodash2.default.isEqual(_filter_utils.FilterUtils.cleanFiltersForComparison(this.appState.filters), _filter_utils.FilterUtils.cleanFiltersForComparison(this.getLastSavedFilterBars()));\n    }\n\n    /**\n     * @param timeFilter\n     * @returns {boolean} True if the time state has changed since the time saved with the dashboard.\n     */\n\n  }, {\n    key: 'getTimeChanged',\n    value: function getTimeChanged(timeFilter) {\n      return !_filter_utils.FilterUtils.areTimesEqual(this.lastSavedDashboardFilters.timeFrom, timeFilter.time.from) || !_filter_utils.FilterUtils.areTimesEqual(this.lastSavedDashboardFilters.timeTo, timeFilter.time.to);\n    }\n\n    /**\n     *\n     * @returns {DashboardViewMode}\n     */\n\n  }, {\n    key: 'getViewMode',\n    value: function getViewMode() {\n      return this.hideWriteControls ? _dashboard_view_mode.DashboardViewMode.VIEW : this.appState.viewMode;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'getIsViewMode',\n    value: function getIsViewMode() {\n      return this.getViewMode() === _dashboard_view_mode.DashboardViewMode.VIEW;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'getIsEditMode',\n    value: function getIsEditMode() {\n      return this.getViewMode() === _dashboard_view_mode.DashboardViewMode.EDIT;\n    }\n\n    /**\n     *\n     * @returns {boolean} True if the dashboard has changed since the last save (or, is new).\n     */\n\n  }, {\n    key: 'getIsDirty',\n    value: function getIsDirty(timeFilter) {\n      return this.isDirty ||\n      // Filter bar comparison is done manually (see cleanFiltersForComparison for the reason) and time picker\n      // changes are not tracked by the state monitor.\n      this.getFiltersChanged(timeFilter);\n    }\n  }, {\n    key: 'getPanels',\n    value: function getPanels() {\n      return this.appState.panels;\n    }\n  }, {\n    key: 'updatePanel',\n    value: function updatePanel(panelIndex, panelAttributes) {\n      var panel = this.getPanels().find(function (panel) {\n        return panel.panelIndex === panelIndex;\n      });\n      Object.assign(panel, panelAttributes);\n      this.saveState();\n      return panel;\n    }\n\n    /**\n     * Creates and initializes a basic panel, adding it to the state.\n     * @param {number} id\n     * @param {string} type\n     */\n\n  }, {\n    key: 'addNewPanel',\n    value: function addNewPanel(id, type) {\n      var maxPanelIndex = _panel_utils.PanelUtils.getMaxPanelIndex(this.getPanels());\n      var newPanel = (0, _panel.createPanelState)(id, type, maxPanelIndex, this.getPanels());\n      this.getPanels().push(newPanel);\n      this.saveState();\n    }\n  }, {\n    key: 'removePanel',\n    value: function removePanel(panelIndex) {\n      var _this3 = this;\n\n      _lodash2.default.remove(this.getPanels(), function (panel) {\n        if (panel.panelIndex === panelIndex) {\n          _this3.uiState.removeChild((0, _panel.getPersistedStateId)(panel));\n          delete _this3.panelIndexPatternMapping[panelIndex];\n          return true;\n        } else {\n          return false;\n        }\n      });\n      this.saveState();\n    }\n\n    /**\n     * @param timeFilter\n     * @returns {Array.<string>} An array of user friendly strings indicating the filter types that have changed.\n     */\n\n  }, {\n    key: 'getChangedFilterTypes',\n    value: function getChangedFilterTypes(timeFilter) {\n      var changedFilters = [];\n      if (this.getFilterBarChanged()) {\n        changedFilters.push('filter');\n      }\n      if (this.getQueryChanged()) {\n        changedFilters.push('query');\n      }\n      if (this.savedDashboard.timeRestore && this.getTimeChanged(timeFilter)) {\n        changedFilters.push('time range');\n      }\n      return changedFilters;\n    }\n\n    /**\n     * @return {boolean} True if filters (query, filter bar filters, and time picker if time is stored\n     * with the dashboard) have changed since the last saved state (or if the dashboard hasn't been saved,\n     * the default state).\n     */\n\n  }, {\n    key: 'getFiltersChanged',\n    value: function getFiltersChanged(timeFilter) {\n      return this.getChangedFilterTypes(timeFilter).length > 0;\n    }\n\n    /**\n     * Updates timeFilter to match the time saved with the dashboard.\n     * @param timeFilter\n     * @param quickTimeRanges\n     */\n\n  }, {\n    key: 'syncTimefilterWithDashboard',\n    value: function syncTimefilterWithDashboard(timeFilter, quickTimeRanges) {\n      var _this4 = this;\n\n      if (!this.getIsTimeSavedWithDashboard()) {\n        throw new Error('The time is not saved with this dashboard so should not be synced.');\n      }\n\n      timeFilter.time.to = this.savedDashboard.timeTo;\n      timeFilter.time.from = this.savedDashboard.timeFrom;\n      var isMoment = (0, _moment2.default)(this.savedDashboard.timeTo).isValid();\n      if (isMoment) {\n        timeFilter.time.mode = 'absolute';\n      } else {\n        var quickTime = _lodash2.default.find(quickTimeRanges, function (timeRange) {\n          return timeRange.from === _this4.savedDashboard.timeFrom && timeRange.to === _this4.savedDashboard.timeTo;\n        });\n\n        timeFilter.time.mode = quickTime ? 'quick' : 'relative';\n      }\n      if (this.savedDashboard.refreshInterval) {\n        timeFilter.refreshInterval = this.savedDashboard.refreshInterval;\n      }\n    }\n\n    /**\n     * Saves the current application state to the URL.\n     */\n\n  }, {\n    key: 'saveState',\n    value: function saveState() {\n      this.appState.save();\n    }\n\n    /**\n     * Applies the current filter state to the dashboard.\n     * @param filter {Array.<Object>} An array of filter bar filters.\n     */\n\n  }, {\n    key: 'applyFilters',\n    value: function applyFilters(query, filters) {\n      this.appState.query = query;\n      this.savedDashboard.searchSource.set('query', query);\n      this.savedDashboard.searchSource.set('filter', filters);\n      this.saveState();\n    }\n\n    /**\n     * Creates a state monitor and saves it to this.stateMonitor. Used to track unsaved changes made to appState.\n     */\n\n  }, {\n    key: 'createStateMonitor',\n    value: function createStateMonitor() {\n      var _this5 = this;\n\n      this.stateMonitor = _state_monitor_factory.stateMonitorFactory.create(this.appState, this.stateDefaults);\n\n      this.stateMonitor.ignoreProps('viewMode');\n      // Filters need to be compared manually because they sometimes have a $$hashkey stored on the object.\n      this.stateMonitor.ignoreProps('filters');\n      // Query needs to be compared manually because saved legacy queries get migrated in app state automatically\n      this.stateMonitor.ignoreProps('query');\n\n      this.stateMonitor.onChange(function (status) {\n        _this5.isDirty = status.dirty;\n      });\n    }\n\n    /**\n     * @param newMode {DashboardViewMode}\n     */\n\n  }, {\n    key: 'switchViewMode',\n    value: function switchViewMode(newMode) {\n      this.appState.viewMode = newMode;\n      this.saveState();\n    }\n\n    /**\n     * Destroys and cleans up this object when it's no longer used.\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this.stateMonitor) {\n        this.stateMonitor.destroy();\n      }\n      this.savedDashboard.destroy();\n      this.unsubscribe();\n    }\n  }]);\n\n  return DashboardStateManager;\n}();",null]}