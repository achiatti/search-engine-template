{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/registry/field_formats.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/registry/field_formats.js","mtime":1515552037000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RegistryFieldFormatsProvider = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _registry = require('ui/registry/_registry');\n\nvar _field_format = require('../../field_formats/field_format');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar RegistryFieldFormatsProvider = exports.RegistryFieldFormatsProvider = (0, _registry.uiRegistry)({\n  name: 'fieldFormats',\n  index: ['id'],\n  group: ['fieldType'],\n\n  invokeProviders: function invokeProviders(providers) {\n    // in order to ensure that FieldFormats can be instantiated on the\n    // server and the browser we don't provide them access to the Angular\n    // injector, just the FieldFormat class.\n    return providers.map(function (createSomeFormat) {\n      return createSomeFormat(_field_format.FieldFormat);\n    });\n  },\n\n\n  constructor: function constructor(config) {\n    var getConfig = function getConfig() {\n      return config.get.apply(config, arguments);\n    };\n    var self = this;\n    var defaultMap = void 0;\n\n    function init() {\n      config.watch('format:defaultTypeMap', parseDefaultTypeMap);\n    }\n\n    /**\n     * Get the id of the default type for this field type\n     * using the format:defaultTypeMap config map\n     *\n     * @param  {String} fieldType - the field type\n     * @return {String}\n     */\n    self.getDefaultConfig = function (fieldType) {\n      return defaultMap[fieldType] || defaultMap._default_;\n    };\n\n    /**\n     * Get a FieldFormat type (class) by it's id.\n     *\n     * @param  {String} formatId - the format id\n     * @return {Function}\n     */\n    self.getType = function (formatId) {\n      return self.byId[formatId];\n    };\n\n    /**\n     * Get the default FieldFormat type (class) for\n     * a field type, using the format:defaultTypeMap.\n     *\n     * @param  {String} fieldType\n     * @return {Function}\n     */\n    self.getDefaultType = function (fieldType) {\n      return self.byId[self.getDefaultConfig(fieldType).id];\n    };\n\n    /**\n     * Get the singleton instance of the FieldFormat type by it's id.\n     *\n     * @param  {String} formatId\n     * @return {FieldFormat}\n     */\n    self.getInstance = _lodash2.default.memoize(function (formatId) {\n      var FieldFormat = self.byId[formatId];\n      return new FieldFormat(null, getConfig);\n    });\n\n    /**\n     * Get the default fieldFormat instance for a field format.\n     *\n     * @param  {String} fieldType\n     * @return {FieldFormat}\n     */\n    self.getDefaultInstance = _lodash2.default.memoize(function (fieldType) {\n      var conf = self.getDefaultConfig(fieldType);\n      var FieldFormat = self.byId[conf.id];\n      return new FieldFormat(conf.params, getConfig);\n    });\n\n    function parseDefaultTypeMap(value) {\n      defaultMap = value;\n      _lodash2.default.forOwn(self, function (fn) {\n        if (_lodash2.default.isFunction(fn) && fn.cache) {\n          // clear all memoize caches\n          fn.cache = new _lodash2.default.memoize.Cache();\n        }\n      });\n    }\n\n    init();\n  }\n});",null]}