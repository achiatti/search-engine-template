{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/state_management/state.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/state_management/state.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StateProvider = StateProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _risonNode = require('rison-node');\n\nvar _risonNode2 = _interopRequireDefault(_risonNode);\n\nvar _diff_object = require('ui/utils/diff_object');\n\nvar _events = require('ui/events');\n\nvar _notifier = require('ui/notify/notifier');\n\nvar _state_storage = require('./state_storage');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction StateProvider(Private, $rootScope, $location, config, kbnUrl) {\n  var Events = Private(_events.EventsProvider);\n\n  _lodash2.default.class(State).inherits(Events);\n  function State(urlParam, defaults) {\n    var _this = this;\n\n    var hashedItemStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _state_storage.HashedItemStoreSingleton;\n    var notifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _notifier.Notifier();\n\n    State.Super.call(this);\n\n    this.setDefaults(defaults);\n    this._urlParam = urlParam || '_s';\n    this._notifier = notifier;\n    this._hashedItemStore = hashedItemStore;\n\n    // When the URL updates we need to fetch the values from the URL\n    this._cleanUpListeners = _lodash2.default.partial(_lodash2.default.callEach, [\n    // partial route update, no app reload\n    $rootScope.$on('$routeUpdate', function () {\n      _this.fetch();\n    }),\n\n    // beginning of full route update, new app will be initialized before\n    // $routeChangeSuccess or $routeChangeError\n    $rootScope.$on('$routeChangeStart', function () {\n      if (!_this._persistAcrossApps) {\n        _this.destroy();\n      }\n    }), $rootScope.$on('$routeChangeSuccess', function () {\n      if (_this._persistAcrossApps) {\n        _this.fetch();\n      }\n    })]);\n\n    // Initialize the State with fetch\n    this.fetch();\n  }\n\n  State.prototype._readFromURL = function () {\n    var search = $location.search();\n    var urlVal = search[this._urlParam];\n\n    if (!urlVal) {\n      return null;\n    }\n\n    if ((0, _state_storage.isStateHash)(urlVal)) {\n      return this._parseStateHash(urlVal);\n    }\n\n    var risonEncoded = void 0;\n    var unableToParse = void 0;\n    try {\n      risonEncoded = _risonNode2.default.decode(urlVal);\n    } catch (e) {\n      unableToParse = true;\n    }\n\n    if (unableToParse) {\n      this._notifier.error('Unable to parse URL');\n      search[this._urlParam] = this.toQueryParam(this._defaults);\n      $location.search(search).replace();\n    }\n\n    if (!risonEncoded) {\n      return null;\n    }\n\n    if (this.isHashingEnabled()) {\n      // RISON can find its way into the URL any number of ways, including the navbar links or\n      // shared urls with the entire state embedded. These values need to be translated into\n      // hashes and replaced in the browser history when state-hashing is enabled\n      search[this._urlParam] = this.toQueryParam(risonEncoded);\n      $location.search(search).replace();\n    }\n\n    return risonEncoded;\n  };\n\n  /**\n   * Fetches the state from the url\n   * @returns {void}\n   */\n  State.prototype.fetch = function () {\n    var stash = this._readFromURL();\n\n    // nothing to read from the url? save if ordered to persist\n    if (stash === null) {\n      if (this._persistAcrossApps) {\n        return this.save();\n      } else {\n        stash = {};\n      }\n    }\n\n    _lodash2.default.defaults(stash, this._defaults);\n    // apply diff to state from stash, will change state in place via side effect\n    var diffResults = (0, _diff_object.applyDiff)(this, stash);\n\n    if (diffResults.keys.length) {\n      this.emit('fetch_with_changes', diffResults.keys);\n    }\n  };\n\n  /**\n   * Saves the state to the url\n   * @returns {void}\n   */\n  State.prototype.save = function (replace) {\n    var stash = this._readFromURL();\n    var state = this.toObject();\n    replace = replace || false;\n\n    if (!stash) {\n      replace = true;\n      stash = {};\n    }\n\n    // apply diff to state from stash, will change state in place via side effect\n    var diffResults = (0, _diff_object.applyDiff)(stash, _lodash2.default.defaults({}, state, this._defaults));\n\n    if (diffResults.keys.length) {\n      this.emit('save_with_changes', diffResults.keys);\n    }\n\n    // persist the state in the URL\n    var search = $location.search();\n    search[this._urlParam] = this.toQueryParam(state);\n    if (replace) {\n      $location.search(search).replace();\n    } else {\n      $location.search(search);\n    }\n  };\n\n  /**\n   * Calls save with a forced replace\n   * @returns {void}\n   */\n  State.prototype.replace = function () {\n    this.save(true);\n  };\n\n  /**\n   * Resets the state to the defaults\n   *\n   * @returns {void}\n   */\n  State.prototype.reset = function () {\n    kbnUrl.removeParam(this.getQueryParamName());\n    // apply diff to attributes from defaults, this is side effecting so\n    // it will change the state in place.\n    var diffResults = (0, _diff_object.applyDiff)(this, this._defaults);\n    if (diffResults.keys.length) {\n      this.emit('reset_with_changes', diffResults.keys);\n    }\n    this.save();\n  };\n\n  /**\n   * Cleans up the state object\n   * @returns {void}\n   */\n  State.prototype.destroy = function () {\n    this.off(); // removes all listeners\n    this._cleanUpListeners(); // Removes the $routeUpdate listener\n  };\n\n  State.prototype.setDefaults = function (defaults) {\n    this._defaults = defaults || {};\n  };\n\n  /**\n   *  Parse the state hash to it's unserialized value. Hashes are restored\n   *  to their pre-hashed state.\n   *\n   *  @param  {string} stateHash - state hash value from the query string.\n   *  @return {any} - the stored value, or null if hash does not resolve.\n   */\n  State.prototype._parseStateHash = function (stateHash) {\n    var json = this._hashedItemStore.getItem(stateHash);\n    if (json === null) {\n      this._notifier.error('Unable to completely restore the URL, be sure to use the share functionality.');\n    }\n\n    return JSON.parse(json);\n  };\n\n  /**\n   *  Lookup the value for a hash and return it's value in rison format or just\n   *  return passed argument if it's not recognized as state hash.\n   *\n   *  @param  {string} stateHashOrRison - either state hash value or rison string.\n   *  @return {string} rison\n   */\n  State.prototype.translateHashToRison = function (stateHashOrRison) {\n    if ((0, _state_storage.isStateHash)(stateHashOrRison)) {\n      return _risonNode2.default.encode(this._parseStateHash(stateHashOrRison));\n    }\n\n    return stateHashOrRison;\n  };\n\n  State.prototype.isHashingEnabled = function () {\n    return !!config.get('state:storeInSessionStorage');\n  };\n\n  /**\n   *  Produce the hash version of the state in it's current position\n   *\n   *  @return {string}\n   */\n  State.prototype.toQueryParam = function () {\n    var _this2 = this;\n\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toObject();\n\n    if (!this.isHashingEnabled()) {\n      return _risonNode2.default.encode(state);\n    }\n\n    // We need to strip out Angular-specific properties.\n    var json = _angular2.default.toJson(state);\n    var hash = (0, _state_storage.createStateHash)(json, function (hash) {\n      return _this2._hashedItemStore.getItem(hash);\n    });\n    var isItemSet = this._hashedItemStore.setItem(hash, json);\n\n    if (isItemSet) {\n      return hash;\n    }\n\n    // If we ran out of space trying to persist the state, notify the user.\n    this._notifier.fatal(new Error('Kibana is unable to store history items in your session ' + 'because it is full and there don\\'t seem to be items any items safe ' + 'to delete.\\n' + '\\n' + 'This can usually be fixed by moving to a fresh tab, but could ' + 'be caused by a larger issue. If you are seeing this message regularly, ' + 'please file an issue at https://github.com/elastic/kibana/issues.'));\n  };\n\n  /**\n   *  Get the query string parameter name where this state writes and reads\n   *  @return {string}\n   */\n  State.prototype.getQueryParamName = function () {\n    return this._urlParam;\n  };\n\n  return State;\n} /**\n   * @name State\n   *\n   * @extends Events\n   *\n   * @description Persists generic \"state\" to and reads it from the URL.\n   */",null]}