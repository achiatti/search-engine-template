{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/scanner.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/scanner.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Scanner = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Scanner = exports.Scanner = function Scanner($http) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      index = _ref.index,\n      type = _ref.type;\n\n  if (!index) throw new Error('Expected index');\n  if (!type) throw new Error('Expected type');\n  if (!$http) throw new Error('Expected $http');\n\n  this.$http = $http;\n  this.index = index;\n  this.type = type;\n};\n\nScanner.prototype.start = function (searchBody) {\n  var addBasePath = _chrome2.default.addBasePath;\n\n  var scrollStartPath = addBasePath('/api/kibana/legacy_scroll_start');\n  return this.$http.post(scrollStartPath, searchBody);\n};\n\nScanner.prototype.continue = function (scrollId) {\n  var addBasePath = _chrome2.default.addBasePath;\n\n  var scrollContinuePath = addBasePath('/api/kibana/legacy_scroll_continue');\n  return this.$http.post(scrollContinuePath, { scrollId: scrollId });\n};\n\nScanner.prototype.scanAndMap = function (searchString, options, mapFn) {\n  var _this = this;\n\n  var bool = { must: [], filter: [] };\n\n  var scrollId = void 0;\n  var allResults = {\n    hits: [],\n    total: 0\n  };\n  var opts = _lodash2.default.defaults(options || {}, {\n    pageSize: 100,\n    docCount: 1000\n  });\n\n  if (this.type) {\n    bool.filter.push({\n      bool: {\n        should: [{\n          term: {\n            _type: this.type\n          }\n        }, {\n          term: {\n            type: this.type\n          }\n        }]\n      }\n    });\n  }\n\n  if (searchString) {\n    bool.must.push({\n      simple_query_string: {\n        query: searchString + '*',\n        fields: ['title^3', 'description'],\n        default_operator: 'AND'\n      }\n    });\n  } else {\n    bool.must.push({\n      match_all: {}\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    var getMoreUntilDone = function getMoreUntilDone(error, response) {\n      if (error) {\n        reject(error);\n        return;\n      }\n      var scanAllResults = opts.docCount === Infinity;\n      allResults.total = scanAllResults ? response.hits.total : Math.min(response.hits.total, opts.docCount);\n      scrollId = response._scroll_id || scrollId;\n\n      var hits = response.hits.hits.slice(0, allResults.total - allResults.hits.length);\n\n      hits = hits.map(function (hit) {\n        if (hit._type === 'doc') {\n          return {\n            _id: hit._id.replace(_this.type + ':', ''),\n            _type: _this.type,\n            _source: hit._source[_this.type],\n            _meta: {\n              savedObjectVersion: 2\n            }\n          };\n        }\n\n        return _lodash2.default.pick(hit, ['_id', '_type', '_source']);\n      });\n\n      if (mapFn) hits = hits.map(mapFn);\n\n      allResults.hits = allResults.hits.concat(hits);\n\n      var collectedAllResults = allResults.total === allResults.hits.length;\n      if (collectedAllResults) {\n        resolve(allResults);\n      } else {\n        _this.continue(scrollId).then(function (response) {\n          return getMoreUntilDone(null, response.data);\n        }).catch(function (error) {\n          return getMoreUntilDone(error);\n        });\n      }\n    };\n\n    var searchBody = {\n      index: _this.index,\n      size: opts.pageSize,\n      body: { query: { bool: bool } }\n    };\n    _this.start(searchBody).then(function (response) {\n      return getMoreUntilDone(null, response.data);\n    }).catch(function (error) {\n      return getMoreUntilDone(error);\n    });\n  });\n};",null]}