{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vis/map/service_settings.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vis/map/service_settings.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _modules = require('ui/modules');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _markdownIt = require('markdown-it');\n\nvar _markdownIt2 = _interopRequireDefault(_markdownIt);\n\nvar _url = require('ui/url');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar markdownIt = new _markdownIt2.default({\n  html: false,\n  linkify: true\n});\n\n_modules.uiModules.get('kibana').service('serviceSettings', function ($http, $sanitize, mapConfig, tilemapsConfig, kbnVersion) {\n\n  var attributionFromConfig = $sanitize(markdownIt.render(tilemapsConfig.deprecated.config.options.attribution || ''));\n  var tmsOptionsFromConfig = _lodash2.default.assign({}, tilemapsConfig.deprecated.config.options, { attribution: attributionFromConfig });\n\n  var extendUrl = function extendUrl(url, props) {\n    return (0, _url.modifyUrl)(url, function (parsed) {\n      return _lodash2.default.merge(parsed, props);\n    });\n  };\n\n  /**\n   *  Unescape a url template that was escaped by encodeURI() so leaflet\n   *  will be able to correctly locate the varables in the template\n   *  @param  {String} url\n   *  @return {String}\n   */\n  var unescapeTemplateVars = function unescapeTemplateVars(url) {\n    var ENCODED_TEMPLATE_VARS_RE = /%7B(\\w+?)%7D/g;\n    return url.replace(ENCODED_TEMPLATE_VARS_RE, function (total, varName) {\n      return '{' + varName + '}';\n    });\n  };\n\n  var ServiceSettings = function () {\n    function ServiceSettings() {\n      _classCallCheck(this, ServiceSettings);\n\n      this._queryParams = {\n        my_app_version: kbnVersion\n      };\n\n      this._loadCatalogue = null;\n      this._loadFileLayers = null;\n      this._loadTMSServices = null;\n\n      this._invalidateSettings();\n    }\n\n    _createClass(ServiceSettings, [{\n      key: '_invalidateSettings',\n      value: function _invalidateSettings() {\n        var _this = this;\n\n        this._loadCatalogue = _lodash2.default.once(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n          var response;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return _this._getManifest(mapConfig.manifestServiceUrl, _this._queryParams);\n\n                case 3:\n                  response = _context.sent;\n                  return _context.abrupt('return', response.data);\n\n                case 7:\n                  _context.prev = 7;\n                  _context.t0 = _context['catch'](0);\n\n                  if (!_context.t0) {\n                    _context.t0 = new Error('Unkown error');\n                  }\n                  if (!(_context.t0 instanceof Error)) {\n                    _context.t0 = new Error(_context.t0.data || 'status ' + (_context.t0.statusText || _context.t0.status));\n                  }\n                  throw new Error('Could not retrieve manifest from the tile service: ' + _context.t0.message);\n\n                case 12:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _callee, _this, [[0, 7]]);\n        })));\n\n        this._loadFileLayers = _lodash2.default.once(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n          var catalogue, fileService, manifest, layers;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return _this._loadCatalogue();\n\n                case 2:\n                  catalogue = _context2.sent;\n                  fileService = catalogue.services.filter(function (service) {\n                    return service.type === 'file';\n                  })[0];\n                  _context2.next = 6;\n                  return _this._getManifest(fileService.manifest, _this._queryParams);\n\n                case 6:\n                  manifest = _context2.sent;\n                  layers = manifest.data.layers.filter(function (layer) {\n                    return layer.format === 'geojson';\n                  });\n\n                  layers.forEach(function (layer) {\n                    layer.url = _this._extendUrlWithParams(layer.url);\n                    layer.attribution = $sanitize(markdownIt.render(layer.attribution));\n                  });\n                  return _context2.abrupt('return', layers);\n\n                case 10:\n                case 'end':\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, _this);\n        })));\n\n        this._loadTMSServices = _lodash2.default.once(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n          var _tmsService, catalogue, tmsService, manifest, services, firstService;\n\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (!tilemapsConfig.deprecated.isOverridden) {\n                    _context3.next = 4;\n                    break;\n                  }\n\n                  //use settings from yml (which are overridden)\n                  _tmsService = _lodash2.default.cloneDeep(tmsOptionsFromConfig);\n\n                  _tmsService.url = tilemapsConfig.deprecated.config.url;\n                  return _context3.abrupt('return', _tmsService);\n\n                case 4:\n                  _context3.next = 6;\n                  return _this._loadCatalogue();\n\n                case 6:\n                  catalogue = _context3.sent;\n                  tmsService = catalogue.services.filter(function (service) {\n                    return service.type === 'tms';\n                  })[0];\n                  _context3.next = 10;\n                  return _this._getManifest(tmsService.manifest, _this._queryParams);\n\n                case 10:\n                  manifest = _context3.sent;\n                  services = manifest.data.services;\n                  firstService = _lodash2.default.cloneDeep(services[0]);\n\n                  if (firstService) {\n                    _context3.next = 15;\n                    break;\n                  }\n\n                  throw new Error('Manifest response does not include sufficient service data.');\n\n                case 15:\n\n                  firstService.attribution = $sanitize(markdownIt.render(firstService.attribution));\n                  firstService.subdomains = firstService.subdomains || [];\n                  firstService.url = _this._extendUrlWithParams(firstService.url);\n                  return _context3.abrupt('return', firstService);\n\n                case 19:\n                case 'end':\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, _this);\n        })));\n      }\n    }, {\n      key: '_extendUrlWithParams',\n      value: function _extendUrlWithParams(url) {\n        return unescapeTemplateVars(extendUrl(url, {\n          query: this._queryParams\n        }));\n      }\n\n      /**\n       * this internal method is overridden by the tests to simulate custom manifest.\n       */\n\n    }, {\n      key: '_getManifest',\n      value: function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(manifestUrl) {\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  return _context4.abrupt('return', $http({\n                    url: extendUrl(manifestUrl, { query: this._queryParams }),\n                    method: 'GET'\n                  }));\n\n                case 1:\n                case 'end':\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function _getManifest(_x) {\n          return _ref4.apply(this, arguments);\n        }\n\n        return _getManifest;\n      }()\n    }, {\n      key: 'getFileLayers',\n      value: function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n          return regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return this._loadFileLayers();\n\n                case 2:\n                  return _context5.abrupt('return', _context5.sent);\n\n                case 3:\n                case 'end':\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function getFileLayers() {\n          return _ref5.apply(this, arguments);\n        }\n\n        return getFileLayers;\n      }()\n    }, {\n      key: 'getTMSService',\n      value: function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n          var tmsService;\n          return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.next = 2;\n                  return this._loadTMSServices();\n\n                case 2:\n                  tmsService = _context6.sent;\n                  return _context6.abrupt('return', {\n                    getUrl: function getUrl() {\n                      return tmsService.url;\n                    },\n                    getMinMaxZoom: function getMinMaxZoom(isWMSEnabled) {\n                      if (isWMSEnabled) {\n                        return {\n                          minZoom: 0,\n                          maxZoom: 18\n                        };\n                      }\n                      //Otherwise, we use the settings from the yml.\n                      //note that it is no longer possible to only override the zoom-settings, since all options are read from the manifest\n                      //by default.\n                      //For a custom configuration, users will need to override tilemap.url as well.\n                      return {\n                        minZoom: tmsService.minZoom,\n                        maxZoom: tmsService.maxZoom\n                      };\n                    },\n                    getTMSOptions: function getTMSOptions() {\n                      return tmsService;\n                    }\n                  });\n\n                case 4:\n                case 'end':\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        function getTMSService() {\n          return _ref6.apply(this, arguments);\n        }\n\n        return getTMSService;\n      }()\n    }, {\n      key: 'getFallbackZoomSettings',\n      value: function getFallbackZoomSettings(isWMSEnabled) {\n        return isWMSEnabled ? { minZoom: 0, maxZoom: 18 } : { minZoom: 0, maxZoom: 10 };\n      }\n\n      /**\n       * Add optional query-parameters to all requests\n       *\n       * @param additionalQueryParams\n       */\n\n    }, {\n      key: 'addQueryParams',\n      value: function addQueryParams(additionalQueryParams) {\n        for (var key in additionalQueryParams) {\n          if (additionalQueryParams.hasOwnProperty(key)) {\n            if (additionalQueryParams[key] !== this._queryParams[key]) {\n              //changes detected.\n              this._queryParams = _lodash2.default.assign({}, this._queryParams, additionalQueryParams);\n              this._invalidateSettings();\n              break;\n            }\n          }\n        }\n      }\n    }]);\n\n    return ServiceSettings;\n  }();\n\n  return new ServiceSettings();\n});",null]}