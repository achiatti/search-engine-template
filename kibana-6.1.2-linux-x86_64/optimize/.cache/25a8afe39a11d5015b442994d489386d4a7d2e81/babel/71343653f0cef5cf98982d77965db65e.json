{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vis/components/tooltip/position_tooltip.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vis/components/tooltip/position_tooltip.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.positionTooltip = positionTooltip;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OFFSET = 10;\nvar $clone = void 0;\n\n// translate css properties into their basic direction\nvar propDirs = {\n  top: 'north',\n  left: 'west'\n};\n\nfunction positionTooltip(opts, html) {\n  if (!opts) return;\n  var $chart = (0, _jquery2.default)(opts.$chart);\n  var $el = (0, _jquery2.default)(opts.$el);\n  var $window = (0, _jquery2.default)(opts.$window || window);\n  var $sizer = (0, _jquery2.default)(opts.$sizer);\n  var prev = $chart.data('previousPlacement') || {};\n  var event = opts.event;\n\n  if (!$chart.size() || !$el.size()) return;\n\n  var size = getTtSize(html || $el.html(), $sizer);\n  var pos = getBasePosition(size, event);\n  var overflow = getOverflow(size, pos, [$chart, $window]);\n\n  var placement = placeToAvoidOverflow(pos, prev, overflow);\n  $chart.data('previousPlacement', placement);\n  return placement;\n}\n\nfunction getTtSize(ttHtml, $sizer) {\n  if ($sizer.html() !== ttHtml) {\n    $sizer.html(ttHtml);\n  }\n\n  var size = {\n    width: $sizer.outerWidth(),\n    height: $sizer.outerHeight()\n  };\n\n  return size;\n}\n\nfunction getBasePosition(size, event) {\n  return {\n    east: event.clientX + OFFSET,\n    west: event.clientX - size.width - OFFSET,\n    south: event.clientY + OFFSET,\n    north: event.clientY - size.height - OFFSET\n  };\n}\n\nfunction getBounds($el) {\n  // in testing, $window is not actually a window, so we need to add\n  // the offsets to make it work right.\n  var bounds = $el.offset() || { top: 0, left: 0 };\n  bounds.top += $el.scrollTop();\n  bounds.left += $el.scrollLeft();\n  bounds.bottom = bounds.top + $el.outerHeight();\n  bounds.right = bounds.left + $el.outerWidth();\n  bounds.area = (bounds.bottom - bounds.top) * (bounds.right - bounds.left);\n  return bounds;\n}\n\nfunction getOverflow(size, pos, containers) {\n  var overflow = {};\n\n  containers.map(getBounds).sort(function (a, b) {\n    // ensure smallest containers are merged first\n    return a.area - b.area;\n  }).forEach(function (bounds) {\n    // number of pixels that the toolip would overflow it's far\n    // side, if we placed it that way. (negative === no overflow)\n    mergeOverflows(overflow, {\n      north: bounds.top - pos.north,\n      east: pos.east + size.width - bounds.right,\n      south: pos.south + size.height - bounds.bottom,\n      west: bounds.left - pos.west\n    });\n  });\n\n  (window.overflows || (window.overflows = [])).push(overflow);\n  return overflow;\n}\n\nfunction mergeOverflows(dest, src) {\n  _lodash2.default.merge(dest, src, function (a, b) {\n    if (a == null || b == null) return a || b;\n    if (a < 0 && b < 0) return Math.min(a, b);\n    return Math.max(a, b);\n  });\n\n  // When tooltip overflows both sides of smaller container,\n  // remove overflow on one side if the outer container can contain tooltip.\n  if (dest.east && dest.west && dest.east > 0 && dest.west > 0 && (src.east < 0 || src.west < 0)) {\n    if (src.east < src.west) {\n      dest.east = src.east;\n    } else {\n      dest.west = src.west;\n    }\n  }\n}\n\nfunction pickPlacement(prop, pos, overflow, prev, pref, fallback, placement) {\n  var stash = '_' + prop;\n\n  // list of directions in order of preference\n  var dirs = _lodash2.default.unique([prev[stash], pref, fallback].filter(Boolean));\n\n  var dir = void 0;\n  var value = void 0;\n\n  // find the first direction that doesn't overflow\n  for (var i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (overflow[dir] > 0) continue;\n    value = pos[dir];\n    break;\n  }\n\n  // if we don't find one that doesn't overflow, use\n  // the first choice and offset based on overflo\n  if (value == null) {\n    dir = dirs[0];\n\n    var offset = overflow[dir];\n    if (propDirs[prop] === dir) {\n      // when the property represents the same direction\n      // as dir, we flip the overflow\n      offset = offset * -1;\n    }\n\n    value = pos[dir] - offset;\n  }\n\n  placement[prop] = value;\n  placement[stash] = dir;\n}\n\nfunction placeToAvoidOverflow(pos, prev, overflow) {\n  var placement = {};\n  pickPlacement('top', pos, overflow, prev, 'south', 'north', placement);\n  pickPlacement('left', pos, overflow, prev, 'east', 'west', placement);\n  return placement;\n}\n\n// expose units/helpers for testing\npositionTooltip.getTtSize = getTtSize;\npositionTooltip.getBasePosition = getBasePosition;\npositionTooltip.getOverflow = getOverflow;\npositionTooltip.getBounds = getBounds;\npositionTooltip.placeToAvoidOverflow = placeToAvoidOverflow;\npositionTooltip.removeClone = function () {\n  $clone && $clone.remove();\n  $clone = null;\n};",null]}