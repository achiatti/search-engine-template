{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/tile_map/public/base_maps_visualization.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/tile_map/public/base_maps_visualization.js","mtime":1515552031000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.BaseMapsVisualizationProvider = BaseMapsVisualizationProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _kibana_map = require('./kibana_map');\n\nvar _Rx = require('rxjs/Rx');\n\nrequire('ui/vis/map/service_settings');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BaseMapsVisualizationProvider(serviceSettings) {\n\n  /**\n   * Abstract base class for a visualization consisting of a map with a single baselayer.\n   * @class BaseMapsVisualization\n   * @constructor\n   */\n  return function () {\n    function BaseMapsVisualization(element, vis) {\n      _classCallCheck(this, BaseMapsVisualization);\n\n      this.vis = vis;\n      this._container = element;\n      this._kibanaMap = null;\n      this._baseLayerDirty = true;\n      this._mapIsLoaded = this._makeKibanaMap();\n    }\n\n    _createClass(BaseMapsVisualization, [{\n      key: 'destroy',\n      value: function destroy() {\n        if (this._kibanaMap) {\n          this._kibanaMap.destroy();\n          this._kibanaMap = null;\n        }\n      }\n\n      /**\n       * checks whether the data is usable.\n       * @return {boolean}\n       */\n\n    }, {\n      key: 'isDataUsable',\n      value: function isDataUsable() {\n        return true;\n      }\n\n      /**\n       * Implementation of Visualization#render.\n       * Child-classes can extend this method if the render-complete function requires more time until rendering has completed.\n       * @param esResponse\n       * @param status\n       * @return {Promise}\n       */\n\n    }, {\n      key: 'render',\n      value: function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(esResponse, status) {\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (this._kibanaMap) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  return _context.abrupt('return');\n\n                case 2:\n                  _context.next = 4;\n                  return this._mapIsLoaded;\n\n                case 4:\n\n                  if (status.resize) {\n                    this._kibanaMap.resize();\n                  }\n\n                  if (!(status.params || status.aggs)) {\n                    _context.next = 8;\n                    break;\n                  }\n\n                  _context.next = 8;\n                  return this._updateParams();\n\n                case 8:\n                  if (this.isDataUsable(esResponse)) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  return _context.abrupt('return');\n\n                case 10:\n                  if (!status.data) {\n                    _context.next = 13;\n                    break;\n                  }\n\n                  _context.next = 13;\n                  return this._updateData(esResponse);\n\n                case 13:\n                  if (status.uiState) {\n                    this._kibanaMap.useUiStateFromVisualization(this.vis);\n                  }\n\n                  _context.next = 16;\n                  return this._whenBaseLayerIsLoaded();\n\n                case 16:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function render(_x, _x2) {\n          return _ref.apply(this, arguments);\n        }\n\n        return render;\n      }()\n\n      /**\n       * Creates an instance of a kibana-map with a single baselayer and assigns it to the this._kibanaMap property.\n       * Clients can override this method to customize the initialization.\n       * @private\n       */\n\n    }, {\n      key: '_makeKibanaMap',\n      value: function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n          var _this = this;\n\n          var options, uiState, zoomFromUiState, centerFromUIState, mapparams;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  options = {};\n                  uiState = this.vis.getUiState();\n                  zoomFromUiState = parseInt(uiState.get('mapZoom'));\n                  centerFromUIState = uiState.get('mapCenter');\n\n                  options.zoom = !isNaN(zoomFromUiState) ? zoomFromUiState : this.vis.params.mapZoom;\n                  options.center = centerFromUIState ? centerFromUIState : this.vis.params.mapCenter;\n\n                  this._kibanaMap = new _kibana_map.KibanaMap(this._container, options);\n\n                  this._kibanaMap.addLegendControl();\n                  this._kibanaMap.addFitControl();\n                  this._kibanaMap.persistUiStateForVisualization(this.vis);\n\n                  this._kibanaMap.on('baseLayer:loaded', function () {\n                    _this._baseLayerDirty = false;\n                  });\n                  this._kibanaMap.on('baseLayer:loading', function () {\n                    _this._baseLayerDirty = true;\n                  });\n\n                  mapparams = this._getMapsParams();\n                  _context2.next = 15;\n                  return this._updateBaseLayer(mapparams);\n\n                case 15:\n                case 'end':\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function _makeKibanaMap() {\n          return _ref2.apply(this, arguments);\n        }\n\n        return _makeKibanaMap;\n      }()\n    }, {\n      key: '_updateBaseLayer',\n      value: function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(mapParams) {\n          var _getMinMaxZoom2, minZoom, maxZoom, url, options;\n\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.prev = 0;\n                  _context3.next = 3;\n                  return serviceSettings.getTMSService();\n\n                case 3:\n                  this._tmsService = _context3.sent;\n\n                  this._tmsError = null;\n                  _context3.next = 12;\n                  break;\n\n                case 7:\n                  _context3.prev = 7;\n                  _context3.t0 = _context3['catch'](0);\n\n                  this._tmsService = null;\n                  this._tmsError = _context3.t0;\n                  this._notify.warning(_context3.t0.message);\n\n                case 12:\n                  _getMinMaxZoom2 = this._getMinMaxZoom(), minZoom = _getMinMaxZoom2.minZoom, maxZoom = _getMinMaxZoom2.maxZoom;\n\n                  if (mapParams.wms.enabled) {\n                    // Switch to WMS\n                    if (maxZoom > this._kibanaMap.getMaxZoomLevel()) {\n                      //need to recreate the map with less restrictive zoom\n                      this._kibanaMap.removeLayer(this._geohashLayer);\n                      this._geohashLayer = null;\n                      this._kibanaMap.setMinZoom(minZoom);\n                      this._kibanaMap.setMaxZoom(maxZoom);\n                    }\n\n                    this._kibanaMap.setBaseLayer({\n                      baseLayerType: 'wms',\n                      options: _extends({\n                        minZoom: minZoom,\n                        maxZoom: maxZoom,\n                        url: mapParams.wms.url\n                      }, mapParams.wms.options)\n                    });\n                  } else {\n\n                    // switch to tms\n                    if (maxZoom < this._kibanaMap.getMaxZoomLevel()) {\n                      //need to recreate the map with more restrictive zoom level\n                      this._kibanaMap.removeLayer(this._geohashLayer);\n                      this._geohashLayer = null;\n                      this._kibanaMap.setMinZoom(minZoom);\n                      this._kibanaMap.setMaxZoom(maxZoom);\n                      if (this._kibanaMap.getZoomLevel() > maxZoom) {\n                        this._kibanaMap.setZoomLevel(maxZoom);\n                      }\n                    }\n\n                    if (!this._tmsError) {\n                      url = this._tmsService.getUrl();\n                      options = this._tmsService.getTMSOptions();\n\n                      this._kibanaMap.setBaseLayer({\n                        baseLayerType: 'tms',\n                        options: _extends({ url: url }, options)\n                      });\n                    }\n                  }\n\n                case 14:\n                case 'end':\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this, [[0, 7]]);\n        }));\n\n        function _updateBaseLayer(_x3) {\n          return _ref3.apply(this, arguments);\n        }\n\n        return _updateBaseLayer;\n      }()\n    }, {\n      key: '_getMinMaxZoom',\n      value: function _getMinMaxZoom() {\n        var mapParams = this._getMapsParams();\n        if (this._tmsError) {\n          return serviceSettings.getFallbackZoomSettings(mapParams.wms.enabled);\n        } else {\n          return this._tmsService.getMinMaxZoom(mapParams.wms.enabled);\n        }\n      }\n    }, {\n      key: '_updateData',\n      value: function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  throw new Error('Child should implement this method to respond to data-update');\n\n                case 1:\n                case 'end':\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function _updateData() {\n          return _ref4.apply(this, arguments);\n        }\n\n        return _updateData;\n      }()\n\n      /**\n       * called on options change (vis.params change)\n       */\n\n    }, {\n      key: '_updateParams',\n      value: function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n          var mapParams;\n          return regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  mapParams = this._getMapsParams();\n                  _context5.next = 3;\n                  return this._updateBaseLayer(mapParams);\n\n                case 3:\n                  this._kibanaMap.setLegendPosition(mapParams.legendPosition);\n                  this._kibanaMap.setShowTooltip(mapParams.addTooltip);\n                  this._kibanaMap.useUiStateFromVisualization(this.vis);\n\n                case 6:\n                case 'end':\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function _updateParams() {\n          return _ref5.apply(this, arguments);\n        }\n\n        return _updateParams;\n      }()\n    }, {\n      key: '_getMapsParams',\n      value: function _getMapsParams() {\n        return _lodash2.default.assign({}, this.vis.type.visConfig.defaults, { type: this.vis.type.name }, this.vis.params);\n      }\n    }, {\n      key: '_whenBaseLayerIsLoaded',\n      value: function _whenBaseLayerIsLoaded() {\n        var _this2 = this;\n\n        var maxTimeForBaseLayer = 10000;\n        var interval$ = _Rx.Observable.interval(10).filter(function () {\n          return !_this2._baseLayerDirty;\n        });\n        var timer$ = _Rx.Observable.timer(maxTimeForBaseLayer);\n\n        return _Rx.Observable.race(interval$, timer$).first().toPromise();\n      }\n    }]);\n\n    return BaseMapsVisualization;\n  }();\n}",null]}