{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/data_source/search_source.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/data_source/search_source.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SearchSourceProvider = SearchSourceProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _normalize_sort_request = require('./_normalize_sort_request');\n\nvar _root_search_source = require('./_root_search_source');\n\nvar _abstract = require('./_abstract');\n\nvar _request = require('../fetch/request');\n\nvar _segmented = require('../fetch/request/segmented');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**\n                                                                                                                                                                                                     * @name SearchSource\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * @description A promise-based stream of search results that can inherit from other search sources.\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * Because filters/queries in Kibana have different levels of persistence and come from different\n                                                                                                                                                                                                     * places, it is important to keep track of where filters come from for when they are saved back to\n                                                                                                                                                                                                     * the savedObject store in the Kibana index. To do this, we create trees of searchSource objects\n                                                                                                                                                                                                     * that can have associated query parameters (index, query, filter, etc) which can also inherit from\n                                                                                                                                                                                                     * other searchSource objects.\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * At query time, all of the searchSource objects that have subscribers are \"flattened\", at which\n                                                                                                                                                                                                     * point the query params from the searchSource are collected while traversing up the inheritance\n                                                                                                                                                                                                     * chain. At each link in the chain a decision about how to merge the query params is made until a\n                                                                                                                                                                                                     * single set of query parameters is created for each active searchSource (a searchSource with\n                                                                                                                                                                                                     * subscribers).\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * That set of query parameters is then sent to elasticsearch. This is how the filter hierarchy\n                                                                                                                                                                                                     * works in Kibana.\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * Visualize, starting from a new search:\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     *  - the `savedVis.searchSource` is set as the `appSearchSource`.\n                                                                                                                                                                                                     *  - The `savedVis.searchSource` would normally inherit from the `appSearchSource`, but now it is\n                                                                                                                                                                                                     *    upgraded to inherit from the `rootSearchSource`.\n                                                                                                                                                                                                     *  - Any interaction with the visualization will still apply filters to the `appSearchSource`, so\n                                                                                                                                                                                                     *    they will be stored directly on the `savedVis.searchSource`.\n                                                                                                                                                                                                     *  - Any interaction with the time filter will be written to the `rootSearchSource`, so those\n                                                                                                                                                                                                     *    filters will not be saved by the `savedVis`.\n                                                                                                                                                                                                     *  - When the `savedVis` is saved to elasticsearch, it takes with it all the filters that are\n                                                                                                                                                                                                     *    defined on it directly, but none of the ones that it inherits from other places.\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * Visualize, starting from an existing search:\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     *  - The `savedVis` loads the `savedSearch` on which it is built.\n                                                                                                                                                                                                     *  - The `savedVis.searchSource` is set to inherit from the `saveSearch.searchSource` and set as\n                                                                                                                                                                                                     *    the `appSearchSource`.\n                                                                                                                                                                                                     *  - The `savedSearch.searchSource`, is set to inherit from the `rootSearchSource`.\n                                                                                                                                                                                                     *  - Then the `savedVis` is written to elasticsearch it will be flattened and only include the\n                                                                                                                                                                                                     *    filters created in the visualize application and will reconnect the filters from the\n                                                                                                                                                                                                     *    `savedSearch` at runtime to prevent losing the relationship\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * Dashboard search sources:\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     *  - Each panel in a dashboard has a search source.\n                                                                                                                                                                                                     *  - The `savedDashboard` also has a searchsource, and it is set as the `appSearchSource`.\n                                                                                                                                                                                                     *  - Each panel's search source inherits from the `appSearchSource`, meaning that they inherit from\n                                                                                                                                                                                                     *    the dashboard search source.\n                                                                                                                                                                                                     *  - When a filter is added to the search box, or via a visualization, it is written to the\n                                                                                                                                                                                                     *    `appSearchSource`.\n                                                                                                                                                                                                     */\n\nfunction SearchSourceProvider(Promise, Private, config) {\n  var SourceAbstract = Private(_abstract.AbstractDataSourceProvider);\n  var SearchRequest = Private(_request.SearchRequestProvider);\n  var SegmentedRequest = Private(_segmented.SegmentedRequestProvider);\n  var normalizeSortRequest = Private(_normalize_sort_request.NormalizeSortRequestProvider);\n\n  var forIp = Symbol('for which index pattern?');\n\n  function isIndexPattern(val) {\n    return Boolean(val && typeof val.toIndexList === 'function');\n  }\n\n  _lodash2.default.class(SearchSource).inherits(SourceAbstract);\n  function SearchSource(initialState) {\n    SearchSource.Super.call(this, initialState);\n  }\n\n  /*****\n   * PUBLIC API\n   *****/\n\n  /**\n   * List of the editable state properties that turn into a\n   * chainable API\n   *\n   * @type {Array}\n   */\n  SearchSource.prototype._methods = ['type', 'query', 'filter', 'sort', 'highlight', 'highlightAll', 'aggs', 'from', 'searchAfter', 'size', 'source', 'version', 'fields'];\n\n  SearchSource.prototype.index = function (indexPattern) {\n    var state = this._state;\n\n    var hasSource = state.source;\n    var sourceCameFromIp = hasSource && state.source.hasOwnProperty(forIp);\n    var sourceIsForOurIp = sourceCameFromIp && state.source[forIp] === state.index;\n    if (sourceIsForOurIp) {\n      delete state.source;\n    }\n\n    if (indexPattern === undefined) return state.index;\n    if (indexPattern === null) return delete state.index;\n    if (!isIndexPattern(indexPattern)) {\n      throw new TypeError('expected indexPattern to be an IndexPattern duck.');\n    }\n\n    state.index = indexPattern;\n    if (!state.source) {\n      // imply source filtering based on the index pattern, but allow overriding\n      // it by simply setting another value for \"source\". When index is changed\n      state.source = function () {\n        return indexPattern.getSourceFiltering();\n      };\n      state.source[forIp] = indexPattern;\n    }\n\n    return this;\n  };\n\n  SearchSource.prototype.extend = function () {\n    return new SearchSource().inherits(this);\n  };\n\n  /**\n   * Set a searchSource that this source should inherit from\n   * @param  {SearchSource} searchSource - the parent searchSource\n   * @return {this} - chainable\n   */\n  SearchSource.prototype.inherits = function (parent) {\n    this._parent = parent;\n    return this;\n  };\n\n  /**\n   * Get the parent of this SearchSource\n   * @return {undefined|searchSource}\n   */\n  SearchSource.prototype.getParent = function (onlyHardLinked) {\n    var self = this;\n    if (self._parent === false) return;\n    if (self._parent) return self._parent;\n    return onlyHardLinked || this.skipTimeRangeFilter ? undefined : Private(_root_search_source.RootSearchSourceProvider).get();\n  };\n\n  /**\n   * Temporarily prevent this Search from being fetched... not a fan but it's easy\n   */\n  SearchSource.prototype.disable = function () {\n    this._fetchDisabled = true;\n  };\n\n  /**\n   * Reverse of SourceAbstract#disable(), only need to call this if source was previously disabled\n   */\n  SearchSource.prototype.enable = function () {\n    this._fetchDisabled = false;\n  };\n\n  SearchSource.prototype.onBeginSegmentedFetch = function (initFunction) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      function addRequest() {\n        var defer = Promise.defer();\n        var req = new SegmentedRequest(self, defer, initFunction);\n\n        req.setErrorHandler(function (request, error) {\n          reject(error);\n          request.abort();\n        });\n\n        // Return promises created by the completion handler so that\n        // errors will bubble properly\n        return req.getCompletePromise().then(addRequest);\n      }\n      addRequest();\n    });\n  };\n\n  /******\n   * PRIVATE APIS\n   ******/\n\n  /**\n   * Gets the type of the DataSource\n   * @return {string}\n   */\n  SearchSource.prototype._getType = function () {\n    return 'search';\n  };\n\n  /**\n   * Create a common search request object, which should\n   * be put into the pending request queye, for this search\n   * source\n   *\n   * @param {Deferred} defer - the deferred object that should be resolved\n   *                         when the request is complete\n   * @return {SearchRequest}\n   */\n  SearchSource.prototype._createRequest = function (defer) {\n    return new SearchRequest(this, defer);\n  };\n\n  /**\n   * Used to merge properties into the state within ._flatten().\n   * The state is passed in and modified by the function\n   *\n   * @param  {object} state - the current merged state\n   * @param  {*} val - the value at `key`\n   * @param  {*} key - The key of `val`\n   * @return {undefined}\n   */\n  SearchSource.prototype._mergeProp = function (state, val, key) {\n    if (typeof val === 'function') {\n      var source = this;\n      return Promise.cast(val(this)).then(function (newVal) {\n        return source._mergeProp(state, newVal, key);\n      });\n    }\n\n    if (val == null || !key || !_lodash2.default.isString(key)) return;\n\n    switch (key) {\n      case 'filter':\n        var verifiedFilters = val;\n        if (config.get('courier:ignoreFilterIfFieldNotInIndex')) {\n          if (!Array.isArray(val)) val = [val];\n          verifiedFilters = val.filter(function (el) {\n            if ('meta' in el && 'index' in state) {\n              var field = state.index.fields.byName[el.meta.key];\n              if (!field) return false;\n            }\n            return true;\n          });\n        }\n        // user a shallow flatten to detect if val is an array, and pull the values out if it is\n        state.filters = (0, _lodash2.default)([state.filters || [], verifiedFilters]).flatten()\n        // Yo Dawg! I heard you needed to filter out your filters\n        .reject(function (filter) {\n          return !filter || _lodash2.default.get(filter, 'meta.disabled');\n        }).value();\n        return;\n      case 'index':\n      case 'type':\n      case 'id':\n      case 'highlightAll':\n        if (key && state[key] == null) {\n          state[key] = val;\n        }\n        return;\n      case 'searchAfter':\n        key = 'search_after';\n        addToBody();\n        break;\n      case 'source':\n        key = '_source';\n        addToBody();\n        break;\n      case 'sort':\n        val = normalizeSortRequest(val, this.get('index'));\n        addToBody();\n        break;\n      case 'query':\n        state.query = (state.query || []).concat(val);\n        break;\n      case 'fields':\n        state[key] = _lodash2.default.uniq([].concat(_toConsumableArray(state[key] || []), _toConsumableArray(val)));\n        break;\n      default:\n        addToBody();\n    }\n\n    /**\n     * Add the key and val to the body of the request\n     */\n    function addToBody() {\n      state.body = state.body || {};\n      // ignore if we already have a value\n      if (state.body[key] == null) {\n        state.body[key] = val;\n      }\n    }\n  };\n\n  SearchSource.prototype.clone = function () {\n    var clone = new SearchSource(this.toString());\n    // when serializing the internal state with .toString() we lose the internal classes used in the index\n    // pattern, so we have to set it again to workaround this behavior\n    clone.set('index', this.get('index'));\n    clone.inherits(this.getParent());\n    return clone;\n  };\n\n  SearchSource.prototype.getSearchRequestBody = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    var searchRequest;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return this._flatten();\n\n          case 2:\n            searchRequest = _context.sent;\n            return _context.abrupt('return', searchRequest.body);\n\n          case 4:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return SearchSource;\n}",null]}