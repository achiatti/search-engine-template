{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/lodash-mixins/collection.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/lodash-mixins/collection.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lodashCollectionMixin = lodashCollectionMixin;\nfunction lodashCollectionMixin(_) {\n  _.mixin(_, {\n\n    /**\n     * move an obj either up or down in the collection by\n     * injecting it either before/after the prev/next obj that\n     * satisfied the qualifier\n     *\n     * or, just from one index to another...\n     *\n     * @param  {array} objs - the list to move the object within\n     * @param  {number|any} obj - the object that should be moved, or the index that the object is currently at\n     * @param  {number|boolean} below - the index to move the object to, or whether it should be moved up or down\n     * @param  {function} qualifier - a lodash-y callback, object = _.where, string = _.pluck\n     * @return {array} - the objs argument\n     */\n    move: function move(objs, obj, below, qualifier) {\n      var origI = _.isNumber(obj) ? obj : objs.indexOf(obj);\n      if (origI === -1) return objs;\n\n      if (_.isNumber(below)) {\n        // move to a specific index\n        objs.splice(below, 0, objs.splice(origI, 1)[0]);\n        return objs;\n      }\n\n      below = !!below;\n      qualifier = _.callback(qualifier);\n\n      var above = !below;\n      var finder = below ? _.findIndex : _.findLastIndex;\n\n      // find the index of the next/previous obj that meets the qualifications\n      var targetI = finder(objs, function (otherAgg, otherI) {\n        if (below && otherI <= origI) return;\n        if (above && otherI >= origI) return;\n        return !!qualifier(otherAgg, otherI);\n      });\n\n      if (targetI === -1) return objs;\n\n      // place the obj at it's new index\n      objs.splice(targetI, 0, objs.splice(origI, 1)[0]);\n    },\n\n    /**\n     * Like _.groupBy, but allows specifying multiple groups for a\n     * single object.\n     *\n     * _.organizeBy([{ a: [1, 2, 3] }, { b: true, a: [1, 4] }], 'a')\n     * // Object {1: Array[2], 2: Array[1], 3: Array[1], 4: Array[1]}\n     *\n     * _.groupBy([{ a: [1, 2, 3] }, { b: true, a: [1, 4] }], 'a')\n     * // Object {'1,2,3': Array[1], '1,4': Array[1]}\n     *\n     * @param  {array} collection - the list of values to organize\n     * @param  {Function} callback - either a property name, or a callback.\n     * @return {object}\n     */\n    organizeBy: function organizeBy(collection, callback) {\n      var buckets = {};\n      var prop = typeof callback === 'function' ? false : callback;\n\n      function add(key, obj) {\n        if (!buckets[key]) buckets[key] = [];\n        buckets[key].push(obj);\n      }\n\n      _.each(collection, function (obj) {\n        var keys = prop === false ? callback(obj) : obj[prop];\n\n        if (!Array.isArray(keys)) {\n          add(keys, obj);\n          return;\n        }\n\n        var length = keys.length;\n        while (length-- > 0) {\n          add(keys[length], obj);\n        }\n      });\n\n      return buckets;\n    },\n\n    /**\n     * Remove or add a value to an array based on it's presense in the\n     * array initially.\n     *\n     * @param  {array} arr\n     * @param  {any} value - the value to toggle\n     * @return {array} arr\n     */\n    toggleInOut: function toggleInOut(arr, value) {\n      if (_.contains(arr, value)) {\n        arr.splice(arr.indexOf(value), 1);\n      } else {\n        arr.push(value);\n      }\n      return arr;\n    },\n\n    /**\n     * Efficient and safe version of [].push(dest, source);\n     *\n     * @param  {Array} source - the array to pull values from\n     * @param  {Array} dest   - the array to push values into\n     * @return {Array} dest\n     */\n    pushAll: function pushAll(source, dest) {\n      var start = dest.length;\n      var adding = source.length;\n\n      // allocate - http://goo.gl/e2i0S0\n      dest.length = start + adding;\n\n      // fill sparse positions\n      var i = -1;\n      while (++i < adding) {\n        dest[start + i] = source[i];\n      }return dest;\n    }\n\n  });\n}",null]}