{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/visualizations/point_series.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/visualizations/point_series.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.VislibVisualizationsPointSeriesProvider = VislibVisualizationsPointSeriesProvider;\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _tooltip = require('ui/vis/components/tooltip');\n\nvar _chart = require('./_chart');\n\nvar _time_marker = require('./time_marker');\n\nvar _series_types = require('./point_series/series_types');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction VislibVisualizationsPointSeriesProvider(Private) {\n\n  var Chart = Private(_chart.VislibVisualizationsChartProvider);\n  var Tooltip = Private(_tooltip.TooltipProvider);\n  var TimeMarker = Private(_time_marker.VislibVisualizationsTimeMarkerProvider);\n  var seriTypes = Private(_series_types.VislibVisualizationsSeriesTypesProvider);\n  var touchdownTmpl = _lodash2.default.template(require('../partials/touchdown.tmpl.html'));\n  /**\n   * Line Chart Visualization\n   *\n   * @class PointSeries\n   * @constructor\n   * @extends Chart\n   * @param handler {Object} Reference to the Handler Class Constructor\n   * @param el {HTMLElement} HTML element to which the chart will be appended\n   * @param chartData {Object} Elasticsearch query results for this specific chart\n   */\n\n  var PointSeries = function (_Chart) {\n    _inherits(PointSeries, _Chart);\n\n    function PointSeries(handler, chartEl, chartData) {\n      _classCallCheck(this, PointSeries);\n\n      var _this = _possibleConstructorReturn(this, (PointSeries.__proto__ || Object.getPrototypeOf(PointSeries)).call(this, handler, chartEl, chartData));\n\n      _this.handler = handler;\n      _this.chartData = chartData;\n      _this.chartEl = chartEl;\n      _this.chartConfig = _this.findChartConfig();\n      _this.handler.pointSeries = _this;\n      return _this;\n    }\n\n    _createClass(PointSeries, [{\n      key: 'findChartConfig',\n      value: function findChartConfig() {\n        var charts = this.handler.visConfig.get('charts');\n        var chartIndex = this.handler.data.chartData().indexOf(this.chartData);\n        return charts[chartIndex];\n      }\n    }, {\n      key: 'getSeries',\n      value: function getSeries(seriesId) {\n        return this.series.find(function (series) {\n          return series.chartData.aggId === seriesId;\n        });\n      }\n    }, {\n      key: 'addBackground',\n      value: function addBackground(svg, width, height) {\n        var startX = 0;\n        var startY = 0;\n\n        return svg.append('rect').attr('x', startX).attr('y', startY).attr('width', width).attr('height', height).attr('fill', 'transparent').attr('class', 'background');\n      }\n    }, {\n      key: 'addGrid',\n      value: function addGrid(svg) {\n        var _svg$node$getBBox = svg.node().getBBox(),\n            width = _svg$node$getBBox.width,\n            height = _svg$node$getBBox.height;\n\n        return svg.append('g').attr('class', 'grid').call(this.handler.grid.draw(width, height));\n      }\n    }, {\n      key: 'addClipPath',\n      value: function addClipPath(svg) {\n        var _svg$node$getBBox2 = svg.node().getBBox(),\n            width = _svg$node$getBBox2.width,\n            height = _svg$node$getBBox2.height;\n\n        var startX = 0;\n        var startY = 0;\n        this.clipPathId = 'chart-area' + _lodash2.default.uniqueId();\n\n        // Creating clipPath\n        return svg.append('clipPath').attr('id', this.clipPathId).append('rect').attr('x', startX).attr('y', startY).attr('width', width).attr('height', height);\n      }\n    }, {\n      key: 'addEvents',\n      value: function addEvents(svg) {\n        var isBrushable = this.events.isBrushable();\n        if (isBrushable) {\n          var brush = this.events.addBrushEvent(svg);\n          return svg.call(brush);\n        }\n      }\n    }, {\n      key: 'createEndZones',\n      value: function createEndZones(svg) {\n        var self = this;\n        var xAxis = this.handler.categoryAxes[0];\n        var xScale = xAxis.getScale();\n        var ordered = xAxis.ordered;\n        var isHorizontal = xAxis.axisConfig.isHorizontal();\n        var missingMinMax = !ordered || _lodash2.default.isUndefined(ordered.min) || _lodash2.default.isUndefined(ordered.max);\n\n        if (missingMinMax || ordered.endzones === false) return;\n\n        var _svg$node$getBBox3 = svg.node().getBBox(),\n            width = _svg$node$getBBox3.width,\n            height = _svg$node$getBBox3.height;\n\n        // we don't want to draw endzones over our min and max values, they\n        // are still a part of the dataset. We want to start the endzones just\n        // outside of them so we will use these values rather than ordered.min/max\n\n\n        var oneUnit = (ordered.units || _lodash2.default.identity)(1);\n\n        var drawInverted = isHorizontal || xAxis.axisConfig.get('scale.inverted', false);\n        var size = isHorizontal ? width : height;\n        // points on this axis represent the amount of time they cover,\n        // so draw the endzones at the actual time bounds\n        var leftEndzone = {\n          x: drawInverted ? 0 : Math.max(xScale(ordered.min), 0),\n          w: drawInverted ? Math.max(xScale(ordered.min), 0) : height - Math.max(xScale(ordered.min), 0)\n        };\n\n        var expandLastBucket = xAxis.axisConfig.get('scale.expandLastBucket');\n        var rightLastVal = expandLastBucket ? ordered.max : Math.min(ordered.max, _lodash2.default.last(xAxis.values));\n        var rightStart = rightLastVal + oneUnit;\n        var rightEndzone = {\n          x: drawInverted ? xScale(rightStart) : 0,\n          w: drawInverted ? Math.max(size - xScale(rightStart), 0) : xScale(rightStart)\n        };\n\n        this.endzones = svg.selectAll('.layer').data([leftEndzone, rightEndzone]).enter().insert('g', '.brush').attr('class', 'endzone').append('rect').attr('class', 'zone').attr('x', function (d) {\n          return isHorizontal ? d.x : 0;\n        }).attr('y', function (d) {\n          return isHorizontal ? 0 : d.x;\n        }).attr('height', function (d) {\n          return isHorizontal ? height : d.w;\n        }).attr('width', function (d) {\n          return isHorizontal ? d.w : width;\n        });\n\n        function callPlay(event) {\n          var boundData = event.target.__data__;\n          var mouseChartXCoord = event.clientX - self.chartEl.getBoundingClientRect().left;\n          var mouseChartYCoord = event.clientY - self.chartEl.getBoundingClientRect().top;\n          var wholeBucket = boundData && boundData.x != null;\n\n          // the min and max that the endzones start in\n          var min = drawInverted ? leftEndzone.w : rightEndzone.w;\n          var max = drawInverted ? rightEndzone.x : leftEndzone.x;\n\n          // bounds of the cursor to consider\n          var xLeft = isHorizontal ? mouseChartXCoord : mouseChartYCoord;\n          var xRight = isHorizontal ? mouseChartXCoord : mouseChartYCoord;\n          if (wholeBucket) {\n            xLeft = xScale(boundData.x);\n            xRight = xScale(xAxis.addInterval(boundData.x));\n          }\n\n          return {\n            wholeBucket: wholeBucket,\n            touchdown: min > xLeft || max < xRight\n          };\n        }\n\n        function textFormatter() {\n          return touchdownTmpl(callPlay(_d2.default.event));\n        }\n\n        var endzoneTT = new Tooltip('endzones', this.handler.el, textFormatter, null);\n        this.tooltips.push(endzoneTT);\n        endzoneTT.order = 0;\n        endzoneTT.showCondition = function inEndzone() {\n          return callPlay(_d2.default.event).touchdown;\n        };\n        endzoneTT.render()(svg);\n      }\n    }, {\n      key: 'calculateRadiusLimits',\n      value: function calculateRadiusLimits(data) {\n        this.radii = (0, _lodash2.default)(data.series).map(function (series) {\n          return _lodash2.default.map(series.values, 'z');\n        }).flattenDeep().reduce(function (result, val) {\n          if (result.min > val) result.min = val;\n          if (result.max < val) result.max = val;\n          return result;\n        }, {\n          min: Infinity,\n          max: -Infinity\n        });\n      }\n    }, {\n      key: 'draw',\n      value: function draw() {\n        var self = this;\n        var $elem = (0, _jquery2.default)(this.chartEl);\n        var width = this.chartConfig.width = $elem.width();\n        var height = this.chartConfig.height = $elem.height();\n        var xScale = this.handler.categoryAxes[0].getScale();\n        var addTimeMarker = this.chartConfig.addTimeMarker;\n        var times = this.chartConfig.times || [];\n        var div = void 0;\n        var svg = void 0;\n\n        return function (selection) {\n          selection.each(function (data) {\n            var el = this;\n\n            div = _d2.default.select(el);\n\n            svg = div.append('svg').attr('width', width).attr('height', height);\n\n            self.addBackground(svg, width, height);\n            self.addGrid(svg);\n            self.addClipPath(svg);\n            self.addEvents(svg);\n            self.createEndZones(svg);\n            self.calculateRadiusLimits(data);\n\n            self.series = [];\n            _lodash2.default.each(self.chartConfig.series, function (seriArgs, i) {\n              if (!seriArgs.show) return;\n              var SeriClass = seriTypes[seriArgs.type || self.handler.visConfig.get('chart.type')] || seriTypes.line;\n              var series = new SeriClass(self.handler, svg, data.series[i], seriArgs);\n              series.events = self.events;\n              svg.call(series.draw());\n              self.series.push(series);\n            });\n\n            if (addTimeMarker) {\n              //Domain end of 'now' will be milliseconds behind current time\n              //Extend toTime by 1 minute to ensure those cases have a TimeMarker\n              var toTime = new Date(xScale.domain()[1].getTime() + 60000);\n              var currentTime = new Date();\n              if (toTime > currentTime) {\n                new TimeMarker(times, xScale, height).render(svg);\n              }\n            }\n\n            return svg;\n          });\n        };\n      }\n    }]);\n\n    return PointSeries;\n  }(Chart);\n\n  return PointSeries;\n}",null]}