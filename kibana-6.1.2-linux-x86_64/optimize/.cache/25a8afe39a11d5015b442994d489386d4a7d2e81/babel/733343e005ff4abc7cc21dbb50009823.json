{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/bind/bind.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/bind/bind.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_modules.uiModules.get('kibana').config(function ($provide) {\n\n  function strictEquality(a, b) {\n    // are the values equal? or, are they both NaN?\n    return a === b || a !== a && b !== b;\n  }\n\n  function errorNotAssignable(source, target) {\n    throw Error('Unable to accept change to bound $scope property \"' + source + '\"' + ' because source expression \"' + target + '\" is not assignable!');\n  }\n\n  $provide.decorator('$rootScope', function ($delegate, $parse) {\n    /**\n     * Two-way bind a value from scope to another property on scope. This\n     * allow values on scope that work like they do in an isolate scope, but\n     * without requiring one.\n     *\n     * @param  {expression} to - the location on scope to bind to\n     * @param  {expression} from - the location on scope to bind from\n     * @param  {Scope} $sourceScope - the scope to read \"from\" expression from\n     * @return {undefined}\n     */\n    $delegate.constructor.prototype.$bind = function (to, from, $sourceScope) {\n      var $source = $sourceScope || this.$parent;\n      var $target = this;\n\n      // parse expressions\n      var $to = $parse(to);\n      if (!$to.assign) errorNotAssignable(to, from);\n      var $from = $parse(from);\n\n      // bind scopes to expressions\n      var getTarget = function getTarget() {\n        return $to($target);\n      };\n      var setTarget = function setTarget(v) {\n        return $to.assign($target, v);\n      };\n      var getSource = function getSource() {\n        return $from($source);\n      };\n      var setSource = function setSource(v) {\n        return $from.assignOrFail($source, v);\n      };\n\n      // to support writing from the child to the parent we need to know\n      // which source has changed. Track the source value and anytime it\n      // changes (even if the target value changed too) push from source\n      // to target. If the source hasn't changed then the change is from\n      // the target and push accordingly\n      var lastSourceVal = getSource();\n\n      $from.assignOrFail = $from.assign || function () {\n        // revert the change and throw an error, child writes aren't supported\n        $to($target, lastSourceVal = $from($source));\n        errorNotAssignable(from, to);\n      };\n\n      // if we are syncing down a literal, then we use loose equality check\n      var strict = !$from.literal;\n      var compare = strict ? strictEquality : _angular2.default.equals;\n\n      // push the initial value down, start off in sync\n      setTarget(lastSourceVal);\n\n      $target.$watch(function () {\n        var sourceVal = getSource();\n        var targetVal = getTarget();\n\n        var outOfSync = !compare(sourceVal, targetVal);\n        var sourceChanged = outOfSync && !compare(sourceVal, lastSourceVal);\n\n        if (sourceChanged) setTarget(sourceVal);else if (outOfSync) setSource(targetVal);\n\n        return lastSourceVal = sourceVal;\n      }, null, !strict);\n    };\n\n    return $delegate;\n  });\n});",null]}