{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/data_source/_abstract.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/data_source/_abstract.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractDataSourceProvider = AbstractDataSourceProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nrequire('ui/promises');\n\nvar _request_queue = require('../_request_queue');\n\nvar _fetch = require('../fetch');\n\nvar _field_wildcard = require('../../field_wildcard');\n\nvar _highlight = require('../../../../core_plugins/kibana/common/highlight');\n\nvar _build_query = require('./build_query');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction AbstractDataSourceProvider(Private, Promise, PromiseEmitter, config) {\n  var fetchSoon = Private(_fetch.FetchSoonProvider);\n  var buildESQuery = Private(_build_query.BuildESQueryProvider);\n\n  var _Private = Private(_field_wildcard.FieldWildcardProvider),\n      fieldWildcardFilter = _Private.fieldWildcardFilter;\n\n  var getConfig = function getConfig() {\n    return config.get.apply(config, arguments);\n  };\n\n  function SourceAbstract(initialState) {\n    var self = this;\n    self._instanceid = _lodash2.default.uniqueId('data_source');\n\n    self._state = function () {\n      // state can be serialized as JSON, and passed back in to restore\n      if (initialState) {\n        if (typeof initialState === 'string') {\n          return JSON.parse(initialState);\n        } else {\n          return _lodash2.default.cloneDeep(initialState);\n        }\n      } else {\n        return {};\n      }\n    }();\n\n    // set internal state values\n    self._methods.forEach(function (name) {\n      self[name] = function (val) {\n        if (val == null) {\n          delete self._state[name];\n        } else {\n          self._state[name] = val;\n        }\n\n        return self;\n      };\n    });\n\n    self.history = [];\n    self._requestStartHandlers = [];\n  }\n\n  /*****\n   * PUBLIC API\n   *****/\n\n  /**\n   * Get values from the state\n   * @param {string} name - The name of the property desired\n   * @return {any} - the value found\n   */\n  SourceAbstract.prototype.get = function (name) {\n    var self = this;\n    while (self) {\n      if (self._state[name] !== void 0) return self._state[name];\n      self = self.getParent();\n    }\n  };\n\n  /**\n   * Get the value from our own state, don't traverse up the chain\n   * @param {string} name - The name of the property desired\n   * @return {any} - the value found\n   */\n  SourceAbstract.prototype.getOwn = function (name) {\n    if (this._state[name] !== void 0) return this._state[name];\n  };\n\n  /**\n   * Change the entire state of a SourceAbstract\n   * @param {object|string} state - The SourceAbstract's new state, or a\n   *   string of the state value to set\n   */\n  SourceAbstract.prototype.set = function (state, val) {\n    var self = this;\n\n    if (typeof state === 'string') {\n      // the getter and setter methods check for undefined explicitly\n      // to identify getters and null to identify deletion\n      if (val === undefined) {\n        val = null;\n      }\n      self[state](val);\n    } else {\n      self._state = state;\n    }\n    return self;\n  };\n\n  /**\n   * Create a new dataSource object of the same type\n   * as this, which inherits this dataSource's properties\n   * @return {SourceAbstract}\n   */\n  SourceAbstract.prototype.extend = function () {\n    return new this.Class().inherits(this);\n  };\n\n  /**\n   * return a simple, encodable object representing the state of the SourceAbstract\n   * @return {[type]} [description]\n   */\n  SourceAbstract.prototype.toJSON = function () {\n    return _lodash2.default.clone(this._state);\n  };\n\n  /**\n   * Create a string representation of the object\n   * @return {[type]} [description]\n   */\n  SourceAbstract.prototype.toString = function () {\n    return _angular2.default.toJson(this.toJSON());\n  };\n\n  /**\n   * Put a request in to the courier that this Source should\n   * be fetched on the next run of the courier\n   * @return {Promise}\n   */\n  SourceAbstract.prototype.onResults = function (handler) {\n    var self = this;\n\n    return new PromiseEmitter(function (resolve, reject) {\n      var defer = Promise.defer();\n      defer.promise.then(resolve, reject);\n\n      var request = self._createRequest(defer);\n\n      request.setErrorHandler(function (request, error) {\n        reject(error);\n        request.abort();\n      });\n    }, handler);\n  };\n\n  /**\n   * Noop\n   */\n  SourceAbstract.prototype.getParent = function () {\n    return this._parent;\n  };\n\n  /**\n   * Fetch just this source ASAP\n   *\n   * ONLY USE IF YOU WILL BE USING THE RESULTS\n   * provided by the returned promise, otherwise\n   * call #fetchQueued()\n   *\n   * @async\n   */\n  SourceAbstract.prototype.fetch = function () {\n    var self = this;\n    var req = _lodash2.default.first(self._myStartableQueued());\n\n    if (!req) {\n      req = self._createRequest();\n    }\n\n    fetchSoon.these([req]);\n\n    return req.getCompletePromise();\n  };\n\n  /**\n   * Fetch this source and reject the returned Promise on error\n   *\n   * Otherwise behaves like #fetch()\n   *\n   * @async\n   */\n  SourceAbstract.prototype.fetchAsRejectablePromise = function () {\n    var self = this;\n    var req = _lodash2.default.first(self._myStartableQueued());\n\n    if (!req) {\n      req = self._createRequest();\n    }\n\n    req.setErrorHandler(function (request, error) {\n      request.defer.reject(error);\n      request.abort();\n    });\n\n    fetchSoon.these([req]);\n\n    return req.getCompletePromise();\n  };\n\n  /**\n   * Fetch all pending requests for this source ASAP\n   * @async\n   */\n  SourceAbstract.prototype.fetchQueued = function () {\n    return fetchSoon.these(this._myStartableQueued());\n  };\n\n  /**\n   * Cancel all pending requests for this dataSource\n   * @return {undefined}\n   */\n  SourceAbstract.prototype.cancelQueued = function () {\n    var _this = this;\n\n    _request_queue.requestQueue.filter(function (req) {\n      return req.source === _this;\n    }).forEach(function (req) {\n      return req.abort();\n    });\n  };\n\n  /**\n   * Completely destroy the SearchSource.\n   * @return {undefined}\n   */\n  SourceAbstract.prototype.destroy = function () {\n    this.cancelQueued();\n    this._requestStartHandlers.length = 0;\n  };\n\n  /**\n   *  Add a handler that will be notified whenever requests start\n   *  @param  {Function} handler\n   *  @return {undefined}\n   */\n  SourceAbstract.prototype.onRequestStart = function (handler) {\n    this._requestStartHandlers.push(handler);\n  };\n\n  /**\n   *  Called by requests of this search source when they are started\n   *  @param  {Courier.Request} request\n   *  @return {Promise<undefined>}\n   */\n  SourceAbstract.prototype.requestIsStarting = function (request) {\n    var _this2 = this;\n\n    this.activeFetchCount = (this.activeFetchCount || 0) + 1;\n    this.history = [request];\n\n    return Promise.map(this._requestStartHandlers, function (fn) {\n      return fn(_this2, request);\n    }).then(_lodash2.default.noop);\n  };\n\n  /**\n   *  Called by requests of this search source when they are done\n   *  @param  {Courier.Request} request\n   *  @return {undefined}\n   */\n  SourceAbstract.prototype.requestIsStopped = function () /* request */{\n    this.activeFetchCount -= 1;\n  };\n\n  /*****\n   * PRIVATE API\n   *****/\n\n  SourceAbstract.prototype._myStartableQueued = function () {\n    var _this3 = this;\n\n    return _request_queue.requestQueue.getStartable().filter(function (req) {\n      return req.source === _this3;\n    });\n  };\n\n  SourceAbstract.prototype._createRequest = function () {\n    throw new Error('_createRequest must be implemented by subclass');\n  };\n\n  /**\n   * Walk the inheritance chain of a source and return it's\n   * flat representaion (taking into account merging rules)\n   * @returns {Promise}\n   * @resolved {Object|null} - the flat state of the SourceAbstract\n   */\n  SourceAbstract.prototype._flatten = function () {\n    var type = this._getType();\n\n    // the merged state of this dataSource and it's ancestors\n    var flatState = {};\n\n    // function used to write each property from each state object in the chain to flat state\n    var root = this;\n\n    // start the chain at this source\n    var current = this;\n\n    // call the ittr and return it's promise\n    return function ittr() {\n      // itterate the _state object (not array) and\n      // pass each key:value pair to source._mergeProp. if _mergeProp\n      // returns a promise, then wait for it to complete and call _mergeProp again\n      return Promise.all(_lodash2.default.map(current._state, function ittr(value, key) {\n        if (Promise.is(value)) {\n          return value.then(function (value) {\n            return ittr(value, key);\n          });\n        }\n\n        var prom = root._mergeProp(flatState, value, key);\n        return Promise.is(prom) ? prom : null;\n      })).then(function () {\n        // move to this sources parent\n        var parent = current.getParent();\n        // keep calling until we reach the top parent\n        if (parent) {\n          current = parent;\n          return ittr();\n        }\n      });\n    }().then(function () {\n      if (type === 'search') {\n        // This is down here to prevent the circular dependency\n        flatState.body = flatState.body || {};\n\n        var computedFields = flatState.index.getComputedFields();\n        flatState.body.stored_fields = computedFields.storedFields;\n        flatState.body.script_fields = flatState.body.script_fields || {};\n        flatState.body.docvalue_fields = flatState.body.docvalue_fields || [];\n\n        _lodash2.default.extend(flatState.body.script_fields, computedFields.scriptFields);\n        flatState.body.docvalue_fields = _lodash2.default.union(flatState.body.docvalue_fields, computedFields.docvalueFields);\n\n        if (flatState.body._source) {\n          // exclude source fields for this index pattern specified by the user\n          var filter = fieldWildcardFilter(flatState.body._source.excludes);\n          flatState.body.docvalue_fields = flatState.body.docvalue_fields.filter(filter);\n        }\n\n        // if we only want to search for certain fields\n        var fields = flatState.fields;\n        if (fields) {\n          // filter out the docvalue_fields, and script_fields to only include those that we are concerned with\n          flatState.body.docvalue_fields = _lodash2.default.intersection(flatState.body.docvalue_fields, fields);\n          flatState.body.script_fields = _lodash2.default.pick(flatState.body.script_fields, fields);\n\n          // request the remaining fields from both stored_fields and _source\n          var remainingFields = _lodash2.default.difference(fields, _lodash2.default.keys(flatState.body.script_fields));\n          flatState.body.stored_fields = remainingFields;\n          _lodash2.default.set(flatState.body, '_source.includes', remainingFields);\n        }\n\n        flatState.body.query = buildESQuery(flatState.index, flatState.query, flatState.filters);\n\n        if (flatState.highlightAll != null) {\n          if (flatState.highlightAll && flatState.body.query) {\n            flatState.body.highlight = (0, _highlight.getHighlightRequest)(flatState.body.query, getConfig);\n          }\n          delete flatState.highlightAll;\n        }\n\n        /**\n        * Translate a filter into a query to support es 3+\n        * @param  {Object} filter - The filter to translate\n        * @return {Object} the query version of that filter\n        */\n        var translateToQuery = function translateToQuery(filter) {\n          if (!filter) return;\n\n          if (filter.query) {\n            return filter.query;\n          }\n\n          return filter;\n        };\n\n        // re-write filters within filter aggregations\n        (function recurse(aggBranch) {\n          if (!aggBranch) return;\n          Object.keys(aggBranch).forEach(function (id) {\n            var agg = aggBranch[id];\n\n            if (agg.filters) {\n              // translate filters aggregations\n              var filters = agg.filters.filters;\n\n              Object.keys(filters).forEach(function (filterId) {\n                filters[filterId] = translateToQuery(filters[filterId]);\n              });\n            }\n\n            recurse(agg.aggs || agg.aggregations);\n          });\n        })(flatState.body.aggs || flatState.body.aggregations);\n      }\n\n      return flatState;\n    });\n  };\n\n  return SourceAbstract;\n}",null]}