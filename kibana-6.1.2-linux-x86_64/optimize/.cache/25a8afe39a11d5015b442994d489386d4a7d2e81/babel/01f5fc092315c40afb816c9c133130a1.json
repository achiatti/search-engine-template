{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/parse_interval.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/parse_interval.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseInterval = parseInterval;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Assume interval is in the form (value)(unit), such as \"1h\"\nvar INTERVAL_STRING_RE = new RegExp('^([0-9\\\\.]*)\\\\s*(' + _datemath2.default.units.join('|') + ')$');\n\nfunction parseInterval(interval) {\n  var matches = String(interval).trim().match(INTERVAL_STRING_RE);\n\n  if (!matches) return null;\n\n  try {\n    var value = parseFloat(matches[1]) || 1;\n    var unit = matches[2];\n\n    var duration = _moment2.default.duration(value, unit);\n\n    // There is an error with moment, where if you have a fractional interval between 0 and 1, then when you add that\n    // interval to an existing moment object, it will remain unchanged, which causes problems in the ordered_x_keys\n    // code. To counteract this, we find the first unit that doesn't result in a value between 0 and 1.\n    // For example, if you have '0.5d', then when calculating the x-axis series, we take the start date and begin\n    // adding 0.5 days until we hit the end date. However, since there is a bug in moment, when you add 0.5 days to\n    // the start date, you get the same exact date (instead of being ahead by 12 hours). So instead of returning\n    // a duration corresponding to 0.5 hours, we return a duration corresponding to 12 hours.\n    var selectedUnit = _lodash2.default.find(_datemath2.default.units, function (unit) {\n      return Math.abs(duration.as(unit)) >= 1;\n    });\n\n    return _moment2.default.duration(duration.as(selectedUnit), selectedUnit);\n  } catch (e) {\n    return null;\n  }\n}",null]}