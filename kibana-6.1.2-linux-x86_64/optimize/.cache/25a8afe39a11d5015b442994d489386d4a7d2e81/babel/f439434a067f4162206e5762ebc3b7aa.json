{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/visualize/editor/editor.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/visualize/editor/editor.js","mtime":1515552029000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nrequire('plugins/kibana/visualize/saved_visualizations/saved_visualizations');\n\nrequire('ui/vis/editors/default/sidebar');\n\nrequire('plugins/kibana/visualize/editor/agg_filter');\n\nrequire('ui/visualize');\n\nrequire('ui/collapsible_sidebar');\n\nrequire('ui/share');\n\nrequire('ui/query_bar');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _notifier = require('ui/notify/notifier');\n\nvar _vis_types = require('ui/registry/vis_types');\n\nvar _doc_title = require('ui/doc_title');\n\nvar _query_filter = require('ui/filter_bar/query_filter');\n\nvar _state_monitor_factory = require('ui/state_management/state_monitor_factory');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _modules = require('ui/modules');\n\nvar _editor = require('plugins/kibana/visualize/editor/editor.html');\n\nvar _editor2 = _interopRequireDefault(_editor);\n\nvar _dashboard_constants = require('plugins/kibana/dashboard/dashboard_constants');\n\nvar _visualize_constants = require('../visualize_constants');\n\nvar _kibana_parsed_url = require('ui/url/kibana_parsed_url');\n\nvar _absolute_to_parsed_url = require('ui/url/absolute_to_parsed_url');\n\nvar _migrateLegacyQuery = require('ui/utils/migrateLegacyQuery');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_routes2.default.when(_visualize_constants.VisualizeConstants.CREATE_PATH, {\n  template: _editor2.default,\n  resolve: {\n    savedVis: function savedVis(savedVisualizations, courier, $route, Private) {\n      var visTypes = Private(_vis_types.VisTypesRegistryProvider);\n      var visType = _lodash2.default.find(visTypes, { name: $route.current.params.type });\n      var shouldHaveIndex = visType.requiresSearch && visType.options.showIndexSelection;\n      var hasIndex = $route.current.params.indexPattern || $route.current.params.savedSearchId;\n      if (shouldHaveIndex && !hasIndex) {\n        throw new Error('You must provide either an indexPattern or a savedSearchId');\n      }\n\n      return savedVisualizations.get($route.current.params).catch(courier.redirectWhenMissing({\n        '*': '/visualize'\n      }));\n    }\n  }\n}).when(_visualize_constants.VisualizeConstants.EDIT_PATH + '/:id', {\n  template: _editor2.default,\n  resolve: {\n    savedVis: function savedVis(savedVisualizations, courier, $route) {\n      return savedVisualizations.get($route.current.params.id).catch(courier.redirectWhenMissing({\n        'visualization': '/visualize',\n        'search': '/management/kibana/objects/savedVisualizations/' + $route.current.params.id,\n        'index-pattern': '/management/kibana/objects/savedVisualizations/' + $route.current.params.id,\n        'index-pattern-field': '/management/kibana/objects/savedVisualizations/' + $route.current.params.id\n      }));\n    }\n  }\n});\n\n_modules.uiModules.get('app/visualize', ['kibana/notify', 'kibana/courier']).directive('visualizeApp', function () {\n  return {\n    restrict: 'E',\n    controllerAs: 'visualizeApp',\n    controller: VisEditor\n  };\n});\n\nfunction VisEditor($scope, $route, timefilter, AppState, $window, kbnUrl, courier, Private, Promise, config, kbnBaseUrl) {\n  var docTitle = Private(_doc_title.DocTitleProvider);\n  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);\n\n  var notify = new _notifier.Notifier({\n    location: 'Visualization Editor'\n  });\n\n  // Retrieve the resolved SavedVis instance.\n  var savedVis = $route.current.locals.savedVis;\n  // vis is instance of src/ui/public/vis/vis.js.\n  // SearchSource is a promise-based stream of search results that can inherit from other search sources.\n  var vis = savedVis.vis,\n      searchSource = savedVis.searchSource;\n\n  $scope.vis = vis;\n\n  $scope.topNavMenu = [{\n    key: 'save',\n    description: 'Save Visualization',\n    template: require('plugins/kibana/visualize/editor/panels/save.html'),\n    testId: 'visualizeSaveButton',\n    disableButton: function disableButton() {\n      return Boolean(vis.dirty);\n    },\n    tooltip: function tooltip() {\n      if (vis.dirty) {\n        return 'Apply or Discard your changes before saving';\n      }\n    }\n  }, {\n    key: 'share',\n    description: 'Share Visualization',\n    template: require('plugins/kibana/visualize/editor/panels/share.html'),\n    testId: 'visualizeShareButton'\n  }, {\n    key: 'refresh',\n    description: 'Refresh',\n    run: function run() {\n      vis.forceReload();\n    },\n    testId: 'visualizeRefreshButton'\n  }];\n\n  var stateMonitor = void 0;\n\n  var $appStatus = this.appStatus = {\n    dirty: !savedVis.id\n  };\n\n  if (savedVis.id) {\n    docTitle.change(savedVis.title);\n  }\n\n  // Extract visualization state with filtered aggs. You can see these filtered aggs in the URL.\n  // Consists of things like aggs, params, listeners, title, type, etc.\n  var savedVisState = vis.getState();\n  var stateDefaults = {\n    uiState: savedVis.uiStateJSON ? JSON.parse(savedVis.uiStateJSON) : {},\n    linked: !!savedVis.savedSearchId,\n    query: searchSource.getOwn('query') || { query: '', language: config.get('search:queryLanguage') },\n    filters: searchSource.getOwn('filter') || [],\n    vis: savedVisState\n  };\n\n  // Instance of app_state.js.\n  var $state = function initState() {\n    // This is used to sync visualization state with the url when `appState.save()` is called.\n    var appState = new AppState(stateDefaults);\n\n    // The savedVis is pulled from elasticsearch, but the appState is pulled from the url, with the\n    // defaults applied. If the url was from a previous session which included modifications to the\n    // appState then they won't be equal.\n    if (!_angular2.default.equals(appState.vis, savedVisState)) {\n      Promise.try(function () {\n        vis.setState(appState.vis);\n      }).catch(courier.redirectWhenMissing({\n        'index-pattern-field': '/visualize'\n      }));\n    }\n\n    return appState;\n  }();\n\n  function init() {\n    // export some objects\n    $scope.savedVis = savedVis;\n    $scope.indexPattern = vis.indexPattern;\n    $scope.searchSource = searchSource;\n    $scope.state = $state;\n\n    // Create a PersistedState instance.\n    $scope.uiState = $state.makeStateful('uiState');\n    $scope.appStatus = $appStatus;\n\n    var addToDashMode = $route.current.params[_dashboard_constants.DashboardConstants.ADD_VISUALIZATION_TO_DASHBOARD_MODE_PARAM];\n    kbnUrl.removeParam(_dashboard_constants.DashboardConstants.ADD_VISUALIZATION_TO_DASHBOARD_MODE_PARAM);\n\n    $scope.isAddToDashMode = function () {\n      return addToDashMode;\n    };\n\n    // Associate PersistedState instance with the Vis instance, so that\n    // `uiStateVal` can be called on it. Currently this is only used to extract\n    // map-specific information (e.g. mapZoom, mapCenter).\n    vis.setUiState($scope.uiState);\n\n    $scope.timefilter = timefilter;\n    $scope.opts = _lodash2.default.pick($scope, 'doSave', 'savedVis', 'shareData', 'timefilter', 'isAddToDashMode');\n\n    stateMonitor = _state_monitor_factory.stateMonitorFactory.create($state, stateDefaults);\n    stateMonitor.ignoreProps(['vis.listeners']).onChange(function (status) {\n      $appStatus.dirty = status.dirty || !savedVis.id;\n    });\n\n    $scope.$watch('state.query', $scope.updateQueryAndFetch);\n\n    $state.replace();\n\n    $scope.getVisualizationTitle = function getVisualizationTitle() {\n      return savedVis.lastSavedTitle || savedVis.title + ' (unsaved)';\n    };\n\n    $scope.$watchMulti(['searchSource.get(\"index\")', 'vis.type.options.showTimePicker'], function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          index = _ref2[0],\n          requiresTimePicker = _ref2[1];\n\n      timefilter.enabled = Boolean((!index || index.timeFieldName) && requiresTimePicker);\n    });\n\n    // update the searchSource when filters update\n    $scope.$listen(queryFilter, 'update', function () {\n      $state.save();\n    });\n\n    // update the searchSource when query updates\n    $scope.fetch = function () {\n      $state.save();\n      $scope.vis.forceReload();\n    };\n\n    $scope.$on('$destroy', function () {\n      savedVis.destroy();\n      stateMonitor.destroy();\n    });\n  }\n\n  $scope.updateQueryAndFetch = function (query) {\n    // reset state if language changes\n    if ($state.query.language && $state.query.language !== query.language) {\n      $state.filters = [];\n      $state.$newFilters = [];\n    }\n    $state.query = (0, _migrateLegacyQuery.migrateLegacyQuery)(query);\n    $scope.fetch();\n  };\n\n  /**\n   * Called when the user clicks \"Save\" button.\n   */\n  $scope.doSave = function () {\n    // vis.title was not bound and it's needed to reflect title into visState\n    $state.vis.title = savedVis.title;\n    $state.vis.type = savedVis.type || $state.vis.type;\n    savedVis.visState = $state.vis;\n    savedVis.uiStateJSON = _angular2.default.toJson($scope.uiState.getChanges());\n\n    savedVis.save().then(function (id) {\n      stateMonitor.setInitialState($state.toJSON());\n      $scope.kbnTopNav.close('save');\n\n      if (id) {\n        notify.info('Saved Visualization \"' + savedVis.title + '\"');\n        if ($scope.isAddToDashMode()) {\n          var savedVisualizationParsedUrl = new _kibana_parsed_url.KibanaParsedUrl({\n            basePath: _chrome2.default.getBasePath(),\n            appId: kbnBaseUrl.slice('/app/'.length),\n            appPath: kbnUrl.eval(_visualize_constants.VisualizeConstants.EDIT_PATH + '/{{id}}', { id: savedVis.id })\n          });\n          // Manually insert a new url so the back button will open the saved visualization.\n          $window.history.pushState({}, '', savedVisualizationParsedUrl.getRootRelativePath());\n          // Since we aren't reloading the page, only inserting a new browser history item, we need to manually update\n          // the last url for this app, so directly clicking on the Visualize tab will also bring the user to the saved\n          // url, not the unsaved one.\n          _chrome2.default.trackSubUrlForApp('kibana:visualize', savedVisualizationParsedUrl);\n\n          var lastDashboardAbsoluteUrl = _chrome2.default.getNavLinkById('kibana:dashboard').lastSubUrl;\n          var dashboardParsedUrl = (0, _absolute_to_parsed_url.absoluteToParsedUrl)(lastDashboardAbsoluteUrl, _chrome2.default.getBasePath());\n          dashboardParsedUrl.addQueryParameter(_dashboard_constants.DashboardConstants.NEW_VISUALIZATION_ID_PARAM, savedVis.id);\n          kbnUrl.change(dashboardParsedUrl.appPath);\n        } else if (savedVis.id === $route.current.params.id) {\n          docTitle.change(savedVis.lastSavedTitle);\n        } else {\n          kbnUrl.change(_visualize_constants.VisualizeConstants.EDIT_PATH + '/{{id}}', { id: savedVis.id });\n        }\n      }\n    }, notify.error);\n  };\n\n  $scope.unlink = function () {\n    if (!$state.linked) return;\n\n    notify.info('Unlinked Visualization \"' + savedVis.title + '\" from Saved Search \"' + savedVis.savedSearch.title + '\"');\n\n    $state.linked = false;\n    var parent = searchSource.getParent(true);\n    var parentsParent = parent.getParent(true);\n\n    delete savedVis.savedSearchId;\n    parent.set('filter', _lodash2.default.union(searchSource.getOwn('filter'), parent.getOwn('filter')));\n\n    // copy over all state except \"aggs\", \"query\" and \"filter\"\n    (0, _lodash2.default)(parent.toJSON()).omit(['aggs', 'filter', 'query']).forOwn(function (val, key) {\n      searchSource.set(key, val);\n    }).commit();\n\n    $state.query = searchSource.get('query');\n    $state.filters = searchSource.get('filter');\n    searchSource.inherits(parentsParent);\n\n    $scope.fetch();\n  };\n\n  $scope.getAdditionalMessage = function () {\n    return 'This visualization is marked as experimental. ' + vis.type.feedbackMessage;\n  };\n\n  init();\n}",null]}