{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/visualize/visualize.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/visualize/visualize.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nvar _modules = require('ui/modules');\n\nvar _state_monitor_factory = require('ui/state_management/state_monitor_factory');\n\nvar _visualize = require('ui/visualize/visualize.html');\n\nvar _visualize2 = _interopRequireDefault(_visualize);\n\nvar _vis_request_handlers = require('ui/registry/vis_request_handlers');\n\nvar _vis_response_handlers = require('ui/registry/vis_response_handlers');\n\nvar _resize_checker = require('ui/resize_checker');\n\nrequire('angular-sanitize');\n\nrequire('./visualization');\n\nrequire('./visualization_editor');\n\nvar _query_filter = require('ui/filter_bar/query_filter');\n\nvar _persisted_state = require('ui/persisted_state');\n\nvar _elasticsearch_errors = require('../elasticsearch_errors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n_modules.uiModules.get('kibana/directive', ['ngSanitize']).directive('visualize', function (Notifier, Private, timefilter, getAppState, Promise) {\n  var notify = new Notifier({ location: 'Visualize' });\n  var requestHandlers = Private(_vis_request_handlers.VisRequestHandlersRegistryProvider);\n  var responseHandlers = Private(_vis_response_handlers.VisResponseHandlersRegistryProvider);\n  var ResizeChecker = Private(_resize_checker.ResizeCheckerProvider);\n  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);\n\n  function getHandler(from, name) {\n    if (typeof name === 'function') return name;\n    return from.find(function (handler) {\n      return handler.name === name;\n    }).handler;\n  }\n\n  return {\n    restrict: 'E',\n    scope: {\n      showSpyPanel: '=?',\n      editorMode: '=?',\n      savedObj: '=?',\n      appState: '=?',\n      uiState: '=?',\n      savedId: '=?',\n      timeRange: '=?'\n    },\n    template: _visualize2.default,\n    link: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee($scope, $el) {\n        var resizeChecker, searchSource, filter, searchSourceFilters, requestHandler, responseHandler, handleVisUpdate, reload, handleQueryUpdate, oldUiState, stateMonitor, handleUiStateChange, resizeFunc, resizeInit;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                resizeChecker = new ResizeChecker($el);\n\n                if ($scope.savedObj) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw 'saved object was not provided to <visualize> directive';\n\n              case 3:\n                if (!$scope.appState) $scope.appState = getAppState();\n                if (!$scope.uiState) $scope.uiState = new _persisted_state.PersistedState({});\n\n                $scope.vis = $scope.savedObj.vis;\n                $scope.vis.visualizeScope = true;\n                $scope.vis.description = $scope.savedObj.description;\n\n                if ($scope.timeRange) {\n                  $scope.vis.params.timeRange = {\n                    min: _datemath2.default.parse($scope.timeRange.min),\n                    max: _datemath2.default.parse($scope.timeRange.max)\n                  };\n\n                  $scope.vis.aggs.forEach(function (agg) {\n                    if (agg.type.name !== 'date_histogram') return;\n                    agg.setTimeRange($scope.vis.params.timeRange);\n                  });\n\n                  searchSource = $scope.savedObj.searchSource;\n                  filter = timefilter.get(searchSource.index(), $scope.vis.params.timeRange);\n                  searchSourceFilters = searchSource.get('filter');\n\n                  if (searchSourceFilters instanceof Array) {\n                    searchSourceFilters.push(filter);\n                    searchSource.skipTimeRangeFilter = true;\n                  }\n                }\n\n                $scope.editorMode = $scope.editorMode || false;\n                $scope.vis.editorMode = $scope.editorMode;\n\n                // spy panel is supported only with courier request handler\n                $scope.shouldShowSpyPanel = function () {\n                  if ($scope.vis.type.requestHandler !== 'courier') return false;\n                  return $scope.vis.type.requiresSearch && $scope.showSpyPanel;\n                };\n\n                requestHandler = getHandler(requestHandlers, $scope.vis.type.requestHandler);\n                responseHandler = getHandler(responseHandlers, $scope.vis.type.responseHandler);\n\n\n                $scope.fetch = _lodash2.default.debounce(function () {\n                  if (!$scope.vis.initialized || !$scope.savedObj) return;\n                  // searchSource is only there for courier request handler\n                  requestHandler($scope.vis, $scope.appState, $scope.uiState, queryFilter, $scope.savedObj.searchSource).then(function (requestHandlerResponse) {\n\n                    //No need to call the response handler when there have been no data nor has been there changes\n                    //in the vis-state (response handler does not depend on uiStat\n                    var canSkipResponseHandler = $scope.previousRequestHandlerResponse && $scope.previousRequestHandlerResponse === requestHandlerResponse && $scope.previousVisState && _lodash2.default.isEqual($scope.previousVisState, $scope.vis.getState());\n\n                    $scope.previousVisState = $scope.vis.getState();\n                    $scope.previousRequestHandlerResponse = requestHandlerResponse;\n                    return canSkipResponseHandler ? $scope.visData : Promise.resolve(responseHandler($scope.vis, requestHandlerResponse));\n                  }, function (e) {\n                    $scope.savedObj.searchSource.cancelQueued();\n                    $el.trigger('renderComplete');\n                    if ((0, _elasticsearch_errors.isTermSizeZeroError)(e)) {\n                      return notify.error('Your visualization (\\'' + $scope.vis.title + '\\') has an error: it has a term ' + 'aggregation with a size of 0. Please set it to a number greater than 0 to resolve ' + 'the error.');\n                    }\n                    notify.error(e);\n                  }).then(function (resp) {\n                    $scope.visData = resp;\n                    $scope.$apply();\n                    $scope.$broadcast('render');\n                    return resp;\n                  });\n                }, 100);\n\n                //todo: clean this one up as well\n\n                handleVisUpdate = function handleVisUpdate() {\n                  if ($scope.editorMode) {\n                    $scope.appState.vis = $scope.vis.getState();\n                    $scope.appState.save();\n                  } else {\n                    $scope.fetch();\n                  }\n                };\n\n                $scope.vis.on('update', handleVisUpdate);\n\n                reload = function reload() {\n                  $scope.vis.reload = true;\n                  $scope.fetch();\n                };\n\n                $scope.vis.on('reload', reload);\n                // auto reload will trigger this event\n                $scope.$on('courier:searchRefresh', reload);\n                // dashboard will fire fetch event when it wants to refresh\n                $scope.$on('fetch', reload);\n\n                handleQueryUpdate = function handleQueryUpdate() {\n                  $scope.fetch();\n                };\n\n                queryFilter.on('update', handleQueryUpdate);\n\n                if ($scope.appState) {\n                  oldUiState = void 0;\n                  stateMonitor = _state_monitor_factory.stateMonitorFactory.create($scope.appState);\n\n                  stateMonitor.onChange(function (status, type, keys) {\n                    if (keys[0] === 'vis') {\n                      if ($scope.appState.vis) $scope.vis.setState($scope.appState.vis);\n                      $scope.fetch();\n                    }\n                    if ($scope.vis.type.requiresSearch && ['query', 'filters'].includes(keys[0])) {\n                      $scope.fetch();\n                    }\n                    if (keys[0] === 'uiState') {\n                      // uiState can be changed by other visualizations on dashboard. this makes sure this fires only if\n                      // current visualizations uiState changed.\n                      if (!oldUiState || oldUiState !== JSON.stringify($scope.uiState.toJSON())) {\n                        oldUiState = JSON.stringify($scope.uiState.toJSON());\n                        $scope.fetch();\n                      }\n                    }\n                  });\n\n                  $scope.$on('$destroy', function () {\n                    stateMonitor.destroy();\n                  });\n                } else {\n                  handleUiStateChange = function handleUiStateChange() {\n                    $scope.$broadcast('render');\n                  };\n\n                  $scope.uiState.on('change', handleUiStateChange);\n                  $scope.$on('$destroy', function () {\n                    $scope.uiState.off('change', handleUiStateChange);\n                  });\n                }\n\n                // the very first resize event is the initialization, which we can safely ignore.\n                // however, we also want to debounce the resize event, and not miss a resize event\n                // if it occurs within the first 200ms window\n                resizeFunc = _lodash2.default.debounce(function () {\n                  $scope.$broadcast('render');\n                }, 200);\n                resizeInit = false;\n\n                resizeChecker.on('resize', function () {\n                  if (!resizeInit) return resizeInit = true;\n                  resizeFunc();\n                });\n\n                // visualize needs to know about timeFilter\n                $scope.$listen(timefilter, 'fetch', $scope.fetch);\n                $scope.$on('renderComplete', function () {\n                  $el.trigger('renderComplete');\n                });\n\n                $scope.$on('$destroy', function () {\n                  $scope.vis.removeListener('update', handleVisUpdate);\n                  queryFilter.off('update', handleQueryUpdate);\n                  resizeChecker.destroy();\n                });\n\n                $scope.$watch('vis.initialized', $scope.fetch);\n\n                $scope.fetch();\n\n              case 32:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function link(_x, _x2) {\n        return _ref.apply(this, arguments);\n      }\n\n      return link;\n    }()\n  };\n});",null]}