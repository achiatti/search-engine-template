{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/notify/notifier.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/notify/notifier.js","mtime":1515552036000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Notifier = Notifier;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _metadata = require('ui/metadata');\n\nvar _format_msg = require('ui/notify/lib/_format_msg');\n\nvar _fatal_splash_screen = require('ui/notify/partials/fatal_splash_screen.html');\n\nvar _fatal_splash_screen2 = _interopRequireDefault(_fatal_splash_screen);\n\nrequire('ui/render_directive');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-console: 0 */\n\nvar notifs = [];\nvar version = _metadata.metadata.version;\nvar buildNum = _metadata.metadata.buildNum;\nvar consoleGroups = 'group' in window.console && 'groupCollapsed' in window.console && 'groupEnd' in window.console;\n\nvar log = _lodash2.default.bindKey(console, 'log');\n\n// used to identify the first call to fatal, set to false there\nvar firstFatal = true;\n\nvar fatalToastTemplate = function lazyTemplate(tmpl) {\n  var compiled = void 0;\n  return function (vars) {\n    return (compiled || (compiled = _lodash2.default.template(tmpl)))(vars);\n  };\n}(require('ui/notify/partials/fatal.html'));\n\nfunction now() {\n  if (window.performance && window.performance.now) {\n    return window.performance.now();\n  }\n  return Date.now();\n}\n\nfunction closeNotif(notif) {\n  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash2.default.noop;\n  var key = arguments[2];\n\n  return function () {\n    // this === notif\n    var i = notifs.indexOf(notif);\n    if (i !== -1) notifs.splice(i, 1);\n\n    cancelTimer(notif);\n    cb(key);\n  };\n}\n\nfunction cancelTimer(notif) {\n  if (notif.timerId) {\n    Notifier.config.clearInterval(notif.timerId);\n    notif.timerId = undefined;\n  }\n}\n\nfunction timerCanceler(notif) {\n  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash2.default.noop;\n  var key = arguments[2];\n\n  return function cancelNotifTimer() {\n    cancelTimer(notif);\n    cb(key);\n  };\n}\n\n/**\n * Initiates a timer to update _timeRemaining_ on the notif at second\n * intervals and clears the notif once the notif _lifetime_ has been reached.\n */\nfunction startNotifTimer(notif, cb) {\n  var interval = 1000;\n\n  if (notif.lifetime === Infinity || notif.lifetime === 0) {\n    return;\n  }\n\n  notif.timeRemaining = Math.floor(notif.lifetime / interval);\n\n  notif.timerId = Notifier.config.setInterval(function () {\n    notif.timeRemaining -= 1;\n\n    if (notif.timeRemaining <= 0) {\n      closeNotif(notif, cb, 'ignore')();\n    }\n  }, interval, notif.timeRemaining);\n\n  notif.cancelTimer = timerCanceler(notif, cb);\n}\n\nfunction restartNotifTimer(notif, cb) {\n  cancelTimer(notif);\n  startNotifTimer(notif, cb);\n}\n\nvar typeToButtonClassMap = {\n  danger: 'kuiButton--danger', // NOTE: `error` type is internally named as `danger`\n  warning: 'kuiButton--warning',\n  info: 'kuiButton--primary',\n  banner: 'kuiButton--basic'\n};\nvar buttonHierarchyClass = function buttonHierarchyClass(index) {\n  if (index === 0) {\n    // first action: primary className\n    return 'kuiButton--primary';\n  }\n  // subsequent actions: secondary/default className\n  return 'kuiButton--basic';\n};\nvar typeToAlertClassMap = {\n  danger: 'alert-danger',\n  warning: 'alert-warning',\n  info: 'alert-info',\n  banner: 'alert-banner'\n};\n\nfunction add(notif, cb) {\n  _lodash2.default.set(notif, 'info.version', version);\n  _lodash2.default.set(notif, 'info.buildNum', buildNum);\n\n  notif.clear = closeNotif(notif);\n\n  if (notif.actions) {\n    notif.actions.forEach(function (action) {\n      notif[action] = closeNotif(notif, cb, action);\n    });\n  } else if (notif.customActions) {\n    // wrap all of the custom functions in a close\n    notif.customActions = notif.customActions.map(function (action, index) {\n      return {\n        key: action.text,\n        dataTestSubj: action.dataTestSubj,\n        callback: closeNotif(notif, action.callback, action.text),\n        getButtonClass: function getButtonClass() {\n          var buttonTypeClass = typeToButtonClassMap[notif.type];\n          return buttonHierarchyClass(index) + ' ' + buttonTypeClass;\n        }\n      };\n    });\n  }\n\n  notif.count = (notif.count || 0) + 1;\n\n  notif.isTimed = function isTimed() {\n    return notif.timerId ? true : false;\n  };\n\n  // decorate the notification with helper functions for the template\n  notif.getButtonClass = function () {\n    return typeToButtonClassMap[notif.type];\n  };\n  notif.getAlertClassStack = function () {\n    return 'toast-stack alert ' + typeToAlertClassMap[notif.type];\n  };\n  notif.getIconClass = function () {\n    return notif.type === 'banner' ? '' : 'fa fa-' + notif.icon;\n  };\n  notif.getToastMessageClass = function () {\n    return notif.type === 'banner' ? 'toast-message-banner' : 'toast-message';\n  };\n  notif.getAlertClass = function () {\n    return notif.type === 'banner' ? 'alert ' + typeToAlertClassMap[notif.type] : // not including `.toast` class leaves out the flex properties for banner\n    'toast alert ' + typeToAlertClassMap[notif.type];\n  };\n  notif.getButtonGroupClass = function () {\n    return notif.type === 'banner' ? 'toast-controls-banner' : 'toast-controls';\n  };\n\n  var dup = null;\n  if (notif.content) {\n    dup = _lodash2.default.find(notifs, function (item) {\n      return item.content === notif.content && item.lifetime === notif.lifetime;\n    });\n  }\n\n  if (dup) {\n    dup.count += 1;\n    dup.stacks = _lodash2.default.union(dup.stacks, [notif.stack]);\n\n    restartNotifTimer(dup, cb);\n\n    return dup;\n  }\n\n  startNotifTimer(notif, cb);\n\n  notif.stacks = [notif.stack];\n  notifs.push(notif);\n  return notif;\n}\n\nfunction set(opts, cb) {\n  if (!opts.content) {\n    return null;\n  }\n\n  if (this._sovereignNotif) {\n    this._sovereignNotif.clear();\n  }\n\n  this._sovereignNotif = add(opts, cb);\n  return this._sovereignNotif;\n}\n\nNotifier.prototype.add = add;\nNotifier.prototype.set = set;\n\nfunction formatInfo() {\n  var info = [];\n\n  if (!_lodash2.default.isUndefined(version)) {\n    info.push('Version: ' + version);\n  }\n\n  if (!_lodash2.default.isUndefined(buildNum)) {\n    info.push('Build: ' + buildNum);\n  }\n\n  return info.join('\\n');\n}\n\n// browsers format Error.stack differently; always include message\nfunction formatStack(err) {\n  if (err.stack && !~err.stack.indexOf(err.message)) {\n    return 'Error: ' + err.message + '\\n' + err.stack;\n  }\n  return err.stack;\n}\n\n/**\n * Functionality to check that\n */\nfunction Notifier(opts) {\n  var self = this;\n  opts = opts || {};\n\n  // label type thing to say where notifications came from\n  self.from = opts.location;\n\n  'event lifecycle timed fatal error warning info banner'.split(' ').forEach(function (m) {\n    self[m] = _lodash2.default.bind(self[m], self);\n  });\n}\n\nNotifier.config = {\n  bannerLifetime: 3000000,\n  errorLifetime: 300000,\n  warningLifetime: 10000,\n  infoLifetime: 5000,\n  setInterval: window.setInterval,\n  clearInterval: window.clearInterval\n};\n\nNotifier.applyConfig = function (config) {\n  _lodash2.default.merge(Notifier.config, config);\n};\n\n// to be notified when the first fatal error occurs, push a function into this array.\nNotifier.fatalCallbacks = [];\n\n// \"Constants\"\nNotifier.QS_PARAM_MESSAGE = 'notif_msg';\nNotifier.QS_PARAM_LEVEL = 'notif_lvl';\nNotifier.QS_PARAM_LOCATION = 'notif_loc';\n\nNotifier.pullMessageFromUrl = function ($location) {\n  var queryString = $location.search();\n  if (!queryString.notif_msg) {\n    return;\n  }\n  var message = queryString[Notifier.QS_PARAM_MESSAGE];\n  var config = queryString[Notifier.QS_PARAM_LOCATION] ? { location: queryString[Notifier.QS_PARAM_LOCATION] } : {};\n  var level = queryString[Notifier.QS_PARAM_LEVEL] || 'info';\n\n  $location.search(Notifier.QS_PARAM_MESSAGE, null);\n  $location.search(Notifier.QS_PARAM_LOCATION, null);\n  $location.search(Notifier.QS_PARAM_LEVEL, null);\n\n  var notifier = new Notifier(config);\n  notifier[level](message);\n};\n\n// simply a pointer to the global notif list\nNotifier.prototype._notifs = notifs;\n\n/**\n * Log a sometimes redundant event\n * @param {string} name - The name of the group\n * @param {boolean} success - Simple flag stating whether the event succeeded\n */\nNotifier.prototype.event = createGroupLogger('event', {\n  open: true\n});\n\n/**\n * Log a major, important, event in the lifecycle of the application\n * @param {string} name - The name of the lifecycle event\n * @param {boolean} success - Simple flag stating whether the lifecycle event succeeded\n */\nNotifier.prototype.lifecycle = createGroupLogger('lifecycle', {\n  open: true\n});\n\n/**\n * Wrap a function so that it's execution time gets logged.\n *\n * @param {function} fn - the function to wrap, it's .name property is\n *                      read so make sure to set it\n * @return {function} - the wrapped function\n */\nNotifier.prototype.timed = function (name, fn) {\n  var self = this;\n\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  return function WrappedNotifierFunction() {\n    var cntx = this;\n    var args = arguments;\n\n    return self.event(name, function () {\n      return fn.apply(cntx, args);\n    });\n  };\n};\n\n/**\n * Kill the page, display an error, then throw the error.\n * Used as a last-resort error back in many promise chains\n * so it rethrows the error that's displayed on the page.\n *\n * @param  {Error} err - The error that occured\n */\nNotifier.prototype.fatal = function (err) {\n  this._showFatal(err);\n  throw err;\n};\n\n/**\n * Display an error that destroys the entire app. Broken out so that\n * global error handlers can display fatal errors without throwing another\n * error like in #fatal()\n *\n * @param  {Error} err - The fatal error that occured\n */\nNotifier.prototype._showFatal = function (err) {\n  if (firstFatal) {\n    _lodash2.default.callEach(Notifier.fatalCallbacks);\n    firstFatal = false;\n    window.addEventListener('hashchange', function () {\n      window.location.reload();\n    });\n  }\n\n  var html = fatalToastTemplate({\n    info: formatInfo(),\n    msg: (0, _format_msg.formatMsg)(err, this.from),\n    stack: formatStack(err)\n  });\n\n  var $container = (0, _jquery2.default)('#fatal-splash-screen');\n\n  if (!$container.size()) {\n    (0, _jquery2.default)(document.body)\n    // in case the app has not completed boot\n    .removeAttr('ng-cloak').html(_fatal_splash_screen2.default);\n\n    $container = (0, _jquery2.default)('#fatal-splash-screen');\n  }\n\n  $container.append(html);\n  console.error(err.stack);\n};\n\nvar overrideableOptions = ['lifetime', 'icon'];\n\n/**\n * Alert the user of an error that occured\n * @param  {Error|String} err\n * @param  {Function} cb\n */\nNotifier.prototype.error = function (err, opts, cb) {\n  if (_lodash2.default.isFunction(opts)) {\n    cb = opts;\n    opts = {};\n  }\n\n  var config = _lodash2.default.assign({\n    type: 'danger',\n    content: (0, _format_msg.formatMsg)(err, this.from),\n    icon: 'warning',\n    title: 'Error',\n    lifetime: Notifier.config.errorLifetime,\n    actions: ['report', 'accept'],\n    stack: formatStack(err)\n  }, _lodash2.default.pick(opts, overrideableOptions));\n  return add(config, cb);\n};\n\n/**\n * Warn the user abort something\n * @param  {String} msg\n * @param  {Function} cb\n */\nNotifier.prototype.warning = function (msg, opts, cb) {\n  if (_lodash2.default.isFunction(opts)) {\n    cb = opts;\n    opts = {};\n  }\n\n  var config = _lodash2.default.assign({\n    type: 'warning',\n    content: (0, _format_msg.formatMsg)(msg, this.from),\n    icon: 'warning',\n    title: 'Warning',\n    lifetime: Notifier.config.warningLifetime,\n    actions: ['accept']\n  }, _lodash2.default.pick(opts, overrideableOptions));\n  return add(config, cb);\n};\n\n/**\n * Display a debug message\n * @param  {String} msg\n * @param  {Function} cb\n */\nNotifier.prototype.info = function (msg, opts, cb) {\n  if (_lodash2.default.isFunction(opts)) {\n    cb = opts;\n    opts = {};\n  }\n\n  var config = _lodash2.default.assign({\n    type: 'info',\n    content: (0, _format_msg.formatMsg)(msg, this.from),\n    icon: 'info-circle',\n    title: 'Debug',\n    lifetime: _lodash2.default.get(opts, 'lifetime', Notifier.config.infoLifetime),\n    actions: ['accept']\n  }, _lodash2.default.pick(opts, overrideableOptions));\n  return add(config, cb);\n};\n\n/**\n * Display a banner message\n * @param  {String} msg\n * @param  {Function} cb\n */\nNotifier.prototype.banner = function (msg, cb) {\n  return this.set({\n    type: 'banner',\n    title: 'Attention',\n    content: (0, _format_msg.formatMsg)(msg, this.from),\n    lifetime: Notifier.config.bannerLifetime,\n    actions: ['accept']\n  }, cb);\n};\n\n/**\n * Helper for common behavior in custom and directive types\n */\nfunction getDecoratedCustomConfig(config) {\n  // There is no helper condition that will allow for 2 parameters, as the\n  // other methods have. So check that config is an object\n  if (!_lodash2.default.isPlainObject(config)) {\n    throw new Error('Config param is required, and must be an object');\n  }\n\n  // workaround to allow callers to send `config.type` as `error` instead of\n  // reveal internal implementation that error notifications use a `danger`\n  // style\n  if (config.type === 'error') {\n    config.type = 'danger';\n  }\n\n  var getLifetime = function getLifetime(type) {\n    switch (type) {\n      case 'banner':\n        return Notifier.config.bannerLifetime;\n      case 'warning':\n        return Notifier.config.warningLifetime;\n      case 'danger':\n        return Notifier.config.errorLifetime;\n      default:\n        // info\n        return Notifier.config.infoLifetime;\n    }\n  };\n\n  var customConfig = _lodash2.default.assign({\n    type: 'info',\n    title: 'Notification',\n    lifetime: getLifetime(config.type)\n  }, config);\n\n  var hasActions = _lodash2.default.get(customConfig, 'actions.length');\n  if (hasActions) {\n    customConfig.customActions = customConfig.actions;\n    delete customConfig.actions;\n  } else {\n    customConfig.actions = ['accept'];\n  }\n\n  return customConfig;\n}\n\n/**\n * Display a custom message\n * @param  {String} msg - required\n * @param  {Object} config - required\n * @param  {Function} cb - optional\n *\n * config = {\n *   title: 'Some Title here',\n *   type: 'info',\n *   actions: [{\n *     text: 'next',\n *     callback: function() { next(); }\n *   }, {\n *     text: 'prev',\n *     callback: function() { prev(); }\n *   }]\n * }\n */\nNotifier.prototype.custom = function (msg, config, cb) {\n  var customConfig = getDecoratedCustomConfig(config);\n  customConfig.content = (0, _format_msg.formatMsg)(msg, this.from);\n  return add(customConfig, cb);\n};\n\n/**\n * Display a scope-bound directive using template rendering in the message area\n * @param  {Object} directive - required\n * @param  {Object} config - required\n * @param  {Function} cb - optional\n *\n * directive = {\n *  template: `<p>Hello World! <a ng-click=\"example.clickHandler()\">Click me</a>.`,\n *  controllerAs: 'example',\n *  controller() {\n *    this.clickHandler = () {\n *      // do something\n *    };\n *  }\n * }\n *\n * config = {\n *   title: 'Some Title here',\n *   type: 'info',\n *   actions: [{\n *     text: 'next',\n *     callback: function() { next(); }\n *   }, {\n *     text: 'prev',\n *     callback: function() { prev(); }\n *   }]\n * }\n */\nNotifier.prototype.directive = function (directive, config, cb) {\n  if (!_lodash2.default.isPlainObject(directive)) {\n    throw new Error('Directive param is required, and must be an object');\n  }\n  if (!Notifier.$compile) {\n    throw new Error('Unable to use the directive notification until Angular has initialized.');\n  }\n  if (directive.scope) {\n    throw new Error('Directive should not have a scope definition. Notifier has an internal implementation.');\n  }\n  if (directive.link) {\n    throw new Error('Directive should not have a link function. Notifier has an internal link function helper.');\n  }\n\n  // make a local copy of the directive param (helps unit tests)\n  var localDirective = _lodash2.default.clone(directive, true);\n\n  localDirective.scope = { notif: '=' };\n  localDirective.link = function link($scope, $el) {\n    var $template = _angular2.default.element($scope.notif.directive.template);\n    var postLinkFunction = Notifier.$compile($template);\n    $el.html($template);\n    postLinkFunction($scope);\n  };\n\n  var customConfig = getDecoratedCustomConfig(config);\n  customConfig.directive = localDirective;\n  return add(customConfig, cb);\n};\n\nNotifier.prototype.describeError = _format_msg.formatMsg.describeError;\n\nif (log === _lodash2.default.noop) {\n  Notifier.prototype.log = _lodash2.default.noop;\n} else {\n  Notifier.prototype.log = function () {\n    var args = [].slice.apply(arguments);\n    if (this.from) args.unshift(this.from + ':');\n    log.apply(null, args);\n  };\n}\n\n// general functionality used by .event() and .lifecycle()\nfunction createGroupLogger(type, opts) {\n  // Track the groups managed by this logger\n  var groups = window[type + 'Groups'] = {};\n\n  return function logger(name, success) {\n    var status = void 0; // status of the timer\n    var exec = void 0; // function to execute and wrap\n    var ret = void 0; // return value\n\n    var complete = function complete(val) {\n      logger(name, true);return val;\n    };\n    var failure = function failure(err) {\n      logger(name, false);throw err;\n    };\n\n    if (typeof success === 'function' || success === void 0) {\n      // start\n      groups[name] = now();\n      if (success) {\n        // success === the function to time\n        exec = success;\n      } else {\n        // function that can report on the success or failure of an op, and pass their value along\n        ret = complete;\n        ret.failure = failure;\n      }\n    } else {\n      groups[name] = now() - (groups[name] || 0);\n      var time = ' in ' + groups[name].toFixed(2) + 'ms';\n\n      // end\n      if (success) {\n        status = 'complete' + time;\n      } else {\n        groups[name] = false;\n        status = 'failure' + time;\n      }\n    }\n\n    if (consoleGroups) {\n      if (status) {\n        console.log(status);\n        console.groupEnd();\n      } else {\n        if (opts.open) {\n          console.group(name);\n        } else {\n          console.groupCollapsed(name);\n        }\n      }\n    } else {\n      log('KBN: ' + name + (status ? ' - ' + status : ''));\n    }\n\n    if (exec) {\n      try {\n        ret = exec();\n      } catch (e) {\n        return failure(e);\n      }\n\n      if (ret && typeof ret.then === 'function') {\n        // return a new promise that proxies the value\n        // and logs about the promise outcome\n        return ret.then(function (val) {\n          complete();\n          return val;\n        }, function (err) {\n          failure(err);\n          throw err;\n        });\n      }\n\n      // the function executed fine, and didn't return a promise, move along\n      complete();\n    }\n\n    return ret;\n  };\n}",null]}