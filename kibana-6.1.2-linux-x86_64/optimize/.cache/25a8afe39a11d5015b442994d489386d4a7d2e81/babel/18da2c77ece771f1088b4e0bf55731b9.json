{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/metrics/public/visualizations/lib/calculate_corrdinates.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/metrics/public/visualizations/lib/calculate_corrdinates.js","mtime":1515552030000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = calculateCorrdinates;\n\nvar _reactDom = require('react-dom');\n\nvar _calc_dimensions = require('./calc_dimensions');\n\nvar _calc_dimensions2 = _interopRequireDefault(_calc_dimensions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction calculateCorrdinates(innerRef, resizeRef, state) {\n  var inner = (0, _reactDom.findDOMNode)(innerRef);\n  var resize = (0, _reactDom.findDOMNode)(resizeRef);\n  var scale = state.scale;\n\n  // Let's start by scaling to the largest dimension\n  if (resize.clientWidth - resize.clientHeight < 0) {\n    scale = resize.clientWidth / inner.clientWidth;\n  } else {\n    scale = resize.clientHeight / inner.clientHeight;\n  }\n\n  var _calcDimensions = (0, _calc_dimensions2.default)(inner, scale),\n      _calcDimensions2 = _slicedToArray(_calcDimensions, 2),\n      newWidth = _calcDimensions2[0],\n      newHeight = _calcDimensions2[1];\n\n  // Now we need to check to see if it will still fit\n\n\n  if (newWidth > resize.clientWidth) {\n    scale = resize.clientWidth / inner.clientWidth;\n  }\n  if (newHeight > resize.clientHeight) {\n    scale = resize.clientHeight / inner.clientHeight;\n  }\n\n  // Calculate the final dimensions\n\n  // Because scale is middle out we need to translate\n  // the new X,Y corrdinates\n  var _calcDimensions3 = (0, _calc_dimensions2.default)(inner, scale);\n\n  var _calcDimensions4 = _slicedToArray(_calcDimensions3, 2);\n\n  newWidth = _calcDimensions4[0];\n  newHeight = _calcDimensions4[1];\n  var translateX = (newWidth - inner.clientWidth) / 2;\n  var translateY = (newHeight - inner.clientHeight) / 2;\n\n  // Center up and down\n  var top = Math.floor((resize.clientHeight - newHeight) / 2);\n  var left = Math.floor((resize.clientWidth - newWidth) / 2);\n\n  return { scale: scale, top: top, left: left, translateY: translateY, translateX: translateX };\n}\nmodule.exports = exports['default'];",null]}