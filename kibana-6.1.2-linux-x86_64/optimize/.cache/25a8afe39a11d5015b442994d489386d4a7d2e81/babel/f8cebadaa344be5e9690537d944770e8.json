{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/field_editor/field_editor.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/field_editor/field_editor.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nrequire('ui/field_format_editor');\n\nrequire('angular-bootstrap-colorpicker');\n\nrequire('angular-bootstrap-colorpicker/css/colorpicker.css');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _field_formats = require('ui/registry/field_formats');\n\nvar _field = require('ui/index_patterns/_field');\n\nvar _modules = require('ui/modules');\n\nvar _field_editor = require('ui/field_editor/field_editor.html');\n\nvar _field_editor2 = _interopRequireDefault(_field_editor);\n\nrequire('../directives/documentation_href');\n\nrequire('./field_editor.less');\n\nvar _scripting_languages = require('../scripting_languages');\n\nvar _utils = require('../../../utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_modules.uiModules.get('kibana', ['colorpicker.module']).directive('fieldEditor', function (Private, $sce, confirmModal, config) {\n  var getConfig = function getConfig() {\n    return config.get.apply(config, arguments);\n  };\n  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);\n  var Field = Private(_field.IndexPatternsFieldProvider);\n  var getEnabledScriptingLanguages = Private(_scripting_languages.GetEnabledScriptingLanguagesProvider);\n\n  var fieldTypesByLang = {\n    painless: ['number', 'string', 'date', 'boolean'],\n    expression: ['number'],\n    default: (0, _utils.getKbnTypeNames)()\n  };\n\n  return {\n    restrict: 'E',\n    template: _field_editor2.default,\n    scope: {\n      getIndexPattern: '&indexPattern',\n      getField: '&field'\n    },\n    controllerAs: 'editor',\n    controller: function controller($scope, Notifier, kbnUrl) {\n      var self = this;\n      var notify = new Notifier({ location: 'Field Editor' });\n\n      getScriptingLangs().then(function (langs) {\n        self.scriptingLangs = langs;\n        if (!_lodash2.default.includes(self.scriptingLangs, self.field.lang)) {\n          self.field.lang = undefined;\n        }\n      });\n\n      self.indexPattern = $scope.getIndexPattern();\n      self.field = shadowCopy($scope.getField());\n      self.formatParams = self.field.format.params();\n      self.conflictDescriptionsLength = self.field.conflictDescriptions ? Object.keys(self.field.conflictDescriptions).length : 0;\n\n      // only init on first create\n      self.creating = !self.indexPattern.fields.byName[self.field.name];\n      self.existingFieldNames = self.indexPattern.fields.map(function (field) {\n        return field.name;\n      }); //used for mapping conflict validation\n      self.selectedFormatId = _lodash2.default.get(self.indexPattern, ['fieldFormatMap', self.field.name, 'type', 'id']);\n      self.defFormatType = initDefaultFormat();\n\n      self.cancel = redirectAway;\n      self.save = function () {\n        var indexPattern = self.indexPattern;\n        var fields = indexPattern.fields;\n        var field = self.field.toActualField();\n\n        var index = fields.findIndex(function (f) {\n          return f.name === field.name;\n        });\n        if (index > -1) {\n          fields.splice(index, 1, field);\n        } else {\n          fields.push(field);\n        }\n\n        if (!self.selectedFormatId) {\n          delete indexPattern.fieldFormatMap[field.name];\n        } else {\n          indexPattern.fieldFormatMap[field.name] = self.field.format;\n        }\n\n        return indexPattern.save().then(function () {\n          notify.info('Saved Field \"' + self.field.name + '\"');\n          redirectAway();\n        });\n      };\n\n      self.delete = function () {\n        function doDelete() {\n          var indexPattern = self.indexPattern;\n          var field = self.field;\n\n          indexPattern.fields.remove({ name: field.name });\n          return indexPattern.save().then(function () {\n            notify.info('Deleted Field \"' + field.name + '\"');\n            redirectAway();\n          });\n        }\n        var confirmModalOptions = {\n          confirmButtonText: 'Delete field',\n          onConfirm: doDelete\n        };\n        confirmModal('Are you sure want to delete \\'' + self.field.name + '\\'? This action is irreversible!', confirmModalOptions);\n      };\n\n      self.isDeprecatedLang = function (lang) {\n        return _lodash2.default.contains((0, _scripting_languages.getDeprecatedScriptingLanguages)(), lang);\n      };\n\n      $scope.$watch('editor.selectedFormatId', function (cur, prev) {\n        var format = self.field.format;\n        var changedFormat = cur !== prev;\n        var missingFormat = cur && (!format || format.type.id !== cur);\n\n        if (!changedFormat || !missingFormat) return;\n\n        // reset to the defaults, but make sure it's an object\n        var FieldFormat = getFieldFormatType();\n        var paramDefaults = new FieldFormat({}, getConfig).getParamDefaults();\n        self.formatParams = _lodash2.default.assign({}, _lodash2.default.cloneDeep(paramDefaults));\n      });\n\n      $scope.$watch('editor.formatParams', function () {\n        var FieldFormat = getFieldFormatType();\n        self.field.format = new FieldFormat(self.formatParams, getConfig);\n      }, true);\n\n      $scope.$watch('editor.field.type', function (newValue) {\n        self.defFormatType = initDefaultFormat();\n        self.fieldFormatTypes = [self.defFormatType].concat(fieldFormats.byFieldType[newValue] || []);\n\n        if (_lodash2.default.isUndefined(_lodash2.default.find(self.fieldFormatTypes, { id: self.selectedFormatId }))) {\n          delete self.selectedFormatId;\n        }\n      });\n\n      $scope.$watch('editor.field.lang', function (newValue) {\n        self.fieldTypes = _lodash2.default.get(fieldTypesByLang, newValue, fieldTypesByLang.default);\n\n        if (!_lodash2.default.contains(self.fieldTypes, self.field.type)) {\n          self.field.type = _lodash2.default.first(self.fieldTypes);\n        }\n      });\n\n      // copy the defined properties of the field to a plain object\n      // which is mutable, and capture the changed seperately.\n      function shadowCopy(field) {\n        var changes = {};\n        var shadowProps = {\n          toActualField: {\n            // bring the shadow copy out of the shadows\n            value: function toActualField() {\n              return new Field(self.indexPattern, _lodash2.default.defaults({}, changes, field.$$spec));\n            }\n          }\n        };\n\n        Object.getOwnPropertyNames(field).forEach(function (prop) {\n          var desc = Object.getOwnPropertyDescriptor(field, prop);\n          shadowProps[prop] = {\n            enumerable: desc.enumerable,\n            get: function get() {\n              return _lodash2.default.has(changes, prop) ? changes[prop] : field[prop];\n            },\n            set: function set(v) {\n              changes[prop] = v;\n            }\n          };\n        });\n\n        return Object.create(null, shadowProps);\n      }\n\n      function redirectAway() {\n        kbnUrl.changeToRoute(self.indexPattern, self.field.scripted ? 'scriptedFields' : 'indexedFields');\n      }\n\n      function getFieldFormatType() {\n        if (self.selectedFormatId) return fieldFormats.getType(self.selectedFormatId);else return fieldFormats.getDefaultType(self.field.type);\n      }\n\n      function getScriptingLangs() {\n        return getEnabledScriptingLanguages().then(function (enabledLanguages) {\n          return _lodash2.default.intersection(enabledLanguages, _lodash2.default.union((0, _scripting_languages.getSupportedScriptingLanguages)(), (0, _scripting_languages.getDeprecatedScriptingLanguages)()));\n        });\n      }\n\n      function initDefaultFormat() {\n        var def = Object.create(fieldFormats.getDefaultType(self.field.type));\n\n        // explicitly set to undefined to prevent inheritting the prototypes id\n        def.id = undefined;\n        def.resolvedTitle = def.title;\n        def.title = '- default - ';\n\n        return def;\n      }\n    }\n  };\n});",null]}