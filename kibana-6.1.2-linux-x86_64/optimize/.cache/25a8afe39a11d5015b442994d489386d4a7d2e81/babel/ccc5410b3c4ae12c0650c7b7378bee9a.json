{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/management/sections/objects/_objects.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/kibana/public/management/sections/objects/_objects.js","mtime":1515552029000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _filesaver = require('@elastic/filesaver');\n\nvar _lodash = require('lodash');\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _saved_object_registry = require('plugins/kibana/management/saved_object_registry');\n\nvar _objects = require('plugins/kibana/management/sections/objects/_objects.html');\n\nvar _objects2 = _interopRequireDefault(_objects);\n\nrequire('ui/directives/file_upload');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _saved_objects = require('ui/saved_objects');\n\nvar _modules = require('ui/modules');\n\nvar _show_change_index_modal = require('./show_change_index_modal');\n\nvar _errors = require('ui/errors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar indexPatternsResolutions = {\n  indexPatterns: function indexPatterns(Private) {\n    var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n\n    return savedObjectsClient.find({\n      type: 'index-pattern',\n      fields: ['title'],\n      perPage: 10000\n    }).then(function (response) {\n      return response.savedObjects;\n    });\n  }\n};\n\n_routes2.default.when('/management/kibana/objects', {\n  template: _objects2.default,\n  resolve: indexPatternsResolutions\n});\n\n_routes2.default.when('/management/kibana/objects/:service', {\n  redirectTo: '/management/kibana/objects'\n});\n\n_modules.uiModules.get('apps/management').directive('kbnManagementObjects', function ($route, kbnIndex, Notifier, Private, kbnUrl, Promise, confirmModal) {\n  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n\n  return {\n    restrict: 'E',\n    controllerAs: 'managementObjectsController',\n    controller: function controller($scope, $injector, $q, AppState) {\n      var _this = this;\n\n      var notify = new Notifier({ location: 'Saved Objects' });\n\n      // TODO: Migrate all scope variables to the controller.\n      var $state = $scope.state = new AppState();\n      $scope.currentTab = null;\n      $scope.selectedItems = [];\n\n      this.areAllRowsChecked = function areAllRowsChecked() {\n        if ($scope.currentTab.data.length === 0) {\n          return false;\n        }\n        return $scope.selectedItems.length === $scope.currentTab.data.length;\n      };\n\n      var getData = function getData(filter) {\n        var services = _saved_object_registry.savedObjectManagementRegistry.all().map(function (obj) {\n          var service = $injector.get(obj.service);\n          return service.findAll(filter).then(function (data) {\n            return {\n              service: service,\n              serviceName: obj.service,\n              title: obj.title,\n              type: service.type,\n              data: data.hits,\n              total: data.total\n            };\n          });\n        });\n\n        $q.all(services).then(function (data) {\n          $scope.services = (0, _lodash.sortBy)(data, 'title');\n          if ($state.tab) $scope.currentTab = (0, _lodash.find)($scope.services, { title: $state.tab });\n\n          $scope.$watch('state.tab', function (tab) {\n            if (!tab) $scope.changeTab($scope.services[0]);\n          });\n        });\n      };\n\n      var refreshData = function refreshData() {\n        return getData(_this.advancedFilter);\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.toggleAll = function () {\n        if ($scope.selectedItems.length === $scope.currentTab.data.length) {\n          $scope.selectedItems.length = 0;\n        } else {\n          $scope.selectedItems = [].concat($scope.currentTab.data);\n        }\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.toggleItem = function (item) {\n        var i = $scope.selectedItems.indexOf(item);\n        if (i >= 0) {\n          $scope.selectedItems.splice(i, 1);\n        } else {\n          $scope.selectedItems.push(item);\n        }\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.open = function (item) {\n        kbnUrl.change(item.url.substr(1));\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.edit = function (service, item) {\n        var params = {\n          service: service.serviceName,\n          id: item.id\n        };\n\n        kbnUrl.change('/management/kibana/objects/{{ service }}/{{ id }}', params);\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.bulkDelete = function () {\n        function doBulkDelete() {\n          $scope.currentTab.service.delete((0, _lodash.pluck)($scope.selectedItems, 'id')).then(refreshData).then(function () {\n            $scope.selectedItems.length = 0;\n          }).catch(function (error) {\n            return notify.error(error);\n          });\n        }\n\n        var confirmModalOptions = {\n          confirmButtonText: 'Delete ' + $scope.currentTab.title,\n          onConfirm: doBulkDelete\n        };\n        confirmModal('Are you sure you want to delete the selected ' + $scope.currentTab.title + '? This action is irreversible!', confirmModalOptions);\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.bulkExport = function () {\n        var objs = $scope.selectedItems.map(function (item) {\n          return { type: $scope.currentTab.type, id: item.id };\n        });\n\n        retrieveAndExportDocs(objs);\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.exportAll = function () {\n        return Promise.map($scope.services, function (service) {\n          return service.service.scanAll('').then(function (result) {\n            return result.hits;\n          });\n        }).then(function (results) {\n          return saveToFile((0, _lodash.flattenDeep)(results));\n        }).catch(function (error) {\n          return notify.error(error);\n        });\n      };\n\n      function retrieveAndExportDocs(objs) {\n        if (!objs.length) return notify.error('No saved objects to export.');\n\n        savedObjectsClient.bulkGet(objs).then(function (response) {\n          saveToFile(response.savedObjects.map(function (obj) {\n            return {\n              _id: obj.id,\n              _type: obj.type,\n              _source: obj.attributes\n            };\n          }));\n        });\n      }\n\n      function saveToFile(results) {\n        var blob = new Blob([_angular2.default.toJson(results, true)], { type: 'application/json' });\n        (0, _filesaver.saveAs)(blob, 'export.json');\n      }\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.importAll = function (fileContents) {\n        var docs = void 0;\n        try {\n          docs = JSON.parse(fileContents);\n        } catch (e) {\n          notify.error('The file could not be processed.');\n          return;\n        }\n\n        // make sure we have an array, show an error otherwise\n        if (!Array.isArray(docs)) {\n          notify.error('Saved objects file format is invalid and cannot be imported.');\n          return;\n        }\n\n        return new Promise(function (resolve) {\n          confirmModal('If any of the objects already exist, do you want to automatically overwrite them?', {\n            confirmButtonText: 'Yes, overwrite all',\n            cancelButtonText: 'No, prompt me for each one',\n            onConfirm: function onConfirm() {\n              return resolve(true);\n            },\n            onCancel: function onCancel() {\n              return resolve(false);\n            }\n          });\n        }).then(function (overwriteAll) {\n          // Keep a record of the index patterns assigned to our imported saved objects that do not\n          // exist. We will provide a way for the user to manually select a new index pattern for those\n          // saved objects.\n          var conflictedIndexPatterns = [];\n          // We want to do the same for saved searches, but we want to keep them separate because they need\n          // to be applied _first_ because other saved objects can be depedent on those saved searches existing\n          var conflictedSearchDocs = [];\n\n          function importDocument(swallowErrors, doc) {\n            var _ref = (0, _lodash.find)($scope.services, { type: doc._type }) || {},\n                service = _ref.service;\n\n            if (!service) {\n              var msg = 'Skipped import of \"' + doc._source.title + '\" (' + doc._id + ')';\n              var reason = 'Invalid type: \"' + doc._type + '\"';\n\n              notify.warning(msg + ', ' + reason, {\n                lifetime: 0\n              });\n\n              return;\n            }\n\n            return service.get().then(function (obj) {\n              obj.id = doc._id;\n              return obj.applyESResp(doc).then(function () {\n                return obj.save({ confirmOverwrite: !overwriteAll });\n              }).catch(function (err) {\n                if (swallowErrors && err instanceof _errors.SavedObjectNotFound) {\n                  switch (err.savedObjectType) {\n                    case 'search':\n                      conflictedSearchDocs.push(doc);\n                      return;\n                    case 'index-pattern':\n                      conflictedIndexPatterns.push({ obj: obj, doc: doc });\n                      return;\n                  }\n                }\n                // swallow errors here so that the remaining promise chain executes\n                err.message = 'Importing ' + obj.title + ' (' + obj.id + ') failed: ' + err.message;\n                notify.error(err);\n              });\n            });\n          }\n\n          function groupByType(docs) {\n            var defaultDocTypes = {\n              searches: [],\n              other: []\n            };\n\n            return docs.reduce(function (types, doc) {\n              switch (doc._type) {\n                case 'search':\n                  types.searches.push(doc);\n                  break;\n                default:\n                  types.other.push(doc);\n              }\n              return types;\n            }, defaultDocTypes);\n          }\n\n          function resolveConflicts(objs, _ref2) {\n            var obj = _ref2.obj;\n\n            var oldIndexId = obj.searchSource.getOwn('index');\n            var newIndexId = objs.find(function (_ref3) {\n              var oldId = _ref3.oldId;\n              return oldId === oldIndexId;\n            }).newId;\n            // If the user did not select a new index pattern in the modal, the id\n            // will be same as before, so don't try to update it\n            if (newIndexId === oldIndexId) {\n              return;\n            }\n            return obj.hydrateIndexPattern(newIndexId).then(function () {\n              return obj.save({ confirmOverwrite: !overwriteAll });\n            });\n          }\n\n          var docTypes = groupByType(docs);\n\n          return Promise.map(docTypes.searches, importDocument.bind(null, true)).then(function () {\n            return Promise.map(docTypes.other, importDocument.bind(null, true));\n          }).then(function () {\n            if (conflictedIndexPatterns.length) {\n              return new Promise(function (resolve, reject) {\n                (0, _show_change_index_modal.showChangeIndexModal)(function (objs) {\n                  Promise.map(conflictedIndexPatterns, resolveConflicts.bind(null, objs)).then(resolve).catch(reject);\n                }, conflictedIndexPatterns, $route.current.locals.indexPatterns);\n              });\n            }\n          }).then(function () {\n            return Promise.map(conflictedSearchDocs, importDocument.bind(null, false));\n          }).then(refreshData).catch(notify.error);\n        });\n      };\n\n      // TODO: Migrate all scope methods to the controller.\n      $scope.changeTab = function (tab) {\n        $scope.currentTab = tab;\n        $scope.selectedItems.length = 0;\n        $state.tab = tab.title;\n        $state.save();\n      };\n\n      $scope.$watch('managementObjectsController.advancedFilter', function (filter) {\n        getData(filter);\n      });\n    }\n  };\n});",null]}