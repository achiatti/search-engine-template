{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/persisted_state/persisted_state.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/persisted_state/persisted_state.js","mtime":1515552037000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PersistedState = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @name PersistedState\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @extends Events\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _toPath = require('lodash/internal/toPath');\n\nvar _toPath2 = _interopRequireDefault(_toPath);\n\nvar _errors = require('ui/errors');\n\nvar _simple_emitter = require('ui/utils/simple_emitter');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction prepSetParams(key, value, path) {\n  // key must be the value, set the entire state using it\n  if (_lodash2.default.isUndefined(value) && (_lodash2.default.isPlainObject(key) || path.length > 0)) {\n    // setting entire tree, swap the key and value to write to the state\n    value = key;\n    key = undefined;\n  }\n\n  // ensure the value being passed in is never mutated\n  return {\n    value: _lodash2.default.cloneDeep(value),\n    key: key\n  };\n}\n\nvar PersistedState = exports.PersistedState = function () {\n\n  /**\n   *\n   * @param value\n   * @param path\n   * @param parent\n   * @param silent\n   * @param EmitterClass {SimpleEmitter} - a SimpleEmitter class that this class will extend. Can be used to\n   * inherit a custom event emitter. For example, the EventEmitter is an \"angular-ized\" version\n   * for angular components which automatically triggers a digest loop for every registered\n   * handler.  TODO: Get rid of the need for EventEmitter by wrapping handlers that require it\n   * in a special function that will handler triggering the digest loop.\n   */\n  function PersistedState(value, path, parent, silent) {\n    var _this = this;\n\n    var EmitterClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _simple_emitter.SimpleEmitter;\n\n    _classCallCheck(this, PersistedState);\n\n    EmitterClass.call(this);\n\n    this._EmitterClass = EmitterClass;\n    this._path = this._setPath(path);\n    this._parent = parent || false;\n\n    _lodash2.default.forOwn(EmitterClass.prototype, function (method, methodName) {\n      _this[methodName] = function () {\n        return EmitterClass.prototype[methodName].apply(this._parent || this, arguments);\n      };\n    });\n\n    // Some validations\n    if (this._parent) {\n      if (this._path.length <= 0) {\n        throw new _errors.PersistedStateError('PersistedState child objects must contain a path');\n      }\n      if (!(this._parent instanceof PersistedState)) {\n        throw new _errors.PersistedStateError('Parent object must be an instance of PersistedState');\n      }\n    } else if (!this._path.length && value && !_lodash2.default.isPlainObject(value)) {\n      throw new _errors.PersistedStateError('State value must be a plain object');\n    }\n\n    value = value || this._getDefault();\n\n    // copy passed state values and create internal trackers\n    silent ? this.setSilent(value) : this.set(value);\n    this._initialized = true; // used to track state changes\n  }\n\n  _createClass(PersistedState, [{\n    key: 'get',\n    value: function get(key, def) {\n      return _lodash2.default.cloneDeep(this._get(key, def));\n    }\n  }, {\n    key: 'set',\n    value: function set(key, value) {\n      var params = prepSetParams(key, value, this._path);\n      var val = this._set(params.key, params.value);\n      this.emit('set');\n      return val;\n    }\n  }, {\n    key: 'setSilent',\n    value: function setSilent(key, value) {\n      var params = prepSetParams(key, value, this._path);\n      return this._set(params.key, params.value, true);\n    }\n  }, {\n    key: 'reset',\n    value: function reset(path) {\n      var keyPath = this._getIndex(path);\n      var origValue = _lodash2.default.get(this._defaultState, keyPath);\n      var currentValue = _lodash2.default.get(this._mergedState, keyPath);\n\n      if (_lodash2.default.isUndefined(origValue)) {\n        this._cleanPath(path, this._mergedState);\n      } else {\n        _lodash2.default.set(this._mergedState, keyPath, origValue);\n      }\n\n      // clean up the changedState and defaultChildState trees\n      this._cleanPath(path, this._changedState);\n      this._cleanPath(path, this._defaultChildState);\n\n      if (!_lodash2.default.isEqual(currentValue, origValue)) this.emit('change');\n    }\n\n    /**\n     *\n     * @param path {String}\n     * @param value {Object} The uiState to store.\n     * @param silent {Boolean}\n     * @returns {PersistedState}\n     */\n\n  }, {\n    key: 'createChild',\n    value: function createChild(path, value, silent) {\n      this._setChild(this._getIndex(path), value, this._parent || this);\n      return new PersistedState(value, this._getIndex(path), this._parent || this, silent, this._EmitterClass);\n    }\n  }, {\n    key: 'removeChild',\n    value: function removeChild(path) {\n      var origValue = _lodash2.default.get(this._defaultState, this._getIndex(path));\n\n      if (_lodash2.default.isUndefined(origValue)) {\n        this.reset(path);\n      } else {\n        this.set(path, origValue);\n      }\n    }\n  }, {\n    key: 'getChanges',\n    value: function getChanges() {\n      return _lodash2.default.cloneDeep(this._changedState);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.get();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return JSON.stringify(this.toJSON());\n    }\n  }, {\n    key: 'fromString',\n    value: function fromString(input) {\n      return this.set(JSON.parse(input));\n    }\n  }, {\n    key: '_getIndex',\n    value: function _getIndex(key) {\n      if (_lodash2.default.isUndefined(key)) return this._path;\n      return (this._path || []).concat((0, _toPath2.default)(key));\n    }\n  }, {\n    key: '_getPartialIndex',\n    value: function _getPartialIndex(key) {\n      var keyPath = this._getIndex(key);\n      return keyPath.slice(this._path.length);\n    }\n  }, {\n    key: '_cleanPath',\n    value: function _cleanPath(path, stateTree) {\n      var partialPath = this._getPartialIndex(path);\n      var remove = true;\n\n      // recursively delete value tree, when no other keys exist\n      while (partialPath.length > 0) {\n        var lastKey = partialPath.splice(partialPath.length - 1, 1)[0];\n        var statePath = this._path.concat(partialPath);\n        var stateVal = statePath.length > 0 ? _lodash2.default.get(stateTree, statePath) : stateTree;\n\n        // if stateVal isn't an object, do nothing\n        if (!_lodash2.default.isPlainObject(stateVal)) return;\n\n        if (remove) delete stateVal[lastKey];\n        if (Object.keys(stateVal).length > 0) remove = false;\n      }\n    }\n  }, {\n    key: '_getDefault',\n    value: function _getDefault() {\n      var def = this._hasPath() ? undefined : {};\n      return this._parent ? this.get() : def;\n    }\n  }, {\n    key: '_setPath',\n    value: function _setPath(path) {\n      var isString = _lodash2.default.isString(path);\n      var isArray = Array.isArray(path);\n\n      if (!isString && !isArray) return [];\n      return isString ? [this._getIndex(path)] : path;\n    }\n  }, {\n    key: '_setChild',\n    value: function _setChild(path, value, parent) {\n      parent._defaultChildState = parent._defaultChildState || {};\n      _lodash2.default.set(parent._defaultChildState, path, value);\n    }\n  }, {\n    key: '_hasPath',\n    value: function _hasPath() {\n      return this._path.length > 0;\n    }\n  }, {\n    key: '_get',\n    value: function _get(key, def) {\n      // delegate to parent instance\n      if (this._parent) return this._parent._get(this._getIndex(key), def);\n\n      // no path and no key, get the whole state\n      if (!this._hasPath() && _lodash2.default.isUndefined(key)) {\n        return this._mergedState;\n      }\n\n      return _lodash2.default.get(this._mergedState, this._getIndex(key), def);\n    }\n  }, {\n    key: '_set',\n    value: function _set(key, value, silent, initialChildState) {\n      var self = this;\n      var stateChanged = false;\n      var initialState = !this._initialized;\n      var keyPath = this._getIndex(key);\n      var hasKeyPath = keyPath.length > 0;\n\n      // if this is the initial state value, save value as the default\n      if (initialState) {\n        this._changedState = {};\n        if (!this._hasPath() && _lodash2.default.isUndefined(key)) this._defaultState = value;else this._defaultState = _lodash2.default.set({}, keyPath, value);\n      }\n\n      // delegate to parent instance, passing child's default value\n      if (this._parent) {\n        return this._parent._set(keyPath, value, silent, initialState);\n      }\n\n      // everything in here affects only the parent state\n      if (!initialState) {\n        // no path and no key, set the whole state\n        if (!this._hasPath() && _lodash2.default.isUndefined(key)) {\n          // compare changedState and new state, emit an event when different\n          stateChanged = !_lodash2.default.isEqual(this._changedState, value);\n          if (!initialChildState) {\n            this._changedState = value;\n            this._mergedState = _lodash2.default.cloneDeep(value);\n          }\n        } else {\n          // check for changes at path, emit an event when different\n          var curVal = hasKeyPath ? this.get(keyPath) : this._mergedState;\n          stateChanged = !_lodash2.default.isEqual(curVal, value);\n\n          if (!initialChildState) {\n            // arrays are merge by index, not desired - ensure they are replaced\n            if (Array.isArray(_lodash2.default.get(this._mergedState, keyPath))) {\n              if (hasKeyPath) _lodash2.default.set(this._mergedState, keyPath, undefined);else this._mergedState = undefined;\n            }\n\n            if (hasKeyPath) _lodash2.default.set(this._changedState, keyPath, value);else this._changedState = _lodash2.default.isPlainObject(value) ? value : {};\n          }\n        }\n      }\n\n      // update the merged state value\n      var targetObj = this._mergedState || _lodash2.default.cloneDeep(this._defaultState);\n      var sourceObj = _lodash2.default.merge({}, this._defaultChildState, this._changedState);\n\n      // handler arguments are (targetValue, sourceValue, key, target, source)\n      var mergeMethod = function mergeMethod(targetValue, sourceValue, mergeKey) {\n        // if not initial state, skip default merge method (ie. return value, see note below)\n        if (!initialState && !initialChildState && _lodash2.default.isEqual(keyPath, self._getIndex(mergeKey))) {\n          // use the sourceValue or fall back to targetValue\n          return !_lodash2.default.isUndefined(sourceValue) ? sourceValue : targetValue;\n        }\n      };\n\n      // If `mergeMethod` is provided it is invoked to produce the merged values of the\n      // destination and source properties.\n      // If `mergeMethod` returns `undefined` the default merging method is used\n      this._mergedState = _lodash2.default.merge(targetObj, sourceObj, mergeMethod);\n\n      // sanity check; verify that there are actually changes\n      if (_lodash2.default.isEqual(this._mergedState, this._defaultState)) this._changedState = {};\n\n      if (!silent && stateChanged) this.emit('change');\n\n      return this;\n    }\n  }]);\n\n  return PersistedState;\n}();",null]}