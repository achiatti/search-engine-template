{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/looper/search.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/looper/search.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SearchLooperProvider = SearchLooperProvider;\n\nvar _fetch = require('../fetch');\n\nvar _request_queue = require('../_request_queue');\n\nvar _looper = require('./_looper');\n\nfunction SearchLooperProvider(Private, Promise, $rootScope) {\n  var fetchSoon = Private(_fetch.FetchSoonProvider);\n\n  var Looper = Private(_looper.LooperProvider);\n\n  /**\n   * The Looper which will manage the doc fetch interval\n   * @type {Looper}\n   */\n  var searchLooper = new Looper(null, function () {\n    $rootScope.$broadcast('courier:searchRefresh');\n    var requests = _request_queue.requestQueue.getInactive();\n    // promise returned from fetch.these() only resolves when\n    // the requests complete, but we want to continue even if\n    // the requests abort so we make our own\n    fetchSoon.these(requests);\n    return Promise.all(requests.map(function (request) {\n      return request.getCompleteOrAbortedPromise();\n    }));\n  });\n\n  searchLooper.onHastyLoop = function () {\n    if (searchLooper.afterHastyQueued) return;\n\n    searchLooper.afterHastyQueued = Promise.resolve(searchLooper.active).then(function () {\n      return searchLooper._loopTheLoop();\n    }).finally(function () {\n      searchLooper.afterHastyQueued = null;\n    });\n  };\n\n  return searchLooper;\n}",null]}