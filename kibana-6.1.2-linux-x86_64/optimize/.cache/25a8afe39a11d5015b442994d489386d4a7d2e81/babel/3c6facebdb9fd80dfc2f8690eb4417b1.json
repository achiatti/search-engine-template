{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/state_management/app_state.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/state_management/app_state.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AppStateProvider = AppStateProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _modules = require('ui/modules');\n\nvar _state = require('ui/state_management/state');\n\nrequire('ui/persisted_state');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @name AppState\n *\n * @extends State\n *\n * @description Inherits State, which inherits Events. This class seems to be\n * concerned with mapping \"props\" to PersistedState instances, and surfacing the\n * ability to destroy those mappings.\n */\n\nvar urlParam = '_a';\n\nfunction AppStateProvider(Private, $rootScope, $location, $injector) {\n  var State = Private(_state.StateProvider);\n  var PersistedState = $injector.get('PersistedState');\n  var persistedStates = void 0;\n  var eventUnsubscribers = void 0;\n\n  _lodash2.default.class(AppState).inherits(State);\n  function AppState(defaults) {\n    // Initialize persistedStates. This object maps \"prop\" names to\n    // PersistedState instances. These are used to make properties \"stateful\".\n    persistedStates = {};\n\n    // Initialize eventUnsubscribers. These will be called in `destroy`, to\n    // remove handlers for the 'change' and 'fetch_with_changes' events which\n    // are dispatched via the rootScope.\n    eventUnsubscribers = [];\n\n    AppState.Super.call(this, urlParam, defaults);\n    AppState.getAppState._set(this);\n  }\n\n  // if the url param is missing, write it back\n  AppState.prototype._persistAcrossApps = false;\n\n  AppState.prototype.destroy = function () {\n    AppState.Super.prototype.destroy.call(this);\n    AppState.getAppState._set(null);\n    _lodash2.default.callEach(eventUnsubscribers);\n  };\n\n  /**\n   * @returns PersistedState instance.\n   */\n  AppState.prototype.makeStateful = function (prop) {\n    var _this = this;\n\n    if (persistedStates[prop]) return persistedStates[prop];\n    var self = this;\n\n    // set up the ui state\n    persistedStates[prop] = new PersistedState();\n\n    // update the app state when the stateful instance changes\n    var updateOnChange = function updateOnChange() {\n      var replaceState = false; // TODO: debouncing logic\n      self[prop] = persistedStates[prop].getChanges();\n      // Save state to the URL.\n      self.save(replaceState);\n    };\n    var handlerOnChange = function handlerOnChange(method) {\n      return persistedStates[prop][method]('change', updateOnChange);\n    };\n    handlerOnChange('on');\n    eventUnsubscribers.push(function () {\n      return handlerOnChange('off');\n    });\n\n    // update the stateful object when the app state changes\n    var persistOnChange = function persistOnChange(changes) {\n      if (!changes) return;\n\n      if (changes.indexOf(prop) !== -1) {\n        persistedStates[prop].set(self[prop]);\n      }\n    };\n    var handlePersist = function handlePersist(method) {\n      return _this[method]('fetch_with_changes', persistOnChange);\n    };\n    handlePersist('on');\n    eventUnsubscribers.push(function () {\n      return handlePersist('off');\n    });\n\n    // if the thing we're making stateful has an appState value, write to persisted state\n    if (self[prop]) persistedStates[prop].setSilent(self[prop]);\n\n    return persistedStates[prop];\n  };\n\n  AppState.getAppState = function () {\n    var currentAppState = void 0;\n\n    function get() {\n      return currentAppState;\n    }\n\n    // Checks to see if the appState might already exist, even if it hasn't been newed up\n    get.previouslyStored = function () {\n      var search = $location.search();\n      return search[urlParam] ? true : false;\n    };\n\n    get._set = function (current) {\n      currentAppState = current;\n    };\n\n    return get;\n  }();\n\n  return AppState;\n}\n\n_modules.uiModules.get('kibana/global_state').factory('AppState', function (Private) {\n  return Private(AppStateProvider);\n}).service('getAppState', function (Private) {\n  return Private(AppStateProvider).getAppState;\n});",null]}