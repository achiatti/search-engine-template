{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/autocomplete/engine.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/autocomplete/engine.js","mtime":1515552026000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AutocompleteComponent = AutocompleteComponent;\nexports.wrapComponentWithDefaults = wrapComponentWithDefaults;\nexports.resolvePathToComponents = resolvePathToComponents;\nexports.populateContext = populateContext;\nvar _ = require('lodash');\n\nfunction AutocompleteComponent(name) {\n  this.name = name;\n}\n\n/** called to get the possible suggestions for tokens, when this object is at the end of\n * the resolving chain (and thus can suggest possible continuation paths)\n */\nAutocompleteComponent.prototype.getTerms = function () {\n  return [];\n};\n\n/*\n if the current matcher matches this term, this method should return an object with the following keys\n {\n context_values: {\n values extract from term that should be added to the context\n }\n next: AutocompleteComponent(s) to use next\n priority: optional priority to solve collisions between multiple paths. Min value is used across entire chain\n }\n */\nAutocompleteComponent.prototype.match = function () {\n  return {\n    next: this.next\n  };\n};\n\nfunction SharedComponent(name, parent) {\n  AutocompleteComponent.call(this, name);\n  this._nextDict = {};\n  if (parent) {\n    parent.addComponent(this);\n  }\n  // for debugging purposes\n  this._parent = parent;\n}\n\nSharedComponent.prototype = _.create(AutocompleteComponent.prototype, { 'constructor': SharedComponent });\n\n(function (cls) {\n  /* return the first component with a given name */\n  cls.getComponent = function (name) {\n    return (this._nextDict[name] || [undefined])[0];\n  };\n\n  cls.addComponent = function (component) {\n    var current = this._nextDict[component.name] || [];\n    current.push(component);\n    this._nextDict[component.name] = current;\n    this.next = [].concat.apply([], _.values(this._nextDict));\n  };\n})(SharedComponent.prototype);\n\n/** A component that suggests one of the give options, but accepts anything */\nfunction ListComponent(name, list, parent, multi_valued, allow_non_valid_values) {\n  SharedComponent.call(this, name, parent);\n  this.listGenerator = Array.isArray(list) ? function () {\n    return list;\n  } : list;\n  this.multi_valued = _.isUndefined(multi_valued) ? true : multi_valued;\n  this.allow_non_valid_values = _.isUndefined(allow_non_valid_values) ? false : allow_non_valid_values;\n}\n\nListComponent.prototype = _.create(SharedComponent.prototype, { \"constructor\": ListComponent });\n\n(function (cls) {\n  cls.getTerms = function (context, editor) {\n    if (!this.multi_valued && context.otherTokenValues) {\n      // already have a value -> no suggestions\n      return [];\n    }\n    var already_set = context.otherTokenValues || [];\n    if (_.isString(already_set)) {\n      already_set = [already_set];\n    }\n    var ret = _.difference(this.listGenerator(context, editor), already_set);\n\n    if (this.getDefaultTermMeta()) {\n      var meta = this.getDefaultTermMeta();\n      ret = _.map(ret, function (term) {\n        if (_.isString(term)) {\n          term = { \"name\": term };\n        }\n        return _.defaults(term, { meta: meta });\n      });\n    }\n\n    return ret;\n  };\n\n  cls.validateTokens = function (tokens) {\n    if (!this.multi_valued && tokens.length > 1) {\n      return false;\n    }\n\n    // verify we have all tokens\n    var list = this.listGenerator();\n    var not_found = _.any(tokens, function (token) {\n      return list.indexOf(token) == -1;\n    });\n\n    if (not_found) {\n      return false;\n    }\n    return true;\n  };\n\n  cls.getContextKey = function () {\n    return this.name;\n  };\n\n  cls.getDefaultTermMeta = function () {\n    return this.name;\n  };\n\n  cls.match = function (token, context, editor) {\n    if (!Array.isArray(token)) {\n      token = [token];\n    }\n    if (!this.allow_non_valid_values && !this.validateTokens(token, context, editor)) {\n      return null;\n    }\n\n    var result = Object.getPrototypeOf(cls).match.call(this, token, context, editor);\n    result.context_values = result.context_values || {};\n    result.context_values[this.getContextKey()] = token;\n    return result;\n  };\n})(ListComponent.prototype);\n\nfunction SimpleParamComponent(name, parent) {\n  SharedComponent.call(this, name, parent);\n}\n\nSimpleParamComponent.prototype = _.create(SharedComponent.prototype, { \"constructor\": SimpleParamComponent });\n\n(function (cls) {\n  cls.match = function (token, context, editor) {\n    var result = Object.getPrototypeOf(cls).match.call(this, token, context, editor);\n    result.context_values = result.context_values || {};\n    result.context_values[this.name] = token;\n    return result;\n  };\n})(SimpleParamComponent.prototype);\n\nfunction ConstantComponent(name, parent, options) {\n  SharedComponent.call(this, name, parent);\n  if (_.isString(options)) {\n    options = [options];\n  }\n  this.options = options || [name];\n}\n\nConstantComponent.prototype = _.create(SharedComponent.prototype, { \"constructor\": ConstantComponent });\n\nexports.SharedComponent = SharedComponent;\nexports.ListComponent = ListComponent;\nexports.SimpleParamComponent = SimpleParamComponent;\nexports.ConstantComponent = ConstantComponent;\n\n\n(function (cls) {\n  cls.getTerms = function () {\n    return this.options;\n  };\n\n  cls.addOption = function (options) {\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    [].push.apply(this.options, options);\n    this.options = _.uniq(this.options);\n  };\n  cls.match = function (token, context, editor) {\n    if (token !== this.name) {\n      return null;\n    }\n\n    return Object.getPrototypeOf(cls).match.call(this, token, context, editor);\n  };\n})(ConstantComponent.prototype);\n\nfunction wrapComponentWithDefaults(component, defaults) {\n  function Wrapper() {}\n\n  Wrapper.prototype = {};\n  for (var key in component) {\n    if (_.isFunction(component[key])) {\n      Wrapper.prototype[key] = _.bindKey(component, key);\n    }\n  }\n\n  Wrapper.prototype.getTerms = function (context, editor) {\n    var result = component.getTerms(context, editor);\n    if (!result) {\n      return result;\n    }\n    result = _.map(result, function (term) {\n      if (!_.isObject(term)) {\n        term = { name: term };\n      }\n      return _.defaults(term, defaults);\n    }, this);\n    return result;\n  };\n  return new Wrapper();\n}\n\nvar tracer = function tracer() {\n  if (window.engine_trace) {\n    console.log.call(console, arguments);\n  }\n};\n\nfunction passThroughContext(context, extensionList) {\n  function PTC() {}\n\n  PTC.prototype = context;\n  var result = new PTC();\n  if (extensionList) {\n    extensionList.unshift(result);\n    _.assign.apply(_, extensionList);\n    extensionList.shift();\n  }\n  return result;\n}\n\nfunction WalkingState(parent_name, components, contextExtensionList, depth, priority) {\n  this.parent_name = parent_name;\n  this.components = components;\n  this.contextExtensionList = contextExtensionList;\n  this.depth = depth || 0;\n  this.priority = priority;\n}\n\nfunction walkTokenPath(tokenPath, walkingStates, context, editor) {\n  if (!tokenPath || tokenPath.length === 0) {\n    return walkingStates;\n  }\n  var token = tokenPath[0],\n      nextWalkingStates = [];\n\n  tracer(\"starting token evaluation [\" + token + \"]\");\n\n  _.each(walkingStates, function (ws) {\n    var contextForState = passThroughContext(context, ws.contextExtensionList);\n    _.each(ws.components, function (component) {\n      tracer(\"evaluating [\" + token + \"] with [\" + component.name + \"]\", component);\n      var result = component.match(token, contextForState, editor);\n      if (result && !_.isEmpty(result)) {\n        tracer(\"matched [\" + token + \"] with:\", result);\n        var next, extensionList;\n        if (result.next && !Array.isArray(result.next)) {\n          next = [result.next];\n        } else {\n          next = result.next;\n        }\n        if (result.context_values) {\n          extensionList = [];\n          [].push.apply(extensionList, ws.contextExtensionList);\n          extensionList.push(result.context_values);\n        } else {\n          extensionList = ws.contextExtensionList;\n        }\n\n        var priority = ws.priority;\n        if (_.isNumber(result.priority)) {\n          if (_.isNumber(priority)) {\n            priority = Math.min(priority, result.priority);\n          } else {\n            priority = result.priority;\n          }\n        }\n\n        nextWalkingStates.push(new WalkingState(component.name, next, extensionList, ws.depth + 1, priority));\n      }\n    });\n  });\n\n  if (nextWalkingStates.length == 0) {\n    // no where to go, still return context variables returned so far..\n    return _.map(walkingStates, function (ws) {\n      return new WalkingState(ws.name, [], ws.contextExtensionList);\n    });\n  }\n\n  return walkTokenPath(tokenPath.slice(1), nextWalkingStates, context, editor);\n}\n\nfunction resolvePathToComponents(tokenPath, context, editor, components) {\n  var walkStates = walkTokenPath(tokenPath, [new WalkingState(\"ROOT\", components, [])], context, editor);\n  var result = [].concat.apply([], _.pluck(walkStates, 'components'));\n  return result;\n}\n\nfunction populateContext(tokenPath, context, editor, includeAutoComplete, components) {\n\n  var walkStates = walkTokenPath(tokenPath, [new WalkingState(\"ROOT\", components, [])], context, editor);\n  if (includeAutoComplete) {\n    var autoCompleteSet = [];\n    _.each(walkStates, function (ws) {\n      var contextForState = passThroughContext(context, ws.contextExtensionList);\n      _.each(ws.components, function (component) {\n        _.each(component.getTerms(contextForState, editor), function (term) {\n          if (!_.isObject(term)) {\n            term = { name: term };\n          }\n          autoCompleteSet.push(term);\n        });\n      });\n    });\n    autoCompleteSet = _.uniq(autoCompleteSet, false);\n    context.autoCompleteSet = autoCompleteSet;\n  }\n\n  // apply what values were set so far to context, selecting the deepest on which sets the context\n  if (walkStates.length !== 0) {\n    var wsToUse;\n    walkStates = _.sortBy(walkStates, function (ws) {\n      return _.isNumber(ws.priority) ? ws.priority : Number.MAX_VALUE;\n    });\n    wsToUse = _.find(walkStates, function (ws) {\n      return _.isEmpty(ws.components);\n    });\n    console.log(\"resolved \", tokenPath, 'to', walkStates);\n    if (!wsToUse && walkStates.length > 1 && !includeAutoComplete) {\n      console.info(\"more then one context active for current path, but autocomplete isn't requested\", walkStates);\n    }\n    if (!wsToUse) {\n      wsToUse = walkStates[0];\n    }\n\n    console.log(\"resolved \", tokenPath, 'to', wsToUse, 'options were', walkStates);\n\n    _.each(wsToUse.contextExtensionList, function (extension) {\n      _.assign(context, extension);\n    });\n  }\n}",null]}