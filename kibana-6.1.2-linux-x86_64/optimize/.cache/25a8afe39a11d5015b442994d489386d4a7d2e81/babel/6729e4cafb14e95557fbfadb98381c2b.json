{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/angular-bootstrap/modal/modal.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/angular-bootstrap/modal/modal.js","mtime":1515552034000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])\n\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n.factory('$$stackedMap', function () {\n  return {\n    createNew: function createNew() {\n      var stack = [];\n\n      return {\n        add: function add(key, value) {\n          stack.push({\n            key: key,\n            value: value\n          });\n        },\n        get: function get(key) {\n          for (var i = 0; i < stack.length; i++) {\n            if (key == stack[i].key) {\n              return stack[i];\n            }\n          }\n        },\n        keys: function keys() {\n          var keys = [];\n          for (var i = 0; i < stack.length; i++) {\n            keys.push(stack[i].key);\n          }\n          return keys;\n        },\n        top: function top() {\n          return stack[stack.length - 1];\n        },\n        remove: function remove(key) {\n          var idx = -1;\n          for (var i = 0; i < stack.length; i++) {\n            if (key == stack[i].key) {\n              idx = i;\n              break;\n            }\n          }\n          return stack.splice(idx, 1)[0];\n        },\n        removeTop: function removeTop() {\n          return stack.splice(stack.length - 1, 1)[0];\n        },\n        length: function length() {\n          return stack.length;\n        }\n      };\n    }\n  };\n})\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n.directive('modalBackdrop', ['$timeout', function ($timeout) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/modal/backdrop.html',\n    link: function link(scope, element, attrs) {\n      scope.backdropClass = attrs.backdropClass || '';\n\n      scope.animate = false;\n\n      //trigger CSS transitions\n      $timeout(function () {\n        scope.animate = true;\n      });\n    }\n  };\n}]).directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {\n  return {\n    restrict: 'EA',\n    scope: {\n      index: '@',\n      animate: '='\n    },\n    replace: true,\n    transclude: true,\n    templateUrl: function templateUrl(tElement, tAttrs) {\n      return tAttrs.templateUrl || 'template/modal/window.html';\n    },\n    link: function link(scope, element, attrs) {\n      element.addClass(attrs.windowClass || '');\n      scope.size = attrs.size;\n\n      $timeout(function () {\n        // trigger CSS transitions\n        scope.animate = true;\n\n        /**\n         * Auto-focusing of a freshly-opened modal element causes any child elements\n         * with the autofocus attribute to lose focus. This is an issue on touch\n         * based devices which will show and then hide the onscreen keyboard.\n         * Attempts to refocus the autofocus element via JavaScript will not reopen\n         * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n         * the modal element if the modal does not contain an autofocus element.\n         */\n        if (!element[0].querySelectorAll('[autofocus]').length) {\n          element[0].focus();\n        }\n      });\n\n      scope.close = function (evt) {\n        var modal = $modalStack.getTop();\n        if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && evt.target === evt.currentTarget) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          $modalStack.dismiss(modal.key, 'backdrop click');\n        }\n      };\n    }\n  };\n}]).directive('modalTransclude', function () {\n  return {\n    link: function link($scope, $element, $attrs, controller, $transclude) {\n      $transclude($scope.$parent, function (clone) {\n        $element.empty();\n        $element.append(clone);\n      });\n    }\n  };\n}).factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap', function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {\n\n  var OPENED_MODAL_CLASS = 'modal-open';\n\n  var backdropDomEl, backdropScope;\n  var openedWindows = $$stackedMap.createNew();\n  var $modalStack = {};\n\n  function backdropIndex() {\n    var topBackdropIndex = -1;\n    var opened = openedWindows.keys();\n    for (var i = 0; i < opened.length; i++) {\n      if (openedWindows.get(opened[i]).value.backdrop) {\n        topBackdropIndex = i;\n      }\n    }\n    return topBackdropIndex;\n  }\n\n  $rootScope.$watch(backdropIndex, function (newBackdropIndex) {\n    if (backdropScope) {\n      backdropScope.index = newBackdropIndex;\n    }\n  });\n\n  function removeModalWindow(modalInstance) {\n\n    var body = $document.find('body').eq(0);\n    var modalWindow = openedWindows.get(modalInstance).value;\n\n    //clean up the stack\n    openedWindows.remove(modalInstance);\n\n    //remove window DOM element\n    removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function () {\n      modalWindow.modalScope.$destroy();\n      body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);\n      checkRemoveBackdrop();\n    });\n  }\n\n  function checkRemoveBackdrop() {\n    //remove backdrop if no longer needed\n    if (backdropDomEl && backdropIndex() == -1) {\n      var backdropScopeRef = backdropScope;\n      removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {\n        backdropScopeRef.$destroy();\n        backdropScopeRef = null;\n      });\n      backdropDomEl = undefined;\n      backdropScope = undefined;\n    }\n  }\n\n  function removeAfterAnimate(domEl, scope, emulateTime, done) {\n    // Closing animation\n    scope.animate = false;\n\n    var transitionEndEventName = $transition.transitionEndEventName;\n    if (transitionEndEventName) {\n      // transition out\n      var timeout = $timeout(afterAnimating, emulateTime);\n\n      domEl.bind(transitionEndEventName, function () {\n        $timeout.cancel(timeout);\n        afterAnimating();\n        scope.$apply();\n      });\n    } else {\n      // Ensure this call is async\n      $timeout(afterAnimating);\n    }\n\n    function afterAnimating() {\n      if (afterAnimating.done) {\n        return;\n      }\n      afterAnimating.done = true;\n\n      domEl.remove();\n      if (done) {\n        done();\n      }\n    }\n  }\n\n  $document.bind('keydown', function (evt) {\n    var modal;\n\n    if (evt.which === 27) {\n      modal = openedWindows.top();\n      if (modal && modal.value.keyboard) {\n        evt.preventDefault();\n        $rootScope.$apply(function () {\n          $modalStack.dismiss(modal.key, 'escape key press');\n        });\n      }\n    }\n  });\n\n  $modalStack.open = function (modalInstance, modal) {\n\n    openedWindows.add(modalInstance, {\n      deferred: modal.deferred,\n      modalScope: modal.scope,\n      backdrop: modal.backdrop,\n      keyboard: modal.keyboard\n    });\n\n    var body = $document.find('body').eq(0),\n        currBackdropIndex = backdropIndex();\n\n    if (currBackdropIndex >= 0 && !backdropDomEl) {\n      backdropScope = $rootScope.$new(true);\n      backdropScope.index = currBackdropIndex;\n      var angularBackgroundDomEl = angular.element('<div modal-backdrop></div>');\n      angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n      backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n      body.append(backdropDomEl);\n    }\n\n    var angularDomEl = angular.element('<div modal-window></div>');\n    angularDomEl.attr({\n      'template-url': modal.windowTemplateUrl,\n      'window-class': modal.windowClass,\n      'size': modal.size,\n      'index': openedWindows.length() - 1,\n      'animate': 'animate'\n    }).html(modal.content);\n\n    var modalDomEl = $compile(angularDomEl)(modal.scope);\n    openedWindows.top().value.modalDomEl = modalDomEl;\n    body.append(modalDomEl);\n    body.addClass(OPENED_MODAL_CLASS);\n  };\n\n  $modalStack.close = function (modalInstance, result) {\n    var modalWindow = openedWindows.get(modalInstance);\n    if (modalWindow) {\n      modalWindow.value.deferred.resolve(result);\n      removeModalWindow(modalInstance);\n    }\n  };\n\n  $modalStack.dismiss = function (modalInstance, reason) {\n    var modalWindow = openedWindows.get(modalInstance);\n    if (modalWindow) {\n      modalWindow.value.deferred.reject(reason);\n      removeModalWindow(modalInstance);\n    }\n  };\n\n  $modalStack.dismissAll = function (reason) {\n    var topModal = this.getTop();\n    while (topModal) {\n      this.dismiss(topModal.key, reason);\n      topModal = this.getTop();\n    }\n  };\n\n  $modalStack.getTop = function () {\n    return openedWindows.top();\n  };\n\n  return $modalStack;\n}]).provider('$modal', function () {\n\n  var $modalProvider = {\n    options: {\n      backdrop: true, //can be also false or 'static'\n      keyboard: true\n    },\n    $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack', function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {\n\n      var $modal = {};\n\n      function getTemplatePromise(options) {\n        return options.template ? $q.when(options.template) : $http.get(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl, { cache: $templateCache }).then(function (result) {\n          return result.data;\n        });\n      }\n\n      function getResolvePromises(resolves) {\n        var promisesArr = [];\n        angular.forEach(resolves, function (value) {\n          if (angular.isFunction(value) || angular.isArray(value)) {\n            promisesArr.push($q.when($injector.invoke(value)));\n          }\n        });\n        return promisesArr;\n      }\n\n      $modal.open = function (modalOptions) {\n\n        var modalResultDeferred = $q.defer();\n        var modalOpenedDeferred = $q.defer();\n\n        //prepare an instance of a modal to be injected into controllers and returned to a caller\n        var modalInstance = {\n          result: modalResultDeferred.promise,\n          opened: modalOpenedDeferred.promise,\n          close: function close(result) {\n            $modalStack.close(modalInstance, result);\n          },\n          dismiss: function dismiss(reason) {\n            $modalStack.dismiss(modalInstance, reason);\n          }\n        };\n\n        //merge and clean up options\n        modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n        modalOptions.resolve = modalOptions.resolve || {};\n\n        //verify options\n        if (!modalOptions.template && !modalOptions.templateUrl) {\n          throw new Error('One of template or templateUrl options is required.');\n        }\n\n        var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n        templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {\n\n          var modalScope = (modalOptions.scope || $rootScope).$new();\n          modalScope.$close = modalInstance.close;\n          modalScope.$dismiss = modalInstance.dismiss;\n\n          var ctrlInstance,\n              ctrlLocals = {};\n          var resolveIter = 1;\n\n          //controllers\n          if (modalOptions.controller) {\n            ctrlLocals.$scope = modalScope;\n            ctrlLocals.$modalInstance = modalInstance;\n            angular.forEach(modalOptions.resolve, function (value, key) {\n              ctrlLocals[key] = tplAndVars[resolveIter++];\n            });\n\n            ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n            if (modalOptions.controllerAs) {\n              modalScope[modalOptions.controllerAs] = ctrlInstance;\n            }\n          }\n\n          $modalStack.open(modalInstance, {\n            scope: modalScope,\n            deferred: modalResultDeferred,\n            content: tplAndVars[0],\n            backdrop: modalOptions.backdrop,\n            keyboard: modalOptions.keyboard,\n            backdropClass: modalOptions.backdropClass,\n            windowClass: modalOptions.windowClass,\n            windowTemplateUrl: modalOptions.windowTemplateUrl,\n            size: modalOptions.size\n          });\n        }, function resolveError(reason) {\n          modalResultDeferred.reject(reason);\n        });\n\n        templateAndResolvePromise.then(function () {\n          modalOpenedDeferred.resolve(true);\n        }, function () {\n          modalOpenedDeferred.reject(false);\n        });\n\n        return modalInstance;\n      };\n\n      return $modal;\n    }]\n  };\n\n  return $modalProvider;\n});",null]}