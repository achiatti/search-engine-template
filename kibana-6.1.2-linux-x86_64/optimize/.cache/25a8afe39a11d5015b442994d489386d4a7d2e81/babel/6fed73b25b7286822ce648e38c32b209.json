{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/ui_framework/src/components/context_menu/context_menu_panel.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/ui_framework/src/components/context_menu/context_menu_panel.js","mtime":1515552213907},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KuiContextMenuPanel = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _tabbable = require('tabbable');\n\nvar _tabbable2 = _interopRequireDefault(_tabbable);\n\nvar _components = require('../../components');\n\nvar _services = require('../../services');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];\n  }return target;\n}\n\nvar transitionDirectionAndTypeToClassNameMap = {\n  next: {\n    in: 'kuiContextMenuPanel-txInLeft',\n    out: 'kuiContextMenuPanel-txOutLeft'\n  },\n  previous: {\n    in: 'kuiContextMenuPanel-txInRight',\n    out: 'kuiContextMenuPanel-txOutRight'\n  }\n};\n\nvar KuiContextMenuPanel = function (_react$Component) {\n  _inherits(KuiContextMenuPanel, _react$Component);\n\n  function KuiContextMenuPanel(props) {\n    _classCallCheck(this, KuiContextMenuPanel);\n\n    var _this = _possibleConstructorReturn(this, (KuiContextMenuPanel.__proto__ || Object.getPrototypeOf(KuiContextMenuPanel)).call(this, props));\n\n    _this.incrementFocusedItemIndex = function (amount) {\n      var nextFocusedItemIndex = void 0;\n\n      if (_this.state.focusedItemIndex === undefined) {\n        // If this is the beginning of the user's keyboard navigation of the menu, then we'll focus\n        // either the first or last item.\n        nextFocusedItemIndex = amount < 0 ? _this.menuItems.length - 1 : 0;\n      } else {\n        nextFocusedItemIndex = _this.state.focusedItemIndex + amount;\n\n        if (nextFocusedItemIndex < 0) {\n          nextFocusedItemIndex = _this.menuItems.length - 1;\n        } else if (nextFocusedItemIndex === _this.menuItems.length) {\n          nextFocusedItemIndex = 0;\n        }\n      }\n\n      _this.setState({\n        focusedItemIndex: nextFocusedItemIndex\n      });\n    };\n\n    _this.onKeyDown = function (e) {\n      // If this panel contains items you can use the left arrow key to go back at any time.\n      // But if it doesn't contain items, then you have to focus on the back button specifically,\n      // since there could be content inside the panel which requires use of the left arrow key,\n      // e.g. text inputs.\n      if (_this.props.items.length || document.activeElement === _this.backButton || document.activeElement === _this.panel) {\n        if (e.keyCode === _services.cascadingMenuKeyCodes.LEFT) {\n          if (_this.props.showPreviousPanel) {\n            _this.props.showPreviousPanel();\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n          }\n        }\n      }\n\n      if (_this.props.items.length) {\n        switch (e.keyCode) {\n          case _services.cascadingMenuKeyCodes.TAB:\n            // We need to sync up with the user if s/he is tabbing through the items.\n            var focusedItemIndex = _this.menuItems.indexOf(document.activeElement);\n\n            _this.setState({\n              focusedItemIndex: focusedItemIndex >= 0 && focusedItemIndex < _this.menuItems.length ? focusedItemIndex : undefined\n            });\n            break;\n\n          case _services.cascadingMenuKeyCodes.UP:\n            e.preventDefault();\n            _this.incrementFocusedItemIndex(-1);\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n            break;\n\n          case _services.cascadingMenuKeyCodes.DOWN:\n            e.preventDefault();\n            _this.incrementFocusedItemIndex(1);\n\n            if (_this.props.onUseKeyboardToNavigate) {\n              _this.props.onUseKeyboardToNavigate();\n            }\n            break;\n\n          case _services.cascadingMenuKeyCodes.RIGHT:\n            if (_this.props.showNextPanel) {\n              e.preventDefault();\n              _this.props.showNextPanel(_this.state.focusedItemIndex);\n\n              if (_this.props.onUseKeyboardToNavigate) {\n                _this.props.onUseKeyboardToNavigate();\n              }\n            }\n            break;\n\n          default:\n            break;\n        }\n      }\n    };\n\n    _this.onTransitionComplete = function () {\n      _this.setState({\n        isTransitioning: false\n      });\n\n      if (_this.props.onTransitionComplete) {\n        _this.props.onTransitionComplete();\n      }\n    };\n\n    _this.menuItemRef = function (index, node) {\n      // There's a weird bug where if you navigate to a panel without items, then this callback\n      // is still invoked, so we have to do a truthiness check.\n      if (node) {\n        // Store all menu items.\n        _this.menuItems[index] = node;\n      }\n    };\n\n    _this.panelRef = function (node) {\n      _this.panel = node;\n\n      if (_this.panel) {\n        if (_this.props.onHeightChange) {\n          _this.props.onHeightChange(_this.panel.clientHeight);\n        }\n      }\n    };\n\n    _this.contentRef = function (node) {\n      _this.content = node;\n    };\n\n    _this.menuItems = [];\n    _this.state = {\n      isTransitioning: Boolean(props.transitionType),\n      focusedItemIndex: props.initialFocusedItemIndex\n    };\n    return _this;\n  }\n\n  _createClass(KuiContextMenuPanel, [{\n    key: 'updateFocus',\n    value: function updateFocus() {\n      // If this panel has lost focus, then none of its content should be focused.\n      if (!this.props.hasFocus) {\n        if (this.panel.contains(document.activeElement)) {\n          document.activeElement.blur();\n        }\n        return;\n      }\n\n      // Setting focus while transitioning causes the animation to glitch, so we have to wait\n      // until it's finished before we focus anything.\n      if (this.state.isTransitioning) {\n        return;\n      }\n\n      // If there aren't any items then this is probably a form or something.\n      if (!this.menuItems.length) {\n        // If we've already focused on something inside the panel, everything's fine.\n        if (this.panel.contains(document.activeElement)) {\n          return;\n        }\n\n        // Otherwise let's focus the first tabbable item and expedite input from the user.\n        if (this.content) {\n          var tabbableItems = (0, _tabbable2.default)(this.content);\n          if (tabbableItems.length) {\n            tabbableItems[0].focus();\n          }\n        }\n        return;\n      }\n\n      // If an item is focused, focus it.\n      if (this.state.focusedItemIndex !== undefined) {\n        this.menuItems[this.state.focusedItemIndex].focus();\n        return;\n      }\n\n      // Focus on the panel as a last resort.\n      if (!this.panel.contains(document.activeElement)) {\n        this.panel.focus();\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.updateFocus();\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      // Clear refs to menuItems if we're getting new ones.\n      if (nextProps.items !== this.props.items) {\n        this.menuItems = [];\n      }\n\n      if (nextProps.transitionType) {\n        this.setState({\n          isTransitioning: true\n        });\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.updateFocus();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props;\n\n      var children = _props.children,\n          className = _props.className,\n          onClose = _props.onClose,\n          title = _props.title,\n          onHeightChange = _props.onHeightChange,\n          transitionType = _props.transitionType,\n          transitionDirection = _props.transitionDirection,\n          onTransitionComplete = _props.onTransitionComplete,\n          onUseKeyboardToNavigate = _props.onUseKeyboardToNavigate,\n          hasFocus = _props.hasFocus,\n          items = _props.items,\n          initialFocusedItemIndex = _props.initialFocusedItemIndex,\n          showNextPanel = _props.showNextPanel,\n          showPreviousPanel = _props.showPreviousPanel,\n          rest = _objectWithoutProperties(_props, ['children', 'className', 'onClose', 'title', 'onHeightChange', 'transitionType', 'transitionDirection', 'onTransitionComplete', 'onUseKeyboardToNavigate', 'hasFocus', 'items', 'initialFocusedItemIndex', 'showNextPanel', 'showPreviousPanel']);\n\n      var panelTitle = void 0;\n\n      if (title) {\n        if (Boolean(onClose)) {\n          panelTitle = _react2.default.createElement('button', {\n            className: 'kuiContextMenuPanelTitle',\n            onClick: onClose,\n            ref: function ref(node) {\n              _this2.backButton = node;\n            },\n            'data-test-subj': 'contextMenuPanelTitleButton'\n          }, _react2.default.createElement('span', { className: 'kuiContextMenu__itemLayout' }, _react2.default.createElement('span', { className: 'kuiContextMenu__icon kuiIcon fa-angle-left' }), _react2.default.createElement('span', { className: 'kuiContextMenu__text' }, title)));\n        } else {\n          panelTitle = _react2.default.createElement(_components.KuiPopoverTitle, null, _react2.default.createElement('span', { className: 'kuiContextMenu__itemLayout' }, title));\n        }\n      }\n\n      var classes = (0, _classnames2.default)('kuiContextMenuPanel', className, this.state.isTransitioning && transitionDirectionAndTypeToClassNameMap[transitionDirection] ? transitionDirectionAndTypeToClassNameMap[transitionDirection][transitionType] : undefined);\n\n      var content = items.length ? items.map(function (MenuItem, index) {\n        return (0, _react.cloneElement)(MenuItem, {\n          buttonRef: _this2.menuItemRef.bind(_this2, index)\n        });\n      }) : children;\n\n      return _react2.default.createElement('div', _extends({\n        ref: this.panelRef,\n        className: classes,\n        onKeyDown: this.onKeyDown,\n        tabIndex: '0',\n        onAnimationEnd: this.onTransitionComplete\n      }, rest), panelTitle, _react2.default.createElement('div', { ref: this.contentRef }, content));\n    }\n  }]);\n\n  return KuiContextMenuPanel;\n}(_react.Component);\n\nexports.KuiContextMenuPanel = KuiContextMenuPanel;\nKuiContextMenuPanel.propTypes = {\n  children: _propTypes2.default.node,\n  className: _propTypes2.default.string,\n  title: _propTypes2.default.string,\n  onClose: _propTypes2.default.func,\n  onHeightChange: _propTypes2.default.func,\n  transitionType: _propTypes2.default.oneOf(['in', 'out']),\n  transitionDirection: _propTypes2.default.oneOf(['next', 'previous']),\n  onTransitionComplete: _propTypes2.default.func,\n  onUseKeyboardToNavigate: _propTypes2.default.func,\n  hasFocus: _propTypes2.default.bool,\n  items: _propTypes2.default.array,\n  showNextPanel: _propTypes2.default.func,\n  showPreviousPanel: _propTypes2.default.func,\n  initialFocusedItemIndex: _propTypes2.default.number\n};\nKuiContextMenuPanel.defaultProps = {\n  hasFocus: true,\n  items: []\n};",null]}