{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/ui_framework/src/components/accessibility/keyboard_accessible.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/ui_framework/src/components/accessibility/keyboard_accessible.js","mtime":1515552213011},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KuiKeyboardAccessible = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n}; /**\n    * Interactive elements must be able to receive focus.\n    *\n    * Ideally, this means using elements that are natively keyboard accessible (<a href=\"\">,\n    * <input type=\"button\">, or <button>). Note that links should be used when navigating and buttons\n    * should be used when performing an action on the page.\n    *\n    * If, however, you need to use elements that aren't natively keyboard accessible (for example, <div>,\n    * <p>, or <a> without the href attribute), then you need to allow them to receive focus and to\n    * respond to keyboard input. The workaround is to:\n    *\n    *   - Give the element tabindex=\"0\" so that it can receive keyboard focus.\n    *   - Add a JavaScript onkeyup event handler that triggers element functionality if the Enter key\n    *     is pressed while the element is focused. This is necessary because some browsers do not trigger\n    *    onclick events for such elements when activated via the keyboard.\n    *   - If the item is meant to function as a button, the onkeyup event handler should also detect the\n    *     Spacebar in addition to the Enter key, and the element should be given role=\"button\".\n    *\n    * Wrap any such elements that aren't natively keyboard accessible in this component to automatically\n    * apply the above workaround to them.\n    */\n\nvar _react = require('react');\n\nvar _services = require('../../services');\n\nvar KuiKeyboardAccessible = function (_react$Component) {\n  _inherits(KuiKeyboardAccessible, _react$Component);\n\n  function KuiKeyboardAccessible() {\n    var _ref;\n\n    var _this, _ret;\n\n    _classCallCheck(this, KuiKeyboardAccessible);\n\n    var _temp;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = KuiKeyboardAccessible.__proto__ || Object.getPrototypeOf(KuiKeyboardAccessible)).call.apply(_ref, [this].concat(args))), _this), _this.onKeyDown = function (e) {\n      // Prevent a scroll from occurring if the user has hit space.\n      if (e.keyCode === _services.keyCodes.SPACE) {\n        e.preventDefault();\n      }\n    }, _this.onKeyUp = function (e) {\n      // Support keyboard accessibility by emulating mouse click on ENTER or SPACE keypress.\n      if (e.keyCode === _services.keyCodes.ENTER || e.keyCode === _services.keyCodes.SPACE) {\n        // Delegate to the click handler on the element.\n        _this.props.children.props.onClick(e);\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(KuiKeyboardAccessible, [{\n    key: 'applyKeyboardAccessibility',\n    value: function applyKeyboardAccessibility(child) {\n      // Add attributes required for accessibility unless they are already specified.\n      var props = _extends({\n        tabIndex: '0',\n        role: 'button'\n      }, child.props, {\n        onKeyDown: this.onKeyDown,\n        onKeyUp: this.onKeyUp\n      });\n\n      return (0, _react.cloneElement)(child, props);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return this.applyKeyboardAccessibility(this.props.children);\n    }\n  }]);\n\n  return KuiKeyboardAccessible;\n}(_react.Component);\n\nexports.KuiKeyboardAccessible = KuiKeyboardAccessible;\nvar keyboardInaccessibleElement = function keyboardInaccessibleElement(props, propName, componentName) {\n  var child = props.children;\n\n  if (!child) {\n    throw new Error(componentName + ' needs to wrap an element with which the user interacts.');\n  }\n\n  // The whole point of this component is to hack in functionality that native buttons provide\n  // by default.\n  if (child.type === 'button') {\n    throw new Error(componentName + ' doesn\\'t need to be used on a button.');\n  }\n\n  if (child.type === 'a' && child.props.href !== undefined) {\n    throw new Error(componentName + ' doesn\\'t need to be used on a link if it has a href attribute.');\n  }\n\n  // We're emulating a click action, so we should already have a regular click handler defined.\n  if (!child.props.onClick) {\n    throw new Error(componentName + ' needs to wrap an element which has an onClick prop assigned.');\n  }\n\n  if (typeof child.props.onClick !== 'function') {\n    throw new Error(componentName + '\\'s child\\'s onClick prop needs to be a function.');\n  }\n\n  if (child.props.onKeyDown) {\n    throw new Error(componentName + '\\'s child can\\'t have an onKeyDown prop because the implementation will override it.');\n  }\n\n  if (child.props.onKeyUp) {\n    throw new Error(componentName + '\\'s child can\\'t have an onKeyUp prop because the implementation will override it.');\n  }\n};\n\nKuiKeyboardAccessible.propTypes = {\n  children: keyboardInaccessibleElement\n};",null]}