{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/decode_geo_hash.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/utils/decode_geo_hash.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeGeoHash = decodeGeoHash;\nexports.geohashColumns = geohashColumns;\n/*\n * Decodes geohash to object containing\n * top-left and bottom-right corners of\n * rectangle and center point.\n *\n * geohash.js\n * Geohash library for Javascript\n * (c) 2008 David Troy\n * Distributed under the MIT License\n *\n * @method refine_interval\n * @param interval {Array} [long, lat]\n * @param cd {Number}\n * @param mask {Number}\n * @return {Object} interval\n */\nfunction decodeGeoHash(geohash) {\n  var BITS = [16, 8, 4, 2, 1];\n  var BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';\n  var is_even = 1;\n  var lat = [];\n  var lon = [];\n  lat[0] = -90.0;\n  lat[1] = 90.0;\n  lon[0] = -180.0;\n  lon[1] = 180.0;\n  var lat_err = 90.0;\n  var lon_err = 180.0;\n  for (var i = 0; i < geohash.length; i++) {\n    var c = geohash[i];\n    var cd = BASE32.indexOf(c);\n    for (var j = 0; j < 5; j++) {\n      var mask = BITS[j];\n      if (is_even) {\n        lon_err /= 2;\n        refine_interval(lon, cd, mask);\n      } else {\n        lat_err /= 2;\n        refine_interval(lat, cd, mask);\n      }\n      is_even = !is_even;\n    }\n  }\n  lat[2] = (lat[0] + lat[1]) / 2;\n  lon[2] = (lon[0] + lon[1]) / 2;\n  return { latitude: lat, longitude: lon };\n}\n\nfunction refine_interval(interval, cd, mask) {\n  if (cd & mask) {\n    interval[0] = (interval[0] + interval[1]) / 2;\n  } else {\n    interval[1] = (interval[0] + interval[1]) / 2;\n  }\n}\n\n/**\n * Get the number of geohash cells for a given precision\n *\n * @param {number} precision the geohash precision (1<=precision<=12).\n * @param {number} axis constant for the axis 0=lengthwise (ie. columns, along longitude), 1=heightwise (ie. rows, along latitude).\n * @returns {number} Number of geohash cells (rows or columns) at that precision\n */\nfunction geohashCells(precision, axis) {\n  var cells = 1;\n  for (var i = 1; i <= precision; i += 1) {\n    //On odd precisions, rows divide by 4 and columns by 8. Vice-versa on even precisions.\n    cells *= i % 2 === axis ? 4 : 8;\n  }\n  return cells;\n}\n\n/**\n * Get the number of geohash columns (world-wide) for a given precision\n * @param precision the geohash precision\n * @returns {number} the number of columns\n */\nfunction geohashColumns(precision) {\n  return geohashCells(precision, 0);\n}",null]}