{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/filter_manager/lib/range.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/filter_manager/lib/range.js","mtime":1515552036000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.buildRangeFilter = buildRangeFilter;\nexports.getRangeScript = getRangeScript;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OPERANDS_IN_RANGE = 2;\n\nfunction buildRangeFilter(field, params, indexPattern, formattedValue) {\n  var filter = { meta: { index: indexPattern.id } };\n  if (formattedValue) filter.meta.formattedValue = formattedValue;\n\n  params = _lodash2.default.mapValues(params, function (value) {\n    return field.type === 'number' ? parseFloat(value) : value;\n  });\n\n  if ('gte' in params && 'gt' in params) throw new Error('gte and gt are mutually exclusive');\n  if ('lte' in params && 'lt' in params) throw new Error('lte and lt are mutually exclusive');\n\n  var totalInfinite = ['gt', 'lt'].reduce(function (totalInfinite, op) {\n    var key = op in params ? op : op + 'e';\n    var isInfinite = Math.abs(params[key]) === Infinity;\n\n    if (isInfinite) {\n      totalInfinite++;\n      delete params[key];\n    }\n\n    return totalInfinite;\n  }, 0);\n\n  if (totalInfinite === OPERANDS_IN_RANGE) {\n    filter.match_all = {};\n    filter.meta.field = field.name;\n  } else if (field.scripted) {\n    filter.script = getRangeScript(field, params);\n    filter.meta.field = field.name;\n  } else {\n    filter.range = {};\n    filter.range[field.name] = params;\n  }\n\n  return filter;\n}\n\nfunction getRangeScript(field, params) {\n  var operators = {\n    gt: '>',\n    gte: '>=',\n    lte: '<=',\n    lt: '<'\n  };\n  var comparators = {\n    gt: 'boolean gt(Supplier s, def v) {return s.get() > v}',\n    gte: 'boolean gte(Supplier s, def v) {return s.get() >= v}',\n    lte: 'boolean lte(Supplier s, def v) {return s.get() <= v}',\n    lt: 'boolean lt(Supplier s, def v) {return s.get() < v}'\n  };\n\n  var knownParams = _lodash2.default.pick(params, function (val, key) {\n    return key in operators;\n  });\n  var script = _lodash2.default.map(knownParams, function (val, key) {\n    return '(' + field.script + ')' + operators[key] + key;\n  }).join(' && ');\n\n  // We must wrap painless scripts in a lambda in case they're more than a simple expression\n  if (field.lang === 'painless') {\n    var currentComparators = _lodash2.default.reduce(knownParams, function (acc, val, key) {\n      return acc.concat(comparators[key]);\n    }, []).join(' ');\n\n    var comparisons = _lodash2.default.map(knownParams, function (val, key) {\n      return key + '(() -> { ' + field.script + ' }, params.' + key + ')';\n    }).join(' && ');\n\n    script = '' + currentComparators + comparisons;\n  }\n\n  var value = _lodash2.default.map(knownParams, function (val, key) {\n    return operators[key] + field.format.convert(val);\n  }).join(' ');\n\n  return {\n    script: {\n      inline: script,\n      params: _extends({}, knownParams, {\n        value: value\n      }),\n      lang: field.lang\n    }\n  };\n}",null]}