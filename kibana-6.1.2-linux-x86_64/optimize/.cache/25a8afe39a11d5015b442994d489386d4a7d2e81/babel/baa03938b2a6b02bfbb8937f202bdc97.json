{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/routes/route_setup_manager.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/routes/route_setup_manager.js","mtime":1515552037000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouteSetupManager = exports.WAIT_FOR_URL_CHANGE_TOKEN = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Throw this inside of an Angular route resolver after calling `kbnUrl.change`\n// so that the $router can observe the $location update. Otherwise, the location\n// route setup work will resovle before the route update occurs.\nvar WAIT_FOR_URL_CHANGE_TOKEN = exports.WAIT_FOR_URL_CHANGE_TOKEN = new Error('WAIT_FOR_URL_CHANGE_TOKEN');\n\nvar RouteSetupManager = exports.RouteSetupManager = function () {\n  function RouteSetupManager() {\n    _classCallCheck(this, RouteSetupManager);\n\n    this.setupWork = [];\n    this.onSetupComplete = [];\n    this.onSetupError = [];\n    this.onWorkComplete = [];\n    this.onWorkError = [];\n  }\n\n  _createClass(RouteSetupManager, [{\n    key: 'addSetupWork',\n    value: function addSetupWork(fn) {\n      this.setupWork.push(fn);\n    }\n  }, {\n    key: 'afterSetupWork',\n    value: function afterSetupWork(onComplete, onError) {\n      this.onSetupComplete.push(onComplete);\n      this.onSetupError.push(onError);\n    }\n  }, {\n    key: 'afterWork',\n    value: function afterWork(onComplete, onError) {\n      this.onWorkComplete.push(onComplete);\n      this.onWorkError.push(onError);\n    }\n\n    /**\n     * Do each setupWork function by injecting it with angular dependencies\n     * and accepting promises from it.\n     * @return {[type]} [description]\n     */\n\n  }, {\n    key: 'doWork',\n    value: function doWork(Promise, $injector, userWork) {\n      var _this = this;\n\n      var invokeEach = function invokeEach(arr, locals) {\n        return Promise.map(arr, function (fn) {\n          if (!fn) return;\n          return $injector.invoke(fn, null, locals);\n        });\n      };\n\n      // call each error handler in order, until one of them resolves\n      // or we run out of handlers\n      var callErrorHandlers = function callErrorHandlers(handlers, origError) {\n        if (!_lodash2.default.size(handlers)) throw origError;\n\n        // clone so we don't discard handlers or loose them\n        handlers = handlers.slice(0);\n\n        var next = function next(err) {\n          if (!handlers.length) throw err;\n\n          var handler = handlers.shift();\n          if (!handler) return next(err);\n\n          return Promise.try(function () {\n            return $injector.invoke(handler, null, { err: err });\n          }).catch(next);\n        };\n\n        return next(origError);\n      };\n\n      return invokeEach(this.setupWork).then(function () {\n        return invokeEach(_this.onSetupComplete);\n      }, function (err) {\n        return callErrorHandlers(_this.onSetupError, err);\n      }).then(function () {\n        // wait for the queue to fill up, then do all the work\n        var defer = Promise.defer();\n        userWork.resolveWhenFull(defer);\n\n        return defer.promise.then(function () {\n          return Promise.all(userWork.doWork());\n        });\n      }).catch(function (error) {\n        if (error === WAIT_FOR_URL_CHANGE_TOKEN) {\n          // prevent moving forward, return a promise that never resolves\n          // so that the $router can observe the $location update\n          return Promise.halt();\n        }\n\n        throw error;\n      }).then(function () {\n        return invokeEach(_this.onWorkComplete);\n      }, function (err) {\n        return callErrorHandlers(_this.onWorkError, err);\n      });\n    }\n  }]);\n\n  return RouteSetupManager;\n}();",null]}