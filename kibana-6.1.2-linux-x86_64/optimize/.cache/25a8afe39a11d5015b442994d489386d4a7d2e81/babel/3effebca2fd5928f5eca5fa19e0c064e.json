{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/types/point_series.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/types/point_series.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.VislibTypesPointSeries = VislibTypesPointSeries;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction VislibTypesPointSeries() {\n\n  var createSerieFromParams = function createSerieFromParams(cfg, seri) {\n    var matchingSeriesParams = cfg.seriesParams ? cfg.seriesParams.find(function (seriConfig) {\n      return seri.aggId === seriConfig.data.id;\n    }) : null;\n\n    var interpolate = cfg.smoothLines ? 'cardinal' : cfg.interpolate;\n\n    if (!matchingSeriesParams) {\n      var stacked = ['stacked', 'percentage', 'wiggle', 'silhouette'].includes(cfg.mode);\n      return {\n        show: true,\n        type: cfg.type || 'line',\n        mode: stacked ? 'stacked' : 'normal',\n        interpolate: interpolate,\n        drawLinesBetweenPoints: cfg.drawLinesBetweenPoints,\n        showCircles: cfg.showCircles,\n        radiusRatio: cfg.radiusRatio,\n        data: seri\n      };\n    }\n\n    return _extends({}, matchingSeriesParams, {\n      data: seri\n    });\n  };\n\n  var createSeries = function createSeries(cfg, series) {\n    return {\n      type: 'point_series',\n      addTimeMarker: cfg.addTimeMarker,\n      series: _lodash2.default.map(series, function (seri) {\n        return createSerieFromParams(cfg, seri);\n      })\n    };\n  };\n\n  var createCharts = function createCharts(cfg, data) {\n    if (data.rows || data.columns) {\n      var charts = data.rows ? data.rows : data.columns;\n      return charts.map(function (chart) {\n        return createSeries(cfg, chart.series);\n      });\n    }\n\n    return [createSeries(cfg, data.series)];\n  };\n  /*\n   * Create handlers for Area, Column, and Line charts which\n   * are all nearly the same minus a few details\n   */\n  function create(opts) {\n    opts = opts || {};\n\n    return function (cfg, data) {\n      var isUserDefinedYAxis = cfg.setYExtents;\n      var config = _lodash2.default.cloneDeep(cfg);\n      _lodash2.default.defaultsDeep(config, {\n        chartTitle: {},\n        mode: 'normal'\n      }, opts);\n\n      config.type = 'point_series';\n\n      if (!config.tooltip) {\n        config.tooltip = {\n          show: cfg.addTooltip\n        };\n      }\n\n      if (!config.valueAxes) {\n        var mode = config.mode;\n        if (['stacked', 'overlap'].includes(mode)) mode = 'normal';\n        config.valueAxes = [{\n          id: 'ValueAxis-1',\n          type: 'value',\n          scale: {\n            type: config.scale,\n            setYExtents: config.setYExtents,\n            defaultYExtents: config.defaultYExtents,\n            min: isUserDefinedYAxis ? config.yAxis.min : undefined,\n            max: isUserDefinedYAxis ? config.yAxis.max : undefined,\n            mode: mode\n          },\n          labels: {\n            axisFormatter: data.data.yAxisFormatter || data.get('yAxisFormatter')\n          },\n          title: {\n            text: data.get('yAxisLabel')\n          }\n        }];\n      } else {\n        config.valueAxes.forEach(function (axis) {\n          if (axis.labels) {\n            axis.labels.axisFormatter = data.data.yAxisFormatter || data.get('yAxisFormatter');\n          }\n        });\n      }\n\n      if (!config.categoryAxes) {\n        config.categoryAxes = [{\n          id: 'CategoryAxis-1',\n          type: 'category',\n          labels: {\n            axisFormatter: data.data.xAxisFormatter || data.get('xAxisFormatter')\n          },\n          scale: {\n            expandLastBucket: opts.expandLastBucket\n          },\n          title: {\n            text: data.get('xAxisLabel')\n          }\n        }];\n      } else {\n        var categoryAxis1 = config.categoryAxes.find(function (categoryAxis) {\n          return categoryAxis.id === 'CategoryAxis-1';\n        });\n        if (categoryAxis1) {\n          categoryAxis1.title.text = data.get('xAxisLabel');\n        }\n      }\n\n      if (!config.charts) {\n        config.charts = createCharts(cfg, data.data);\n      }\n\n      if (typeof config.enableHover === 'undefined') config.enableHover = true;\n\n      return config;\n    };\n  }\n\n  return {\n    line: create(),\n\n    column: create({\n      expandLastBucket: true\n    }),\n\n    area: create({\n      alerts: [{\n        type: 'warning',\n        msg: 'Positive and negative values are not accurately represented by stacked ' + 'area charts. Either changing the chart mode to \"overlap\" or using a ' + 'bar chart is recommended.',\n        test: function test(vis, data) {\n          if (!data.shouldBeStacked() || data.maxNumberOfSeries() < 2) return;\n\n          var hasPos = data.getYMax(data._getY) > 0;\n          var hasNeg = data.getYMin(data._getY) < 0;\n          return hasPos && hasNeg;\n        }\n      }, {\n        type: 'warning',\n        msg: 'Parts of or the entire area chart might not be displayed due to null ' + 'values in the data. A line chart is recommended when displaying data ' + 'with null values.',\n        test: function test(vis, data) {\n          return data.hasNullValues();\n        }\n      }]\n    }),\n\n    heatmap: function heatmap(cfg, data) {\n      var defaults = create()(cfg, data);\n      var seriesLimit = 25;\n      var hasCharts = defaults.charts.length;\n      var tooManySeries = defaults.charts.length && defaults.charts[0].series.length > seriesLimit;\n      if (hasCharts && tooManySeries) {\n        defaults.error = 'There are too many series defined.';\n      }\n      defaults.valueAxes[0].show = false;\n      defaults.categoryAxes[0].style = {\n        rangePadding: 0,\n        rangeOuterPadding: 0\n      };\n      defaults.categoryAxes.push({\n        id: 'CategoryAxis-2',\n        type: 'category',\n        position: 'left',\n        values: data.getLabels(),\n        scale: {\n          inverted: true\n        },\n        labels: {\n          filter: false,\n          axisFormatter: function axisFormatter(val) {\n            return val;\n          }\n        },\n        style: {\n          rangePadding: 0,\n          rangeOuterPadding: 0\n        },\n        title: {\n          text: data.get('zAxisLabel') || ''\n        }\n      });\n      return defaults;\n    }\n  };\n}",null]}