{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/time_buckets/time_buckets.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/time_buckets/time_buckets.js","mtime":1515552038000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeBucketsProvider = TimeBucketsProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _parse_interval = require('ui/utils/parse_interval');\n\nvar _calc_auto_interval = require('ui/time_buckets/calc_auto_interval');\n\nvar _calc_es_interval = require('ui/time_buckets/calc_es_interval');\n\nvar _field_formats = require('ui/registry/field_formats');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction TimeBucketsProvider(Private, timefilter, config) {\n  var calcAuto = Private(_calc_auto_interval.TimeBucketsCalcAutoIntervalProvider);\n  var calcEsInterval = Private(_calc_es_interval.TimeBucketsCalcEsIntervalProvider);\n  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);\n  var getConfig = function getConfig() {\n    return config.get.apply(config, arguments);\n  };\n\n  function isValidMoment(m) {\n    return m && 'isValid' in m && m.isValid();\n  }\n\n  /**\n   * Helper class for wrapping the concept of an \"Interval\",\n   * which describes a timespan that will seperate moments.\n   *\n   * @param {state} object - one of \"\"\n   * @param {[type]} display [description]\n   */\n  function TimeBuckets() {\n    return TimeBuckets.__cached__(this);\n  }\n\n  /****\n   *  PUBLIC API\n   ****/\n\n  /**\n   * Set the bounds that these buckets are expected to cover.\n   * This is required to support interval \"auto\" as well\n   * as interval scaling.\n   *\n   * @param {object} input - an object with properties min and max,\n   *                       representing the edges for the time span\n   *                       we should cover\n   *\n   * @returns {undefined}\n   */\n  TimeBuckets.prototype.setBounds = function (input) {\n    if (!input) return this.clearBounds();\n\n    var bounds = void 0;\n    if (_lodash2.default.isPlainObject(input)) {\n      // accept the response from timefilter.getActiveBounds()\n      bounds = [input.min, input.max];\n    } else {\n      bounds = Array.isArray(input) ? input : [];\n    }\n\n    var moments = (0, _lodash2.default)(bounds).map(_lodash2.default.ary(_moment2.default, 1)).sortBy(Number);\n\n    var valid = moments.size() === 2 && moments.every(isValidMoment);\n    if (!valid) {\n      this.clearBounds();\n      throw new Error('invalid bounds set: ' + input);\n    }\n\n    this._lb = moments.shift();\n    this._ub = moments.pop();\n    if (this.getDuration().asSeconds() < 0) {\n      throw new TypeError('Intervals must be positive');\n    }\n  };\n\n  /**\n   * Clear the stored bounds\n   *\n   * @return {undefined}\n   */\n  TimeBuckets.prototype.clearBounds = function () {\n    this._lb = this._ub = null;\n  };\n\n  /**\n   * Check to see if we have received bounds yet\n   *\n   * @return {Boolean}\n   */\n  TimeBuckets.prototype.hasBounds = function () {\n    return isValidMoment(this._ub) && isValidMoment(this._lb);\n  };\n\n  /**\n   * Return the current bounds, if we have any.\n   *\n   * THIS DOES NOT CLONE THE BOUNDS, so editing them\n   * may have unexpected side-effects. Always\n   * call bounds.min.clone() before editing\n   *\n   * @return {object|undefined} - If bounds are not defined, this\n   *                      returns undefined, else it returns the bounds\n   *                      for these buckets. This object has two props,\n   *                      min and max. Each property will be a moment()\n   *                      object\n   *\n   */\n  TimeBuckets.prototype.getBounds = function () {\n    if (!this.hasBounds()) return;\n    return {\n      min: this._lb,\n      max: this._ub\n    };\n  };\n\n  /**\n   * Get a moment duration object representing\n   * the distance between the bounds, if the bounds\n   * are set.\n   *\n   * @return {moment.duration|undefined}\n   */\n  TimeBuckets.prototype.getDuration = function () {\n    if (!this.hasBounds()) return;\n    return _moment2.default.duration(this._ub - this._lb, 'ms');\n  };\n\n  /**\n   * Update the interval at which buckets should be\n   * generated.\n   *\n   * Input can be one of the following:\n   *  - Any object from src/ui/agg_types/buckets/_interval_options.js\n   *  - \"auto\"\n   *  - Pass a valid moment unit\n   *  - a moment.duration object.\n   *\n   * @param {object|string|moment.duration} input - see desc\n   */\n  TimeBuckets.prototype.setInterval = function (input) {\n    var interval = input;\n\n    // selection object -> val\n    if (_lodash2.default.isObject(input)) {\n      interval = input.val;\n    }\n\n    if (!interval || interval === 'auto') {\n      this._i = 'auto';\n      return;\n    }\n\n    if (_lodash2.default.isString(interval)) {\n      input = interval;\n      interval = (0, _parse_interval.parseInterval)(interval);\n      if (+interval === 0) {\n        interval = null;\n      }\n    }\n\n    // if the value wasn't converted to a duration, and isn't\n    // already a duration, we have a problem\n    if (!_moment2.default.isDuration(interval)) {\n      throw new TypeError('\"' + input + '\" is not a valid interval.');\n    }\n\n    this._i = interval;\n  };\n\n  /**\n   * Get the interval for the buckets. If the\n   * number of buckets created by the interval set\n   * is larger than config:histogram:maxBars then the\n   * interval will be scaled up. If the number of buckets\n   * created is less than one, the interval is scaled back.\n   *\n   * The interval object returned is a moment.duration\n   * object that has been decorated with the following\n   * properties.\n   *\n   * interval.description: a text description of the interval.\n   *   designed to be used list \"field per {{ desc }}\".\n   *     - \"minute\"\n   *     - \"10 days\"\n   *     - \"3 years\"\n   *\n   * interval.expr: the elasticsearch expression that creates this\n   *   interval. If the interval does not properly form an elasticsearch\n   *   expression it will be forced into one.\n   *\n   * interval.scaled: the interval was adjusted to\n   *   accomidate the maxBars setting.\n   *\n   * interval.scale: the numer that y-values should be\n   *   multiplied by\n   *\n   * interval.scaleDescription: a description that reflects\n   *   the values which will be produced by using the\n   *   interval.scale.\n   *\n   *\n   * @return {[type]} [description]\n   */\n  TimeBuckets.prototype.getInterval = function () {\n    var self = this;\n    var duration = self.getDuration();\n    return decorateInterval(maybeScaleInterval(readInterval()));\n\n    // either pull the interval from state or calculate the auto-interval\n    function readInterval() {\n      var interval = self._i;\n      if (_moment2.default.isDuration(interval)) return interval;\n      return calcAuto.near(config.get('histogram:barTarget'), duration);\n    }\n\n    // check to see if the interval should be scaled, and scale it if so\n    function maybeScaleInterval(interval) {\n      if (!self.hasBounds()) return interval;\n\n      var maxLength = config.get('histogram:maxBars');\n      var approxLen = duration / interval;\n      var scaled = void 0;\n\n      if (approxLen > maxLength) {\n        scaled = calcAuto.lessThan(maxLength, duration);\n      } else {\n        return interval;\n      }\n\n      if (+scaled === +interval) return interval;\n\n      decorateInterval(interval);\n      return _lodash2.default.assign(scaled, {\n        preScaled: interval,\n        scale: interval / scaled,\n        scaled: true\n      });\n    }\n\n    // append some TimeBuckets specific props to the interval\n    function decorateInterval(interval) {\n      var esInterval = calcEsInterval(interval);\n      interval.esValue = esInterval.value;\n      interval.esUnit = esInterval.unit;\n      interval.expression = esInterval.expression;\n      interval.overflow = duration > interval ? _moment2.default.duration(interval - duration) : false;\n\n      var prettyUnits = _moment2.default.normalizeUnits(esInterval.unit);\n      if (esInterval.value === 1) {\n        interval.description = prettyUnits;\n      } else {\n        interval.description = esInterval.value + ' ' + prettyUnits + 's';\n      }\n\n      return interval;\n    }\n  };\n\n  /**\n   * Get a date format string that will represent dates that\n   * progress at our interval.\n   *\n   * Since our interval can be as small as 1ms, the default\n   * date format is usually way too much. with `dateFormat:scaled`\n   * users can modify how dates are formatted within series\n   * produced by TimeBuckets\n   *\n   * @return {string}\n   */\n  TimeBuckets.prototype.getScaledDateFormat = function () {\n    var interval = this.getInterval();\n    var rules = config.get('dateFormat:scaled');\n\n    for (var i = rules.length - 1; i >= 0; i--) {\n      var rule = rules[i];\n      if (!rule[0] || interval >= _moment2.default.duration(rule[0])) {\n        return rule[1];\n      }\n    }\n\n    return config.get('dateFormat');\n  };\n\n  TimeBuckets.prototype.getScaledDateFormatter = function () {\n    var DateFieldFormat = fieldFormats.getType('date');\n    return new DateFieldFormat({\n      pattern: this.getScaledDateFormat()\n    }, getConfig);\n  };\n\n  TimeBuckets.__cached__ = function (self) {\n    var cache = {};\n    var sameMoment = same(_moment2.default.isMoment);\n    var sameDuration = same(_moment2.default.isDuration);\n\n    var desc = {\n      __cached__: {\n        value: self\n      }\n    };\n\n    var breakers = {\n      setBounds: 'bounds',\n      clearBounds: 'bounds',\n      setInterval: 'interval'\n    };\n\n    var resources = {\n      bounds: {\n        setup: function setup() {\n          return [self._lb, self._ub];\n        },\n        changes: function changes(prev) {\n          return !sameMoment(prev[0], self._lb) || !sameMoment(prev[1], self._ub);\n        }\n      },\n      interval: {\n        setup: function setup() {\n          return self._i;\n        },\n        changes: function changes(prev) {\n          return !sameDuration(prev, this._i);\n        }\n      }\n    };\n\n    function cachedGetter(prop) {\n      return {\n        value: function cachedGetter() {\n          if (cache.hasOwnProperty(prop)) {\n            return cache[prop];\n          }\n\n          return cache[prop] = self[prop]();\n        }\n      };\n    }\n\n    function cacheBreaker(prop) {\n      var resource = resources[breakers[prop]];\n      var setup = resource.setup;\n      var changes = resource.changes;\n      var fn = self[prop];\n\n      return {\n        value: function cacheBreaker() {\n          var prev = setup.call(self);\n          var ret = fn.apply(self, arguments);\n\n          if (changes.call(self, prev)) {\n            cache = {};\n          }\n\n          return ret;\n        }\n      };\n    }\n\n    function same(checkType) {\n      return function (a, b) {\n        if (a === b) return true;\n        if (checkType(a) === checkType(b)) return +a === +b;\n        return false;\n      };\n    }\n\n    _lodash2.default.forOwn(TimeBuckets.prototype, function (fn, prop) {\n      if (prop[0] === '_') return;\n\n      if (breakers.hasOwnProperty(prop)) {\n        desc[prop] = cacheBreaker(prop);\n      } else {\n        desc[prop] = cachedGetter(prop);\n      }\n    });\n\n    return Object.create(self, desc);\n  };\n\n  return TimeBuckets;\n}",null]}