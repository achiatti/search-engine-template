{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/sense_editor/editor.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/core_plugins/console/public/src/sense_editor/editor.js","mtime":1515552026000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = SenseEditor;\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _ = require('lodash');\nvar ace = require('ace');\nvar $ = require('jquery');\nvar curl = require('../curl');\nvar RowParser = require('./row_parser');\nvar InputMode = require('./mode/input');\nvar utils = require('../utils');\nvar es = require('../es');\n\n\nvar smartResize = require('../smart_resize');\n\nfunction createInstance($el) {\n  var aceEditor = ace.edit($el[0]);\n\n  // we must create a custom class for each instance, so that the prototype\n  // can be the unique aceEditor it extends\n  var CustomSenseEditor = function CustomSenseEditor() {};\n  CustomSenseEditor.prototype = {};\n\n  function bindProp(key) {\n    Object.defineProperty(CustomSenseEditor.prototype, key, {\n      get: function get() {\n        return aceEditor[key];\n      },\n      set: function set(val) {\n        aceEditor[key] = val;\n      }\n    });\n  }\n\n  // iterate all of the accessible properties/method, on the prototype and beyond\n  for (var key in aceEditor) {\n    switch (_typeof(aceEditor[key])) {\n      case 'function':\n        CustomSenseEditor.prototype[key] = _.bindKey(aceEditor, key);\n        break;\n      default:\n        bindProp(key);\n        break;\n    }\n  }\n\n  var editor = new CustomSenseEditor();\n  editor.__ace = aceEditor;\n  return editor;\n}\n\nfunction SenseEditor($el) {\n  var editor = createInstance($el);\n  var CURRENT_REQ_RANGE = null;\n\n  editor.$el = $el;\n  // place holder for an action bar, needs to be set externally.\n  editor.$actions = null;\n\n  // mixin the RowParser\n  editor.parser = new RowParser(editor);\n  editor.resize = smartResize(editor);\n\n  // dirty check for tokenizer state, uses a lot less cycles\n  // than listening for tokenizerUpdate\n  var onceDoneTokenizing = function onceDoneTokenizing(func, cancelAlreadyScheduledCalls) {\n    var session = editor.getSession();\n    var timer = false;\n    var checkInterval = 25;\n\n    return function () {\n      var self = this;\n      var args = [].slice.call(arguments, 0);\n\n      if (cancelAlreadyScheduledCalls) {\n        timer = clearTimeout(timer);\n      }\n\n      setTimeout(function check() {\n        if (session.bgTokenizer.running) {\n          timer = setTimeout(check, checkInterval);\n        } else {\n          func.apply(self, args);\n        }\n      });\n    };\n  };\n\n  editor.setShowPrintMargin(false);\n  (function (session) {\n    session.setMode(new InputMode.Mode());\n    session.setFoldStyle('markbeginend');\n    session.setTabSize(2);\n    session.setUseWrapMode(true);\n  })(editor.getSession());\n\n  editor.prevRequestStart = function (rowOrPos) {\n    rowOrPos = _.isUndefined(rowOrPos) || rowOrPos == null ? editor.getCursorPosition() : rowOrPos;\n\n    var curRow = _.isObject(rowOrPos) ? rowOrPos.row : rowOrPos;\n    while (curRow > 0 && !editor.parser.isStartRequestRow(curRow, editor)) {\n      curRow--;\n    }return {\n      row: curRow,\n      column: 0\n    };\n  };\n\n  editor.nextRequestStart = function (rowOrPos) {\n    rowOrPos = _.isUndefined(rowOrPos) || rowOrPos == null ? editor.getCursorPosition() : rowOrPos;\n    var session = editor.getSession();\n    var curRow = _.isObject(rowOrPos) ? rowOrPos.row : rowOrPos;\n    var maxLines = session.getLength();\n    for (; curRow < maxLines - 1; curRow++) {\n      if (editor.parser.isStartRequestRow(curRow, editor)) {\n        break;\n      }\n    }\n    return {\n      row: curRow,\n      column: 0\n    };\n  };\n\n  editor.autoIndent = onceDoneTokenizing(function () {\n    editor.getRequestRange(function (req_range) {\n      if (!req_range) {\n        return;\n      }\n      editor.getRequest(function (parsed_req) {\n        if (parsed_req.data && parsed_req.data.length > 0) {\n          var indent = parsed_req.data.length == 1; // unindent multi docs by default\n          var formatted_data = utils.reformatData(parsed_req.data, indent);\n          if (!formatted_data.changed) {\n            // toggle.\n            indent = !indent;\n            formatted_data = utils.reformatData(parsed_req.data, indent);\n          }\n          parsed_req.data = formatted_data.data;\n\n          editor.replaceRequestRange(parsed_req, req_range);\n        }\n      });\n    });\n  }, true);\n\n  editor.update = function (data, callback) {\n    callback = typeof callback === 'function' ? callback : null;\n    var session = editor.getSession();\n\n    session.setValue(data);\n    if (callback) {\n      // force update of tokens, but not on this thread to allow for ace rendering.\n      setTimeout(function () {\n        var i;\n        for (i = 0; i < session.getLength(); i++) {\n          session.getTokens(i);\n        }\n        callback();\n      });\n    }\n  };\n\n  editor.replaceRequestRange = function (newRequest, requestRange) {\n    var text = utils.textFromRequest(newRequest);\n    if (requestRange) {\n      var pos = editor.getCursorPosition();\n      editor.getSession().replace(requestRange, text);\n      var max_row = Math.max(requestRange.start.row + text.split('\\n').length - 1, 0);\n      pos.row = Math.min(pos.row, max_row);\n      editor.moveCursorToPosition(pos);\n      // ACE UPGRADE - check if needed - at the moment the above may trigger a selection.\n      editor.clearSelection();\n    } else {\n      // just insert where we are\n      editor.insert(text);\n    }\n  };\n\n  editor.iterForCurrentLoc = function () {\n    var pos = editor.getCursorPosition();\n    return editor.iterForPosition(pos.row, pos.column, editor);\n  };\n\n  editor.iterForPosition = function (row, column) {\n    return new (ace.require(\"ace/token_iterator\").TokenIterator)(editor.getSession(), row, column);\n  };\n\n  editor.getRequestRange = onceDoneTokenizing(function (row, cb) {\n    if (_.isUndefined(cb)) {\n      cb = row;\n      row = null;\n    }\n    if (typeof cb !== 'function') {\n      return;\n    }\n\n    if (editor.parser.isInBetweenRequestsRow(row)) {\n      cb(null);\n      return;\n    }\n\n    var reqStart = editor.prevRequestStart(row, editor);\n    var reqEnd = editor.nextRequestEnd(reqStart, editor);\n    cb(new (ace.require(\"ace/range\").Range)(reqStart.row, reqStart.column, reqEnd.row, reqEnd.column));\n  });\n\n  editor.getEngulfingRequestsRange = onceDoneTokenizing(function (range, cb) {\n    if (_.isUndefined(cb)) {\n      cb = range;\n      range = null;\n    }\n\n    range = range || editor.getSelectionRange();\n\n    var session = editor.getSession();\n    var startRow = range.start.row;\n    var endRow = range.end.row;\n    var maxLine = Math.max(0, session.getLength() - 1);\n\n    // move start row to the previous request start if in body, o.w. forward\n    if (editor.parser.isInBetweenRequestsRow(startRow)) {\n      //for (; startRow <= endRow; startRow++) {\n      //  if (editor.parser.isStartRequestRow(startRow)) {\n      //    break;\n      //  }\n      //}\n    } else {\n      for (; startRow >= 0; startRow--) {\n        if (editor.parser.isStartRequestRow(startRow)) {\n          break;\n        }\n      }\n    }\n\n    if (startRow < 0 || startRow > endRow) {\n      cb(null);\n      return;\n    }\n    // move end row to the previous request end if between requests, o.w. walk forward\n    if (editor.parser.isInBetweenRequestsRow(endRow)) {\n      for (; endRow >= startRow; endRow--) {\n        if (editor.parser.isEndRequestRow(endRow)) {\n          break;\n        }\n      }\n    } else {\n\n      for (; endRow <= maxLine; endRow++) {\n        if (editor.parser.isEndRequestRow(endRow)) {\n          break;\n        }\n      }\n    }\n\n    if (endRow < startRow || endRow > maxLine) {\n      cb(null);\n      return;\n    }\n\n    var endColumn = (session.getLine(endRow) || \"\").replace(/\\s+$/, \"\").length;\n    cb(new (ace.require(\"ace/range\").Range)(startRow, 0, endRow, endColumn));\n  });\n\n  editor.getRequestInRange = onceDoneTokenizing(function (range, cb) {\n    var request = {\n      method: \"\",\n      data: [],\n      url: null,\n      range: range\n    };\n\n    var pos = range.start;\n    var tokenIter = editor.iterForPosition(pos.row, pos.column, editor);\n    var t = tokenIter.getCurrentToken();\n    if (editor.parser.isEmptyToken(t)) {\n      // if the row starts with some spaces, skip them.\n      t = editor.parser.nextNonEmptyToken(tokenIter);\n    }\n    request.method = t.value;\n    t = editor.parser.nextNonEmptyToken(tokenIter);\n    if (!t || t.type == \"method\") {\n      return null;\n    }\n    request.url = \"\";\n    while (t && t.type && t.type.indexOf(\"url\") == 0) {\n      request.url += t.value;\n      t = tokenIter.stepForward();\n    }\n    if (editor.parser.isEmptyToken(t)) {\n      // if the url row ends with some spaces, skip them.\n      t = editor.parser.nextNonEmptyToken(tokenIter);\n    }\n\n    var bodyStartRow = (t ? 0 : 1) + tokenIter.getCurrentTokenRow(); // artificially increase end of docs.\n    var dataEndPos;\n    while (bodyStartRow < range.end.row || bodyStartRow == range.end.row && 0 < range.end.column) {\n      dataEndPos = editor.nextDataDocEnd({\n        row: bodyStartRow,\n        column: 0\n      });\n      var bodyRange = new (ace.require(\"ace/range\").Range)(bodyStartRow, 0, dataEndPos.row, dataEndPos.column);\n      var data = editor.getSession().getTextRange(bodyRange);\n      request.data.push(data.trim());\n      bodyStartRow = dataEndPos.row + 1;\n    }\n\n    cb(request);\n  });\n\n  editor.getRequestsInRange = function (range, includeNonRequestBlocks, cb) {\n    if (_.isUndefined(includeNonRequestBlocks)) {\n      includeNonRequestBlocks = false;\n      cb = range;\n      range = null;\n    } else if (_.isUndefined(cb)) {\n      cb = includeNonRequestBlocks;\n      includeNonRequestBlocks = false;\n    }\n\n    function explicitRangeToRequests(requestsRange, tempCb) {\n      if (!requestsRange) {\n        tempCb([]);\n        return;\n      }\n\n      var startRow = requestsRange.start.row;\n      var endRow = requestsRange.end.row;\n\n      // move to the next request start (during the second iterations this may not be exactly on a request\n      var currentRow = startRow;\n      for (; currentRow <= endRow; currentRow++) {\n        if (editor.parser.isStartRequestRow(currentRow)) {\n          break;\n        }\n      }\n\n      var nonRequestPrefixBlock = null;\n      if (includeNonRequestBlocks && currentRow != startRow) {\n        nonRequestPrefixBlock = editor.getSession().getLines(startRow, currentRow - 1).join(\"\\n\");\n      }\n\n      if (currentRow > endRow) {\n        tempCb(nonRequestPrefixBlock ? [nonRequestPrefixBlock] : []);\n        return;\n      }\n\n      editor.getRequest(currentRow, function (request) {\n        explicitRangeToRequests({\n          start: {\n            row: request.range.end.row + 1\n          },\n          end: {\n            row: requestsRange.end.row\n          }\n        }, function (rest_of_requests) {\n          rest_of_requests.unshift(request);\n          if (nonRequestPrefixBlock != null) {\n            rest_of_requests.unshift(nonRequestPrefixBlock);\n          }\n          tempCb(rest_of_requests);\n        });\n      });\n    }\n\n    editor.getEngulfingRequestsRange(range, function (requestRange) {\n      explicitRangeToRequests(requestRange, cb);\n    });\n  };\n\n  editor.getRequest = onceDoneTokenizing(function (row, cb) {\n    if (_.isUndefined(cb)) {\n      cb = row;\n      row = null;\n    }\n    if (typeof cb !== 'function') {\n      return;\n    }\n    if (editor.parser.isInBetweenRequestsRow(row)) {\n      cb(null);\n      return;\n    }\n    editor.getRequestRange(row, function (range) {\n      editor.getRequestInRange(range, cb);\n    });\n  });\n\n  editor.moveToPreviousRequestEdge = onceDoneTokenizing(function () {\n    var pos = editor.getCursorPosition();\n    for (pos.row--; pos.row > 0 && !editor.parser.isRequestEdge(pos.row); pos.row--) {}\n    editor.moveCursorTo(pos.row, 0);\n  });\n\n  editor.moveToNextRequestEdge = onceDoneTokenizing(function (moveOnlyIfNotOnEdge) {\n    var pos = editor.getCursorPosition();\n    var maxRow = editor.getSession().getLength();\n    if (!moveOnlyIfNotOnEdge) {\n      pos.row++;\n    }\n    for (; pos.row < maxRow && !editor.parser.isRequestEdge(pos.row); pos.row++) {}\n    editor.moveCursorTo(pos.row, 0);\n  });\n\n  editor.nextRequestEnd = function (pos) {\n    pos = pos || editor.getCursorPosition();\n    var session = editor.getSession();\n    var curRow = pos.row;\n    var maxLines = session.getLength();\n    for (; curRow < maxLines - 1; curRow++) {\n      var curRowMode = editor.parser.getRowParseMode(curRow, editor);\n      if ((curRowMode & editor.parser.MODE.REQUEST_END) > 0) {\n        break;\n      }\n      if (curRow != pos.row && (curRowMode & editor.parser.MODE.REQUEST_START) > 0) {\n        break;\n      }\n    }\n\n    var column = (session.getLine(curRow) || \"\").replace(/\\s+$/, \"\").length;\n\n    return {\n      row: curRow,\n      column: column\n    };\n  };\n\n  editor.nextDataDocEnd = function (pos) {\n    pos = pos || editor.getCursorPosition();\n    var session = editor.getSession();\n    var curRow = pos.row;\n    var maxLines = session.getLength();\n    for (; curRow < maxLines - 1; curRow++) {\n      var curRowMode = editor.parser.getRowParseMode(curRow, editor);\n      if ((curRowMode & RowParser.REQUEST_END) > 0) {\n        break;\n      }\n      if ((curRowMode & editor.parser.MODE.MULTI_DOC_CUR_DOC_END) > 0) {\n        break;\n      }\n      if (curRow != pos.row && (curRowMode & editor.parser.MODE.REQUEST_START) > 0) {\n        break;\n      }\n    }\n\n    var column = (session.getLine(curRow) || \"\").length;\n\n    return {\n      row: curRow,\n      column: column\n    };\n  };\n\n  // overwrite the actual aceEditor's onPaste method\n  var origOnPaste = editor.__ace.onPaste;\n  editor.__ace.onPaste = function (text) {\n    if (text && curl.detectCURL(text)) {\n      editor.handleCURLPaste(text);\n      return;\n    }\n    origOnPaste.call(this, text);\n  };\n\n  editor.handleCURLPaste = function (text) {\n    var curlInput = curl.parseCURL(text);\n\n    editor.insert(curlInput);\n  };\n\n  editor.highlightCurrentRequestsAndUpdateActionBar = onceDoneTokenizing(function () {\n    var session = editor.getSession();\n    editor.getEngulfingRequestsRange(function (new_current_req_range) {\n      if (new_current_req_range == null && CURRENT_REQ_RANGE == null) {\n        return;\n      }\n      if (new_current_req_range != null && CURRENT_REQ_RANGE != null && new_current_req_range.start.row == CURRENT_REQ_RANGE.start.row && new_current_req_range.end.row == CURRENT_REQ_RANGE.end.row) {\n        // same request, now see if we are on the first line and update the action bar\n        var cursorRow = editor.getCursorPosition().row;\n        if (cursorRow == CURRENT_REQ_RANGE.start.row) {\n          editor.updateActionsBar();\n        }\n        return; // nothing to do..\n      }\n\n      if (CURRENT_REQ_RANGE) {\n        session.removeMarker(CURRENT_REQ_RANGE.marker_id);\n      }\n\n      CURRENT_REQ_RANGE = new_current_req_range;\n      if (CURRENT_REQ_RANGE) {\n        CURRENT_REQ_RANGE.marker_id = session.addMarker(CURRENT_REQ_RANGE, \"ace_snippet-marker\", \"fullLine\");\n      }\n      editor.updateActionsBar();\n    });\n  }, true);\n\n  editor.getRequestsAsCURL = function (range, cb) {\n    if (_.isUndefined(cb)) {\n      cb = range;\n      range = null;\n    }\n\n    if (_.isUndefined(cb)) {\n      cb = $.noop;\n    }\n\n    editor.getRequestsInRange(range, true, function (requests) {\n\n      var result = _.map(requests, function requestToCurl(req) {\n\n        if (typeof req === \"string\") {\n          // no request block\n          return req;\n        }\n\n        var es_path = req.url,\n            es_method = req.method,\n            es_data = req.data;\n\n        var elasticsearchBaseUrl = _chrome2.default.getInjected('elasticsearchUrl');\n        var url = es.constructESUrl(elasticsearchBaseUrl, es_path);\n\n        var ret = 'curl -X' + es_method + ' \"' + url + '\"';\n        if (es_data && es_data.length) {\n          ret += \" -H 'Content-Type: application/json' -d'\\n\";\n          var data_as_string = utils.collapseLiteralStrings(es_data.join(\"\\n\"));\n          // since Sense doesn't allow single quote json string any single qoute is within a string.\n          ret += data_as_string.replace(/'/g, '\\\\\"');\n          if (es_data.length > 1) {\n            ret += \"\\n\";\n          } // end with a new line\n          ret += \"'\";\n        }\n        return ret;\n      });\n\n      cb(result.join(\"\\n\"));\n    });\n  };\n\n  editor.getSession().on('tokenizerUpdate', function () {\n    editor.highlightCurrentRequestsAndUpdateActionBar();\n  });\n\n  editor.getSession().selection.on('changeCursor', function () {\n    editor.highlightCurrentRequestsAndUpdateActionBar();\n  });\n\n  editor.updateActionsBar = function () {\n    var set = function set(top) {\n      if (top == null) {\n        editor.$actions.css('visibility', 'hidden');\n      } else {\n        editor.$actions.css({\n          top: top,\n          visibility: 'visible'\n        });\n      }\n    };\n\n    var hide = function hide() {\n      set();\n    };\n\n    return function () {\n      if (!editor.$actions) {\n        return;\n      }\n      if (CURRENT_REQ_RANGE) {\n        // elements are positioned relative to the editor's container\n        // pageY is relative to page, so subtract the offset\n        // from pageY to get the new top value\n        var offsetFromPage = editor.$el.offset().top;\n        var startRow = CURRENT_REQ_RANGE.start.row;\n        var startColumn = CURRENT_REQ_RANGE.start.column;\n        var session = editor.session;\n        var firstLine = session.getLine(startRow);\n\n        if (firstLine.length > session.getWrapLimit() - 5) {\n          // overlap first row\n          if (startRow > 0) {\n            startRow--;\n          } else {\n            startRow++;\n          }\n        }\n\n        var topOfReq = editor.renderer.textToScreenCoordinates(startRow, startColumn).pageY - offsetFromPage;\n\n        if (topOfReq >= 0) {\n          return set(topOfReq);\n        }\n\n        var bottomOfReq = editor.renderer.textToScreenCoordinates(CURRENT_REQ_RANGE.end.row, CURRENT_REQ_RANGE.end.column).pageY - offsetFromPage;\n\n        if (bottomOfReq >= 0) {\n          return set(0);\n        }\n      }\n\n      hide();\n    };\n  }();\n\n  editor.getSession().on(\"changeScrollTop\", editor.updateActionsBar);\n\n  return editor;\n}\nmodule.exports = exports['default'];",null]}