{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/request/segmented.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/courier/fetch/request/segmented.js","mtime":1515552035000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.SegmentedRequestProvider = SegmentedRequestProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _notifier = require('ui/notify/notifier');\n\nvar _search_request = require('./search_request');\n\nvar _segmented_handle = require('./segmented_handle');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction SegmentedRequestProvider(Private, timefilter, config) {\n  var SearchRequest = Private(_search_request.SearchRequestProvider);\n  var SegmentedHandle = Private(_segmented_handle.SegmentedHandleProvider);\n\n  var notify = new _notifier.Notifier({\n    location: 'Segmented Fetch'\n  });\n\n  var SegmentedReq = function (_SearchRequest) {\n    _inherits(SegmentedReq, _SearchRequest);\n\n    function SegmentedReq(source, defer, initFn) {\n      _classCallCheck(this, SegmentedReq);\n\n      var _this = _possibleConstructorReturn(this, (SegmentedReq.__proto__ || Object.getPrototypeOf(SegmentedReq)).call(this, source, defer));\n\n      _this.type = 'segmented';\n\n      // segmented request specific state\n      _this._initFn = initFn;\n\n      _this._desiredSize = null;\n      _this._maxSegments = config.get('courier:maxSegmentCount');\n      _this._direction = 'desc';\n      _this._sortFn = null;\n      _this._queueCreated = false;\n      _this._handle = new SegmentedHandle(_this);\n\n      _this._hitWindow = null;\n\n      // prevent the source from changing between requests,\n      // all calls will return the same promise\n      _this._getFlattenedSource = _lodash2.default.once(_this._getFlattenedSource);\n      return _this;\n    }\n\n    /*********\n    ** SearchReq overrides\n    *********/\n\n    _createClass(SegmentedReq, [{\n      key: 'start',\n      value: function start() {\n        var _this2 = this;\n\n        return _get(SegmentedReq.prototype.__proto__ || Object.getPrototypeOf(SegmentedReq.prototype), 'start', this).call(this).then(function () {\n          _this2._complete = [];\n          _this2._active = null;\n          _this2._segments = [];\n          _this2._all = [];\n          _this2._queue = [];\n\n          _this2._mergedResp = {\n            took: 0,\n            hits: {\n              hits: [],\n              total: 0,\n              max_score: 0\n            }\n          };\n\n          // give the request consumer a chance to receive each segment and set\n          // parameters via the handle\n          if (_lodash2.default.isFunction(_this2._initFn)) _this2._initFn(_this2._handle);\n          return _this2._createQueue();\n        }).then(function (queue) {\n          if (_this2.stopped) return;\n\n          _this2._all = queue.slice(0);\n\n          // Send the initial fetch status\n          return _this2._reportStatus();\n        });\n      }\n    }, {\n      key: 'continue',\n      value: function _continue() {\n        return this._reportStatus();\n      }\n    }, {\n      key: 'getFetchParams',\n      value: function getFetchParams() {\n        var _this3 = this;\n\n        return this._getFlattenedSource().then(function (flatSource) {\n          var params = _lodash2.default.cloneDeep(flatSource);\n\n          // calculate the number of indices to fetch in this request in order to prevent\n          // more than this._maxSegments requests. We use Math.max(1, n) to ensure that each request\n          // has at least one index pattern, and Math.floor() to make sure that if the\n          // number of indices does not round out evenly the extra index is tacked onto the last\n          // request, making sure the first request returns faster.\n          var remainingSegments = _this3._maxSegments - _this3._segments.length;\n          var indexCount = Math.max(1, Math.floor(_this3._queue.length / remainingSegments));\n\n          var indices = _this3._active = _this3._queue.splice(0, indexCount);\n          params.index = _lodash2.default.pluck(indices, 'index');\n\n          if (_lodash2.default.isNumber(_this3._desiredSize)) {\n            params.body.size = _this3._pickSizeForIndices(indices);\n          }\n\n          return params;\n        });\n      }\n    }, {\n      key: 'handleResponse',\n      value: function handleResponse(resp) {\n        return this._consumeSegment(resp);\n      }\n    }, {\n      key: 'filterError',\n      value: function filterError(resp) {\n        if (/ClusterBlockException.*index\\sclosed/.test(resp.error)) {\n          this._consumeSegment(false);\n          return true;\n        }\n      }\n    }, {\n      key: 'isIncomplete',\n      value: function isIncomplete() {\n        var queueNotCreated = !this._queueCreated;\n        var queueNotEmpty = this._queue.length > 0;\n        return queueNotCreated || queueNotEmpty;\n      }\n    }, {\n      key: 'clone',\n      value: function clone() {\n        return new SegmentedReq(this.source, this.defer, this._initFn);\n      }\n    }, {\n      key: 'complete',\n      value: function complete() {\n        this._reportStatus();\n        this._handle.emit('complete');\n        return _get(SegmentedReq.prototype.__proto__ || Object.getPrototypeOf(SegmentedReq.prototype), 'complete', this).call(this);\n      }\n\n      /*********\n      ** SegmentedReq specific methods\n      *********/\n\n      /**\n      * Set the sort total number of segments to emit\n      *\n      * @param {number}\n      */\n\n    }, {\n      key: 'setMaxSegments',\n      value: function setMaxSegments(maxSegments) {\n        this._maxSegments = Math.max(_lodash2.default.parseInt(maxSegments), 1);\n      }\n\n      /**\n      * Set the sort direction for the request.\n      *\n      * @param {string} dir - one of 'asc' or 'desc'\n      */\n\n    }, {\n      key: 'setDirection',\n      value: function setDirection(dir) {\n        switch (dir) {\n          case 'asc':\n          case 'desc':\n            return this._direction = dir;\n          default:\n            throw new TypeError('unknown sort direction \"' + dir + '\"');\n        }\n      }\n\n      /**\n      * Set the function that will be used to sort the rows\n      *\n      * @param {fn}\n      */\n\n    }, {\n      key: 'setSortFn',\n      value: function setSortFn(sortFn) {\n        this._sortFn = sortFn;\n      }\n\n      /**\n      * Set the sort total number of documents to\n      * emit\n      *\n      * Setting to false will not limit the documents,\n      * if a number is set the size of the request to es\n      * will be updated on each new request\n      *\n      * @param {number|false}\n      */\n\n    }, {\n      key: 'setSize',\n      value: function setSize(totalSize) {\n        this._desiredSize = _lodash2.default.parseInt(totalSize);\n        if (isNaN(this._desiredSize)) this._desiredSize = null;\n      }\n    }, {\n      key: '_createQueue',\n      value: function _createQueue() {\n        var _this4 = this;\n\n        var timeBounds = timefilter.getBounds();\n        var indexPattern = this.source.get('index');\n        this._queueCreated = false;\n\n        return indexPattern.toDetailedIndexList(timeBounds.min, timeBounds.max, this._direction).then(function (queue) {\n          _this4._queue = queue;\n          _this4._queueCreated = true;\n          return queue;\n        });\n      }\n    }, {\n      key: '_reportStatus',\n      value: function _reportStatus() {\n        return this._handle.emit('status', {\n          total: this._queueCreated ? this._all.length : NaN,\n          complete: this._queueCreated ? this._complete.length : NaN,\n          remaining: this._queueCreated ? this._queue.length : NaN,\n          hitCount: this._queueCreated ? this._mergedResp.hits.hits.length : NaN\n        });\n      }\n    }, {\n      key: '_getFlattenedSource',\n      value: function _getFlattenedSource() {\n        return this.source._flatten();\n      }\n    }, {\n      key: '_consumeSegment',\n      value: function _consumeSegment(seg) {\n        var index = this._active;\n        this._complete.push(index);\n        if (!seg) return; // segment was ignored/filtered, don't store it\n\n        var hadHits = _lodash2.default.get(this._mergedResp, 'hits.hits.length') > 0;\n        var gotHits = _lodash2.default.get(seg, 'hits.hits.length') > 0;\n        var firstHits = !hadHits && gotHits;\n        var haveHits = hadHits || gotHits;\n\n        this._mergeSegment(seg);\n        this.resp = _lodash2.default.omit(this._mergedResp, '_bucketIndex');\n\n        if (firstHits) this._handle.emit('first', seg);\n        if (gotHits) this._handle.emit('segment', seg);\n        if (haveHits) this._handle.emit('mergedSegment', this.resp);\n      }\n    }, {\n      key: '_mergeHits',\n      value: function _mergeHits(hits) {\n        var mergedHits = this._mergedResp.hits.hits;\n        var desiredSize = this._desiredSize;\n        var sortFn = this._sortFn;\n\n        _lodash2.default.pushAll(hits, mergedHits);\n\n        if (sortFn) {\n          notify.event('resort rows', function () {\n            mergedHits.sort(sortFn);\n          });\n        }\n\n        if (_lodash2.default.isNumber(desiredSize)) {\n          this._mergedResp.hits.hits = mergedHits.slice(0, desiredSize);\n        }\n      }\n    }, {\n      key: '_mergeSegment',\n      value: function _mergeSegment(seg) {\n        var merged = this._mergedResp;\n\n        this._segments.push(seg);\n\n        merged.took += seg.took;\n        merged.hits.total += seg.hits.total;\n        merged.hits.max_score = Math.max(merged.hits.max_score, seg.hits.max_score);\n\n        if (_lodash2.default.size(seg.hits.hits)) {\n          this._mergeHits(seg.hits.hits);\n          this._detectHitsWindow(merged.hits.hits);\n        }\n\n        if (!seg.aggregations) return;\n\n        Object.keys(seg.aggregations).forEach(function (aggKey) {\n\n          if (!merged.aggregations) {\n            // start merging aggregations\n            merged.aggregations = {};\n            merged._bucketIndex = {};\n          }\n\n          if (!merged.aggregations[aggKey]) {\n            merged.aggregations[aggKey] = {\n              buckets: []\n            };\n          }\n\n          seg.aggregations[aggKey].buckets.forEach(function (bucket) {\n            var mbucket = merged._bucketIndex[bucket.key];\n            if (mbucket) {\n              mbucket.doc_count += bucket.doc_count;\n              return;\n            }\n\n            mbucket = merged._bucketIndex[bucket.key] = bucket;\n            merged.aggregations[aggKey].buckets.push(mbucket);\n          });\n        });\n      }\n    }, {\n      key: '_detectHitsWindow',\n      value: function _detectHitsWindow(hits) {\n        hits = hits || [];\n        var indexPattern = this.source.get('index');\n        var desiredSize = this._desiredSize;\n\n        var size = _lodash2.default.size(hits);\n        if (!_lodash2.default.isNumber(desiredSize) || size < desiredSize) {\n          this._hitWindow = {\n            size: size,\n            min: -Infinity,\n            max: Infinity\n          };\n          return;\n        }\n\n        var min = void 0;\n        var max = void 0;\n\n        hits.forEach(function (deepHit) {\n          var hit = indexPattern.flattenHit(deepHit);\n          var time = hit[indexPattern.timeFieldName];\n          if (min == null || time < min) min = time;\n          if (max == null || time > max) max = time;\n        });\n\n        this._hitWindow = { size: size, min: min, max: max };\n      }\n    }, {\n      key: '_pickSizeForIndices',\n      value: function _pickSizeForIndices(indices) {\n        var hitWindow = this._hitWindow;\n        var desiredSize = this._desiredSize;\n\n        if (!_lodash2.default.isNumber(desiredSize)) return null;\n        // we don't have any hits yet, get us more info!\n        if (!hitWindow) return desiredSize;\n        // the order of documents isn't important, just get us more\n        if (!this._sortFn) return Math.max(desiredSize - hitWindow.size, 0);\n        // if all of the documents in every index fall outside of our current doc set, we can ignore them.\n        var someOverlap = indices.some(function (index) {\n          return index.min <= hitWindow.max && hitWindow.min <= index.max;\n        });\n\n        return someOverlap ? desiredSize : 0;\n      }\n    }]);\n\n    return SegmentedReq;\n  }(SearchRequest);\n\n  SegmentedReq.prototype.mergedSegment = notify.timed('merge response segment', SegmentedReq.prototype.mergedSegment);\n\n  return SegmentedReq;\n}",null]}