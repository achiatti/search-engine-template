{"remainingRequest":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js??ref--6-1!/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/data.js","dependencies":[{"path":"/home/vagrant/projects/kibana/build/kibana/src/ui/public/vislib/lib/data.js","mtime":1515552039000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1493198456000},{"path":"/home/vagrant/projects/kibana/build/kibana/node_modules/babel-loader/lib/index.js","mtime":1503096278000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.VislibLibDataProvider = VislibLibDataProvider;\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _inject_zeros = require('../components/zero_injection/inject_zeros');\n\nvar _ordered_x_keys = require('../components/zero_injection/ordered_x_keys');\n\nvar _labels = require('../components/labels/labels');\n\nvar _color = require('ui/vis/components/color/color');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction VislibLibDataProvider(Private) {\n\n  var _injectZeros = Private(_inject_zeros.VislibComponentsZeroInjectionInjectZerosProvider);\n  var orderKeys = Private(_ordered_x_keys.VislibComponentsZeroInjectionOrderedXKeysProvider);\n  var _getLabels2 = Private(_labels.VislibComponentsLabelsLabelsProvider);\n  var color = Private(_color.VislibComponentsColorColorProvider);\n\n  /**\n   * Provides an API for pulling values off the data\n   * and calculating values using the data\n   *\n   * @class Data\n   * @constructor\n   * @param data {Object} Elasticsearch query results\n   * @param attr {Object|*} Visualization options\n   */\n\n  var Data = function () {\n    function Data(data, uiState) {\n      _classCallCheck(this, Data);\n\n      this.uiState = uiState;\n      this.data = this.copyDataObj(data);\n      this.type = this.getDataType();\n\n      this.labels = this._getLabels(this.data);\n      this.color = this.labels ? color(this.labels, uiState.get('vis.colors')) : undefined;\n      this._normalizeOrdered();\n    }\n\n    _createClass(Data, [{\n      key: 'copyDataObj',\n      value: function copyDataObj(data) {\n        var copyChart = function copyChart(data) {\n          var newData = {};\n          Object.keys(data).forEach(function (key) {\n            if (key !== 'series') {\n              newData[key] = data[key];\n            } else {\n              newData[key] = data[key].map(function (seri) {\n                return {\n                  label: seri.label,\n                  aggLabel: seri.aggLabel,\n                  aggId: seri.aggId,\n                  values: seri.values.map(function (val) {\n                    var newVal = _lodash2.default.clone(val);\n                    newVal.aggConfig = val.aggConfig;\n                    newVal.aggConfigResult = val.aggConfigResult;\n                    newVal.extraMetrics = val.extraMetrics;\n                    newVal.series = val.series || seri.label;\n                    return newVal;\n                  })\n                };\n              });\n            }\n          });\n          return newData;\n        };\n\n        if (!data.series) {\n          var newData = {};\n          Object.keys(data).forEach(function (key) {\n            if (!['rows', 'columns'].includes(key)) {\n              newData[key] = data[key];\n            } else {\n              newData[key] = data[key].map(function (chart) {\n                return copyChart(chart);\n              });\n            }\n          });\n          return newData;\n        }\n        return copyChart(data);\n      }\n    }, {\n      key: '_getLabels',\n      value: function _getLabels(data) {\n        return this.type === 'series' ? _getLabels2(data) : this.pieNames();\n      }\n    }, {\n      key: 'getDataType',\n      value: function getDataType() {\n        var data = this.getVisData();\n        var type = void 0;\n\n        data.forEach(function (obj) {\n          if (obj.series) {\n            type = 'series';\n          } else if (obj.slices) {\n            type = 'slices';\n          } else if (obj.geoJson) {\n            type = 'geoJson';\n          }\n        });\n\n        return type;\n      }\n\n      /**\n       * Returns an array of the actual x and y data value objects\n       * from data with series keys\n       *\n       * @method chartData\n       * @returns {*} Array of data objects\n       */\n\n    }, {\n      key: 'chartData',\n      value: function chartData() {\n        if (!this.data.series) {\n          var arr = this.data.rows ? this.data.rows : this.data.columns;\n          return _lodash2.default.toArray(arr);\n        }\n        return [this.data];\n      }\n    }, {\n      key: 'shouldBeStacked',\n      value: function shouldBeStacked(seriesConfig) {\n        if (!seriesConfig) return false;\n        return seriesConfig.mode === 'stacked';\n      }\n    }, {\n      key: 'getStackedSeries',\n      value: function getStackedSeries(chartConfig, axis, series) {\n        var _this = this;\n\n        var first = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        var matchingSeries = [];\n        chartConfig.series.forEach(function (seriArgs, i) {\n          var matchingAxis = seriArgs.valueAxis === axis.axisConfig.get('id') || !seriArgs.valueAxis && first;\n          if (matchingAxis && (_this.shouldBeStacked(seriArgs) || axis.axisConfig.get('scale.stacked'))) {\n            matchingSeries.push(series[i]);\n          }\n        });\n        return matchingSeries;\n      }\n    }, {\n      key: 'stackChartData',\n      value: function stackChartData(handler, data, chartConfig) {\n        var _this2 = this;\n\n        var stackedData = {};\n        handler.valueAxes.forEach(function (axis, i) {\n          var id = axis.axisConfig.get('id');\n          stackedData[id] = _this2.getStackedSeries(chartConfig, axis, data, i === 0);\n          stackedData[id] = _this2.injectZeros(stackedData[id], handler.visConfig.get('orderBucketsBySum', false));\n          axis.axisConfig.set('stackedSeries', stackedData[id].length);\n          axis.stack(_lodash2.default.map(stackedData[id], 'values'));\n        });\n        return stackedData;\n      }\n    }, {\n      key: 'stackData',\n      value: function stackData(handler) {\n        var _this3 = this;\n\n        var data = this.data;\n        if (data.rows || data.columns) {\n          var charts = data.rows ? data.rows : data.columns;\n          charts.forEach(function (chart, i) {\n            _this3.stackChartData(handler, chart.series, handler.visConfig.get('charts[' + i + ']'));\n          });\n        } else {\n          this.stackChartData(handler, data.series, handler.visConfig.get('charts[0]'));\n        }\n      }\n\n      /**\n       * Returns an array of chart data objects\n       *\n       * @method getVisData\n       * @returns {*} Array of chart data objects\n       */\n\n    }, {\n      key: 'getVisData',\n      value: function getVisData() {\n        var visData = void 0;\n\n        if (this.data.rows) {\n          visData = this.data.rows;\n        } else if (this.data.columns) {\n          visData = this.data.columns;\n        } else {\n          visData = [this.data];\n        }\n\n        return visData;\n      }\n\n      /**\n       * get min and max for all cols, rows of data\n       *\n       * @method getMaxMin\n       * @return {Object}\n       */\n\n    }, {\n      key: 'getGeoExtents',\n      value: function getGeoExtents() {\n        var visData = this.getVisData();\n\n        return _lodash2.default.reduce(_lodash2.default.pluck(visData, 'geoJson.properties'), function (minMax, props) {\n          return {\n            min: Math.min(props.min, minMax.min),\n            max: Math.max(props.max, minMax.max)\n          };\n        }, { min: Infinity, max: -Infinity });\n      }\n\n      /**\n       * Returns array of chart data objects for pie data objects\n       *\n       * @method pieData\n       * @returns {*} Array of chart data objects\n       */\n\n    }, {\n      key: 'pieData',\n      value: function pieData() {\n        if (!this.data.slices) {\n          return this.data.rows ? this.data.rows : this.data.columns;\n        }\n        return [this.data];\n      }\n\n      /**\n       * Get attributes off the data, e.g. `tooltipFormatter` or `xAxisFormatter`\n       * pulls the value off the first item in the array\n       * these values are typically the same between data objects of the same chart\n       * TODO: May need to verify this or refactor\n       *\n       * @method get\n       * @param thing {String} Data object key\n       * @returns {*} Data object value\n       */\n\n    }, {\n      key: 'get',\n      value: function get(thing, def) {\n        var source = (this.data.rows || this.data.columns || [this.data])[0];\n        return _lodash2.default.get(source, thing, def);\n      }\n\n      /**\n       * Returns true if null values are present\n       * @returns {*}\n       */\n\n    }, {\n      key: 'hasNullValues',\n      value: function hasNullValues() {\n        var chartData = this.chartData();\n\n        return chartData.some(function (chart) {\n          return chart.series.some(function (obj) {\n            return obj.values.some(function (d) {\n              return d.y === null;\n            });\n          });\n        });\n      }\n\n      /**\n       * Return an array of all value objects\n       * Pluck the data.series array from each data object\n       * Create an array of all the value objects from the series array\n       *\n       * @method flatten\n       * @returns {Array} Value objects\n       */\n\n    }, {\n      key: 'flatten',\n      value: function flatten() {\n        return (0, _lodash2.default)(this.chartData()).pluck('series').flattenDeep().pluck('values').flattenDeep().value();\n      }\n\n      /**\n       * Validates that the Y axis min value defined by user input\n       * is a number.\n       *\n       * @param val {Number} Y axis min value\n       * @returns {Number} Y axis min value\n       */\n\n    }, {\n      key: 'validateUserDefinedYMin',\n      value: function validateUserDefinedYMin(val) {\n        if (!_lodash2.default.isNumber(val)) {\n          throw new Error('validateUserDefinedYMin expects a number');\n        }\n        return val;\n      }\n\n      /**\n       * Helper function for getNames\n       * Returns an array of objects with a name (key) value and an index value.\n       * The index value allows us to sort the names in the correct nested order.\n       *\n       * @method returnNames\n       * @param array {Array} Array of data objects\n       * @param index {Number} Number of times the object is nested\n       * @param columns {Object} Contains name formatter information\n       * @returns {Array} Array of labels (strings)\n       */\n\n    }, {\n      key: 'returnNames',\n      value: function returnNames(array, index, columns) {\n        var names = [];\n        var self = this;\n\n        _lodash2.default.forEach(array, function (obj) {\n          names.push({\n            label: obj.name,\n            values: obj,\n            index: index\n          });\n\n          if (obj.children) {\n            var plusIndex = index + 1;\n\n            _lodash2.default.forEach(self.returnNames(obj.children, plusIndex, columns), function (namedObj) {\n              names.push(namedObj);\n            });\n          }\n        });\n\n        return names;\n      }\n\n      /**\n       * Flattens hierarchical data into an array of objects with a name and index value.\n       * The indexed value determines the order of nesting in the data.\n       * Returns an array with names sorted by the index value.\n       *\n       * @method getNames\n       * @param data {Object} Chart data object\n       * @param columns {Object} Contains formatter information\n       * @returns {Array} Array of names (strings)\n       */\n\n    }, {\n      key: 'getNames',\n      value: function getNames(data, columns) {\n        var slices = data.slices;\n\n        if (slices.children) {\n          var namedObj = this.returnNames(slices.children, 0, columns);\n\n          return (0, _lodash2.default)(namedObj).sortBy(function (obj) {\n            return obj.index;\n          }).unique(function (d) {\n            return d.label;\n          }).value();\n        }\n      }\n\n      /**\n       * Removes zeros from pie chart data\n       * @param slices\n       * @returns {*}\n       */\n\n    }, {\n      key: '_removeZeroSlices',\n      value: function _removeZeroSlices(slices) {\n        var self = this;\n\n        if (!slices.children) return slices;\n\n        slices = _lodash2.default.clone(slices);\n        slices.children = slices.children.reduce(function (children, child) {\n          if (child.size !== 0) {\n            children.push(self._removeZeroSlices(child));\n          }\n          return children;\n        }, []);\n\n        return slices;\n      }\n\n      /**\n       * Returns an array of names ordered by appearance in the nested array\n       * of objects\n       *\n       * @method pieNames\n       * @returns {Array} Array of unique names (strings)\n       */\n\n    }, {\n      key: 'pieNames',\n      value: function pieNames(data) {\n        var self = this;\n        var names = [];\n\n        _lodash2.default.forEach(data, function (obj) {\n          var columns = obj.raw ? obj.raw.columns : undefined;\n          obj.slices = self._removeZeroSlices(obj.slices);\n\n          _lodash2.default.forEach(self.getNames(obj, columns), function (name) {\n            names.push(name);\n          });\n        });\n\n        return _lodash2.default.uniq(names, 'label');\n      }\n\n      /**\n       * Inject zeros into the data\n       *\n       * @method injectZeros\n       * @returns {Object} Data object with zeros injected\n       */\n\n    }, {\n      key: 'injectZeros',\n      value: function injectZeros(data) {\n        var orderBucketsBySum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        return _injectZeros(data, this.data, orderBucketsBySum);\n      }\n\n      /**\n       * Returns an array of all x axis values from the data\n       *\n       * @method xValues\n       * @returns {Array} Array of x axis values\n       */\n\n    }, {\n      key: 'xValues',\n      value: function xValues() {\n        var orderBucketsBySum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        return orderKeys(this.data, orderBucketsBySum);\n      }\n\n      /**\n       * Return an array of unique labels\n       * Curently, only used for vertical bar and line charts,\n       * or any data object with series values\n       *\n       * @method getLabels\n       * @returns {Array} Array of labels (strings)\n       */\n\n    }, {\n      key: 'getLabels',\n      value: function getLabels() {\n        return _getLabels2(this.data);\n      }\n\n      /**\n       * Returns a function that does color lookup on labels\n       *\n       * @method getColorFunc\n       * @returns {Function} Performs lookup on string and returns hex color\n       */\n\n    }, {\n      key: 'getColorFunc',\n      value: function getColorFunc() {\n        if (this.type === 'slices') {\n          return this.getPieColorFunc();\n        }\n        var defaultColors = this.uiState.get('vis.defaultColors');\n        var overwriteColors = this.uiState.get('vis.colors');\n        var colors = defaultColors ? _lodash2.default.defaults({}, overwriteColors, defaultColors) : overwriteColors;\n        return color(this.getLabels(), colors);\n      }\n\n      /**\n       * Returns a function that does color lookup on names for pie charts\n       *\n       * @method getPieColorFunc\n       * @returns {Function} Performs lookup on string and returns hex color\n       */\n\n    }, {\n      key: 'getPieColorFunc',\n      value: function getPieColorFunc() {\n        return color(this.pieNames(this.getVisData()).map(function (d) {\n          return d.label;\n        }), this.uiState.get('vis.colors'));\n      }\n\n      /**\n       * ensure that the datas ordered property has a min and max\n       * if the data represents an ordered date range.\n       *\n       * @return {undefined}\n       */\n\n    }, {\n      key: '_normalizeOrdered',\n      value: function _normalizeOrdered() {\n        var data = this.getVisData();\n        var self = this;\n\n        data.forEach(function (d) {\n          if (!d.ordered || !d.ordered.date) return;\n\n          var missingMin = d.ordered.min == null;\n          var missingMax = d.ordered.max == null;\n\n          if (missingMax || missingMin) {\n            var extent = _d2.default.extent(self.xValues());\n            if (missingMin) d.ordered.min = extent[0];\n            if (missingMax) d.ordered.max = extent[1];\n          }\n        });\n      }\n\n      /**\n       * Calculates min and max values for all map data\n       * series.rows is an array of arrays\n       * each row is an array of values\n       * last value in row array is bucket count\n       *\n       * @method mapDataExtents\n       * @param series {Array} Array of data objects\n       * @returns {Array} min and max values\n       */\n\n    }, {\n      key: 'mapDataExtents',\n      value: function mapDataExtents(series) {\n        var values = _lodash2.default.map(series.rows, function (row) {\n          return row[row.length - 1];\n        });\n        return [_lodash2.default.min(values), _lodash2.default.max(values)];\n      }\n\n      /**\n       * Get the maximum number of series, considering each chart\n       * individually.\n       *\n       * @return {number} - the largest number of series from all charts\n       */\n\n    }, {\n      key: 'maxNumberOfSeries',\n      value: function maxNumberOfSeries() {\n        return this.chartData().reduce(function (max, chart) {\n          return Math.max(max, chart.series.length);\n        }, 0);\n      }\n    }]);\n\n    return Data;\n  }();\n\n  return Data;\n}",null]}